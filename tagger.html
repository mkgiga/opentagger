
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>opentagger</title>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="theme-color" content="#f0f0f0" />
        <link rel="icon" href="/assets/images/favicon.ico" type="image/x-icon" />
        
        <!-- third-party imports -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/neat.min.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css" />
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
        
        <!-- opengraph metadata -->
        <meta property="og:title" content="opentagger" />
        <meta property="og:description" content="The easiest way to tag your images." />
        <meta property="og:image" content="/assets/images/opentagger.png" />
        <meta property="og:url" content="https://opentagger.org" />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="opentagger" />
        <meta property="og:locale" content="en_US" />
        <meta property="og:locale:alternate" content="en_GB" />
        <meta property="og:locale:alternate" content="en_CA" />
        <meta property="og:locale:alternate" content="en_AU" />

        <!-- twitter metadata -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="opentagger" />
        <meta name="twitter:description" content="The easiest way to tag your images." />
        <meta name="twitter:image" content="/assets/images/opentagger.png" />
        

        <style>
            :root {
                --menu-bar-height: 28px;
                --splash-ide-bg: #f3f3f3;
                --splash-ide-content-bg: #fcfcfc;
                --splash-ide-text-primary: #222222;
                --splash-ide-text-secondary: #555555;
                --splash-ide-accent: #007acc;
                --splash-ide-border: #dcdcdc;
                --splash-ide-hover-bg: rgba(0, 122, 204, 0.08);
            }

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol";
                display: flex;
                flex-direction: column;
                height: 100vh;
                overflow: hidden;
                background-color: #f0f0f0;
                color: #333;
            }

            #menu-bar {
                background-color: #e0e0e0;
                padding: 2px 5px;
                border-bottom: 1px solid #ccc;
                flex-shrink: 0;
                height: var(--menu-bar-height);
                display: flex;
                align-items: center;
            }

            #menu-bar button {
                background: none;
                border: none;
                padding: 4px 8px;
                cursor: pointer;
                font-size: 0.85em;
            }

            #menu-bar button:hover {
                background-color: #d0d0d0;
            }

            #app {
                display: flex;
                flex-grow: 1;
                overflow: hidden;
                height: calc(100vh - var(--menu-bar-height));
            }

            #app > .sidebar,
            #app > .main-view {
                display: none;
            }

            #app.loaded > .sidebar,
            #app.loaded > .main-view {
                display: flex;
            }

            #splash-screen {
                position: fixed;
                top: var(--menu-bar-height);
                left: 0;
                right: 0;
                bottom: 0;
                background-color: var(--splash-ide-bg);
                z-index: 500;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                transition: opacity 0.4s ease-out, visibility 0.4s ease-out;
            }

            #splash-screen.hidden {
                opacity: 0;
                visibility: hidden;
                pointer-events: none;
            }

            .splash-ide-container {
                width: 90vw;
                max-width: 1050px;
                height: auto;
                max-height: calc(100vh - var(--menu-bar-height) - 40px);
                background-color: var(--splash-ide-content-bg);
                border: 1px solid var(--splash-ide-border);
                border-radius: 6px;
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .splash-ide-header {
                padding: 25px 35px 15px 35px;
                border-bottom: 1px solid var(--splash-ide-border);
            }
            .splash-ide-header h1 {
                font-size: 2em;
                font-weight: 600;
                color: var(--splash-ide-text-primary);
                margin-bottom: 2px;
            }
            .splash-ide-header p {
                font-size: 0.95em;
                color: var(--splash-ide-text-secondary);
            }

            .splash-ide-content-area {
                display: flex;
                flex-grow: 1;
                padding: 25px 35px;
                gap: 35px;
                overflow-y: auto;
            }

            .splash-ide-column {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 25px;
                min-width: 0;
            }
            .splash-ide-column:first-child {
                flex-basis: 55%;
            }
            .splash-ide-column:last-child {
                flex-basis: 45%;
            }

            .splash-ide-section h2 {
                font-size: 1.05em;
                font-weight: 500;
                color: var(--splash-ide-text-secondary);
                margin-bottom: 12px;
            }

            .splash-ide-list {
                list-style: none;
                padding: 0;
                margin: 0;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .splash-ide-list li button,
            .splash-ide-list li a.splash-ide-info-item,
            .splash-ide-list li div.splash-ide-info-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 10px;
                border-radius: 4px;
                background: none;
                border: none;
text-align: left;
                cursor: pointer;
                width: 100%;
                color: var(--splash-ide-text-primary);
                font-size: 0.9em;
                transition: background-color 0.15s ease-in-out;
                text-decoration: none;
            }
            .splash-ide-list li button:hover,
            .splash-ide-list li a.splash-ide-info-item:hover {
                background-color: var(--splash-ide-hover-bg);
                color: var(--splash-ide-accent);
            }
            .splash-ide-list li button:hover .material-icons,
            .splash-ide-list li a.splash-ide-info-item:hover .material-icons {
                color: var(--splash-ide-accent);
            }

            .splash-ide-list li button .material-icons,
            .splash-ide-list li .splash-ide-info-item .material-icons {
                color: var(--splash-ide-accent);
                font-size: 22px;
                flex-shrink: 0;
            }
            .splash-ide-list li button span:last-of-type,
            .splash-ide-list li .splash-ide-info-item div {
                flex-grow: 1;
                line-height: 1.4;
            }

            .splash-ide-info-item div h4 {
                margin: 0 0 2px 0;
                font-size: 0.9em;
                font-weight: 500;
                color: var(--splash-ide-text-primary);
            }
            .splash-ide-info-item div p {
                margin: 0;
                font-size: 0.82em;
                color: var(--splash-ide-text-secondary);
                line-height: 1.45;
            }

            .splash-ide-list.large-icons
                li
                .splash-ide-info-item
                .material-icons {
                font-size: 26px;
                background-color: var(--splash-ide-hover-bg);
                padding: 6px;
                border-radius: 4px;
                margin-right: 4px;
            }
            .splash-ide-list.large-icons
                li
                a.splash-ide-info-item:hover
                .material-icons,
            .splash-ide-list.large-icons
                li
                div.splash-ide-info-item
                .material-icons {
                color: var(--splash-ide-accent);
            }

            .splash-ide-list-placeholder {
                display: flex !important;
                align-items: center;
                gap: 10px;
                padding: 12px 10px !important;
                color: #777;
                font-size: 0.85em !important;
                border: 1px dashed #ddd;
                border-radius: 4px;
                background-color: transparent;
                cursor: default !important;
            }
            .splash-ide-list-placeholder:hover {
                background-color: transparent !important;
            }
            .splash-ide-list-placeholder .material-icons {
                color: #777 !important;
                font-size: 20px !important;
            }

            .splash-anim {
                opacity: 0;
                transform: translateY(15px);
                animation: splash-item-fade-in 0.5s
                    cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            }

            @keyframes splash-item-fade-in {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .sidebar {
                min-width: 250px;
                width: 20svw;
                background-color: #f8f8f8;
                border-right: 1px solid #ccc;
                padding: 15px;
                display: flex;
                flex-direction: column;
                overflow-y: auto;
                flex-shrink: 0;
            }

            .sidebar h2 {
                margin-bottom: 15px;
                font-size: 1.1em;
                color: #555;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }

            #tag-group-list {
                flex-grow: 1;
                margin-bottom: 10px;
            }

            #btn-add-group {
                padding: 8px;
                background-color: #5c85d6;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                margin-top: auto;
            }
            #btn-add-group:hover {
                background-color: #4a6aaa;
            }

            .main-view {
                flex-grow: 1;
                background-color: #fff;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .main-view-header {
                display: flex;
                align-items: center;

                gap: 10px;
                padding: 15px 15px 10px 15px;
                flex-shrink: 0;
                border-bottom: 1px solid #eee;
            }
            .main-view-header h2 {
                margin-bottom: 0;
                flex-shrink: 0;
                font-size: 1.1em;
                color: #555;
            }

            #main-content-area {
                flex-grow: 1;
                overflow-y: auto;
                padding: 15px;
                position: relative;
            }

            #main-content-area .drop-hint {
                text-align: center;
                color: #aaa;
                padding: 40px;
                border: 2px dashed #ddd;
                border-radius: 5px;
                margin-bottom: 20px;
            }

            #main-content-area .drop-hint.no-results {
                border-style: solid;
                color: #888;
            }
            #main-content-area .drop-hint.no-results::before {
                content: "No entries match your search.";
                display: block;
                font-weight: bold;
                margin-bottom: 10px;
            }

            #autotag-all-button {
                background: none;
                border: none;
                border-radius: 8px;
                padding: 5px;
                cursor: pointer;
                font-family: "Material Icons";
                font-size: 20px;
                color: #666;
                line-height: 1;
                transition: background-color 0.2s, color 0.2s, border-color 0.2s;
                width: 28px;
                background: none !important;
            }

            #autotag-all-button:hover:not(:disabled) {
                background-color: #e0e0e0;
                border-color: #bbb;
                color: #333;
            }
            #autotag-all-button.loading {
                color: #5c5cff;
                animation: spin 1s linear infinite;
                cursor: default;
                background: none;
            }
            #autotag-all-button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                background-color: #f0f0f0;
            }

            #search-bar {
                padding: 6px 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 0.9em;
                min-width: 200px;
                max-width: 400px;
                flex-grow: 1;
                margin-left: auto;
            }

            #search-bar:focus {
                outline: none;
                border-color: #5c85d6;
                box-shadow: 0 0 0 2px rgba(92, 133, 214, 0.2);
            }

            dataset-tag {
                display: inline-flex;
                align-items: center;
                background-color: #e7f0ff;
                border: 1px solid #b3d1ff;
                border-radius: 12px;
                padding: 3px 8px 3px 10px;
                margin: 3px;
                font-size: 0.9em;
                cursor: grab;
                user-select: none;
                transition: background-color 0.2s ease;
                min-width: 50px;
                position: relative; /* For autocomplete positioning context */
            }

            dataset-tag:active {
                cursor: grabbing;
            }

            dataset-tag span[contenteditable] {
                outline: none;
                flex-grow: 1;
                min-width: 10px;
                padding-right: 5px;
            }
            dataset-tag span[contenteditable]:focus {
                background-color: #fff;
                box-shadow: 0 0 0 1px #b3d1ff;
            }

            dataset-tag .delete-tag {
                font-family: "Material Icons";
                font-size: 16px;
                cursor: pointer;
                color: #aaa;
                margin-left: 5px;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2px;
                border-radius: 50%;
                border-color: #b3d1ff;
                line-height: 1;
            }

            dataset-tag .delete-tag:hover {
                color: #ff4d4d;
                background-color: #ffe0e0;
            }

            dataset-entry img,
            dataset-entry span:not([contenteditable]),
            dataset-entry button {
                user-select: none;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-button {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 3px;
                border: 1px dashed #ccc;
                border-radius: 12px;
                cursor: pointer;
                color: #777;
                min-width: 26px;
                width: 26px;
                height: 26px;
                box-sizing: border-box;
                background-color: #f9f9f9;
                transition: all 0.2s ease;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-button:hover {
                border-color: #5c85d6;
                color: #5c85d6;
                background-color: #e7f0ff;
            }

            dataset-entry
                > .entry-content
                > tag-list
                > .add-tag-button
                .material-icons {
                font-size: 20px;
                line-height: 1;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-input {
                outline: none;
                background-color: #fff;
                border: 1px solid #b3d1ff;
                box-shadow: 0 0 0 1px #b3d1ff;
                border-radius: 12px;
                padding: 3px 8px 3px 10px;
                margin: 3px;
                font-size: 0.9em;
                min-width: 70px;
                height: 28px;
                box-sizing: border-box;
                line-height: normal;
                vertical-align: middle;
            }

            tag-list {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding: 5px;
                min-height: 30px;
                border-radius: 4px;
                transition: background-color 0.2s ease;
            }

            tag-list[direction="column"] {
                flex-direction: column;
                align-items: flex-start;
                flex-wrap: nowrap;
            }

            tag-list[direction="row"] {
                flex-direction: row;
                align-items: center;
            }

            .drag-over {
                background-color: #e0ffe0 !important;
                border: 1px dashed #8fbc8f;
            }
            dataset-tag.dragging {
                opacity: 0.5;
            }

            dataset-tag.searched-highlight {
                border: 2px solid var(--highlight-border-color, #ff0000);
                padding: 2px 7px 2px 9px;
            }

            dataset-entry {
                display: flex;
                flex-direction: column;
                border: 1px solid #ddd;
                border-radius: 5px;
                margin-bottom: 15px;
                padding: 10px;
                background-color: #fdfdfd;
                transition: box-shadow 0.2s ease, border-color 0.3s ease;
                position: relative;
                cursor: default; /* For selection clicks */
            }

            dataset-entry.requirement-not-met {
                border-color: #ff7b7b;
                box-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
            }

            dataset-entry[selected] {
                border-color: #5c85d6;
                background-color: #e7f0ff;
                box-shadow: 0 0 8px rgba(92, 133, 214, 0.5);
            }

            dataset-entry[selected]::before {
                content: "check_circle";
                font-family: "Material Icons";
                position: absolute;
                top: 8px;
                left: 8px;
                font-size: 22px;
                color: #4a6aaa;
                background-color: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                padding: 2px;
                z-index: 2;
                pointer-events: none;
            }

            dataset-entry[selected].requirement-not-met::after {
            }

            #developer-console {
                background-color: #f7f7f7;
                color: #333;
                border-top: 1px solid #ccc;
                display: flex;
                flex-direction: column;
                z-index: 50;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease-in-out;
                flex-shrink: 0;
            }

            #developer-console.visible {
            }

            #console-output {
                flex-grow: 1;
                padding: 8px;
                overflow-y: auto;
                font-family: "Consolas", "Monaco", monospace;
                font-size: 0.85em;
                line-height: 1.5;
                min-height: 2em;
            }

            #console-output .console-message {
                padding: 3px 5px;
                border-bottom: 1px solid #e8e8e8;
                word-break: break-all;
            }
            #console-output .console-message:nth-child(even) {
                background-color: #efefef;
            }
            #console-output .console-message:last-child {
                border-bottom: none;
            }

            #console-output .console-message.command {
                color: #005cbb;
                font-weight: bold;
            }
            #console-output .console-message.error {
                color: #c00;
            }
            #console-output .console-message.success {
                color: #007700;
            }
            #console-output .console-message.info {
                color: #555;
            }
            #console-output .console-message pre {
                white-space: pre-wrap;
word-wrap: break-word; /* Use word-wrap for older browsers */
                overflow-wrap: break-word; /* Use overflow-wrap for modern browsers */
                margin: 0;
                font-family: inherit;
            }

            .CodeMirror {
                border-top: 1px solid #ccc;
                font-family: "Consolas", "Monaco", monospace;
                font-size: 0.9em;
                height: auto;
                min-height: 2.5em;
                max-height: 15em;
            }
            .CodeMirror-scroll {
                min-height: 2.5em;
            }
            .CodeMirror-hints {
                position: absolute;
                background: #fff;
                border: 1px solid #ddd;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
                z-index: 101; /* Ensure it's above CodeMirror itself */
                max-height: 10em;
                overflow-y: auto;
            }
            .CodeMirror-hint {
                color: #333;
                padding: 2px 5px;
            }
            li.CodeMirror-hint-active {
                background: #e7f0ff;
                color: #005cbb;
            }

            autocomplete-dropdown {
                position: absolute;
                background-color: #fff;
                border: 1px solid #ccc;
                box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15);
                padding: 3px 0;
                min-width: 150px; 
                z-index: 2500; 
                display: none; 
                flex-direction: column;
                max-height: 200px; 
                overflow-y: auto;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                font-size: 0.9em;
            }

            autocomplete-dropdown.visible {
                display: flex;
            }

            autocomplete-dropdown div.suggestion-item {
                padding: 5px 10px;
                cursor: pointer;
                white-space: nowrap;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            autocomplete-dropdown div.suggestion-item:hover,
            autocomplete-dropdown div.suggestion-item.selected {
                background-color: #e7f0ff; 
                color: #005cbb; 
            }
            autocomplete-dropdown div.suggestion-item.selected .tag-count {
                 color: #005cbb; /* Match text color */
            }


            autocomplete-dropdown div.suggestion-item .tag-name {
                font-weight: normal; /* Default, can be overridden */
            }
            autocomplete-dropdown div.suggestion-item.selected .tag-name {
                font-weight: bold;
            }

            autocomplete-dropdown div.suggestion-item .tag-count {
                font-size: 0.85em;
                color: #777;
                margin-left: 8px;
            }


            dataset-entry.requirement-not-met::after {
                content: "warning";
                font-family: "Material Icons";
                position: absolute;
                top: 5px;

                right: 76px;
                color: #ff4d4d;
                font-size: 20px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                padding: 4px;
                pointer-events: none;
                z-index: 2;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 28px;
                height: 28px;
            }

            dataset-entry:hover {
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            }

            dataset-entry .entry-content {
                display: flex;
                flex-direction: row;
                gap: 10px;
                align-items: flex-start;
            }

            dataset-entry img {
                max-width: 150px;
                max-height: 150px;
                height: auto;
                object-fit: contain;
                border-radius: 3px;
                flex-shrink: 0;
                cursor: pointer;
            }

            dataset-entry tag-list {
                flex-grow: 1;
                border: 1px solid #eee;
                align-self: stretch;
            }

            dataset-entry .entry-buttons {
                position: absolute;
                top: 5px;
                right: 38px;
                display: flex;
                align-items: center;
                gap: 5px;
                z-index: 1;
            }

            dataset-entry .autotag-entry {
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #aaa;
                font-family: "Material Icons";
                font-size: 20px;
                padding: 4px;
                width: 28px;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                transition: background-color 0.2s, color 0.2s;
            }

            dataset-entry .delete-entry {
                position: absolute;
                top: 5px;
                right: 5px;
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #aaa;
                font-family: "Material Icons";
                font-size: 20px;
                padding: 4px;
                width: 28px;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                z-index: 1;
                transition: background-color 0.2s, color 0.2s;
            }

            dataset-entry .delete-entry:hover {
                background-color: #ffe0e0;
                color: #ff4d4d;
            }

            dataset-entry .autotag-entry:hover:not(:disabled) {
                background-color: #e0e0ff;
                color: #5c5cff;
            }
            dataset-entry .autotag-entry.loading {
                color: #5c5cff;
                animation: spin 1s linear infinite;
            }
            dataset-entry .autotag-entry.loading:hover {
                background-color: rgba(255, 255, 255, 0.7);
            }
            dataset-entry .autotag-entry:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                background-color: rgba(230, 230, 230, 0.7);
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            tag-group {
                display: block;
                margin-bottom: 15px;
                border: 1px solid #e0e0e0;
                padding: 10px;
                border-radius: 4px;
                background-color: #fff;
                position: relative;
            }

            tag-group .group-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                cursor: default;
                gap: 5px;
            }

            tag-group .group-name {
                font-weight: bold;
                color: #666;
                padding: 3px 5px;
                border-radius: 3px;
                cursor: text;
                outline: none;
                flex-grow: 1;
                min-width: 50px;
                margin-right: 5px;
            }
            tag-group .group-name:hover {
                background-color: #f0f0f0;
            }
            tag-group .group-name:focus {
                background-color: #e7f0ff;
                box-shadow: 0 0 0 1px #b3d1ff;
            }

            tag-group .min-tags-control {
                display: flex;
                align-items: center;
                gap: 3px;
                color: #777;
                font-size: 0.85em;
                margin-left: auto;
                flex-shrink: 0;
            }
            tag-group .min-tags-control button {
                font-family: "Material Icons";
                font-size: 18px;
                cursor: pointer;
                color: #999;
                padding: 0;
                border: none;
                background: none;
                line-height: 1;
                width: 18px;
                height: 18px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border-radius: 3px;
            }
            tag-group .min-tags-control button:hover {
                background-color: #eee;
                color: #333;
            }
            tag-group .min-tags-value {
                min-width: 15px;
                text-align: center;
                font-weight: bold;
            }

            tag-group .btn-new-tag {
                font-family: "Material Icons";
                font-size: 20px;
                cursor: pointer;
                color: #5c85d6;
                padding: 2px;
                border-radius: 50%;
                background: none;
                border: none;
                flex-shrink: 0;
            }

            tag-group .btn-new-tag:hover {
                background-color: #e7f0ff;
                color: #4a6aaa;
            }

            tag-group tag-list {
                min-height: 40px;
                padding-bottom: 10px;
                position: relative;
            }

            context-menu {
                position: absolute;
                background-color: #fff;
                border: 1px solid #ccc;
                box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15);
                padding: 3px 0;
                min-width: 150px;
                z-index: 1000;
                display: none;
                flex-direction: column;
            }

            context-menu.visible {
                display: flex;
            }

            menu-item {
                display: flex;
                align-items: center;
                padding: 5px 12px;
                cursor: pointer;
                font-size: 0.85em;
                white-space: nowrap;
                position: relative;
            }

            menu-item:hover {
                background-color: #e7f0ff;
            }

            menu-item.disabled {
                opacity: 0.5;
                pointer-events: none;
                cursor: default;
            }

            menu-item .submenu-arrow {
                margin-left: auto;
                font-size: 14px;
                color: #777;
            }
            menu-item context-menu {
                top: -6px;
                left: 100%;
                margin-left: -5px;
                display: none;
            }

            menu-item:hover > context-menu {
                display: flex;
            }

            context-menu hr {
                border: none;
                border-top: 1px solid #eee;
                margin: 3px 5px;
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            }

            .modal-content {
                background-color: #fff;
                padding: 25px 30px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 450px;
                width: 90%;
                text-align: center;
            }

            .modal-message {
                margin-bottom: 20px;
                font-size: 1.1em;
                line-height: 1.5;
                color: #444;
                white-space: pre-wrap;
            }

            .modal-buttons {
                display: flex;
                justify-content: center;
                gap: 15px;
            }

            .modal-buttons button {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                min-width: 80px;
                transition: background-color 0.2s ease;
            }

            .modal-buttons .modal-button-confirm {
                background-color: #5c85d6;
                color: white;
            }
            .modal-buttons .modal-button-confirm:hover {
                background-color: #4a6aaa;
            }

            .modal-buttons .modal-button-cancel {
                background-color: #ccc;
                color: #333;
            }
            .modal-buttons .modal-button-cancel:hover {
                background-color: #bbb;
            }

            .modal-buttons .modal-button-default {
                background-color: #e0e0e0;
                color: #333;
            }
            .modal-buttons .modal-button-default:hover {
                background-color: #d0d0d0;
            }

            .image-preview-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.65);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1500;
                padding: 2vh;
            }

            .image-preview-content {
                position: relative;
                background-color: #fff;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 90vw;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }
            .image-preview-content img {
                display: block;
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
                margin-bottom: 15px;
                flex-shrink: 1;
                flex-grow: 1;
                min-height: 50px;
            }

            .image-preview-info {
                flex-shrink: 0;
                text-align: center;
                margin-top: auto;
                font-size: 0.95em;
                color: #333;
                line-height: 1.4;
            }
            .image-preview-info strong {
                word-break: break-all;
            }

            .image-preview-close {
                position: absolute;
                top: 5px;
                right: 5px;
                font-size: 24px;
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #555;
                padding: 3px;
                z-index: 1501;
                line-height: 1;
            }
            .image-preview-close:hover {
                color: #000;
                background: rgba(255, 255, 255, 0.9);
            }

            .autotag-timer-label {
                display: inline-block;
                background-color: #e9e9e9;
                border: 1px solid #dcdcdc;
                border-radius: 10px;
                padding: 2px 7px;
                margin-left: 6px;
                font-size: 0.8em;
                color: #555;
                line-height: 1.2;
                vertical-align: middle;
                opacity: 1;
                transition: opacity 0.5s ease-out 1.5s;
            }

            .autotag-timer-label.fade-out {
                opacity: 0;
            }
        </style>
    </head>
    <body>
        <audio id="sfxWelcome" src="assets/audio/jingle.ogg"></audio>
        <audio id="sfxGood1" src="assets/audio/sweet.ogg"></audio>
        <audio id="sfxGood2" src="assets/audio/sweet2.ogg"></audio>
        <audio id="sfxGood3" src="assets/audio/sweet3.ogg"></audio>
        <audio id="sfxBad" src="assets/audio/uhoh.ogg"></audio>
        <audio id="sfxGoodnight" src="assets/audio/goodnight.ogg"></audio>
        <audio id="sfxPop" src="assets/audio/pop.ogg"></audio>

        <nav id="menu-bar">
            <button>File</button>
            <button>Edit</button>
            <button>Select</button> <!-- Selection-related actions -->
            <button>View</button>
            <button>Help</button>
        </nav>

        <div id="splash-screen">
            <div
                class="splash-ide-container splash-anim"
                style="animation-delay: 0s"
            >
                <div
                    class="splash-ide-header splash-anim"
                    style="animation-delay: 0.05s"
                >
                    <h1>opentagger</h1>
                    <p>
                        Really simple image tagging
                    </p>
                </div>

                <div
                    class="splash-ide-content-area splash-anim"
                    style="animation-delay: 0.1s"
                >
                    <div class="splash-ide-column">
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.15s"
                        >
                            <h2>Start</h2>
                            <ul class="splash-ide-list">
                                <li>
                                    <button id="splash-new-project">
                                        <span class="material-icons"
                                            >add_box</span
                                        >
                                        <span>New Project...</span>
                                    </button>
                                </li>
                                <li>
                                    <button id="splash-open-project">
                                        <span class="material-icons"
                                            >folder_open</span
                                        >
                                        <span>Open Project...</span>
                                    </button>
                                </li>
                            </ul>
                        </div>
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.2s"
                        >
                            <h2>Recent</h2>
                            <ul
                                class="splash-ide-list"
                                id="splash-recent-projects-list"
                            >
                                <li class="splash-ide-list-placeholder">
                                    <span class="material-icons">history</span>
                                    <span
                                        >No recent projects to show. Feature
                                        coming soon™</span
                                    >
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div class="splash-ide-column">
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.25s"
                        >
                            <h2>Learn & Discover</h2>
                            <ul class="splash-ide-list large-icons">
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >school</span
                                        >
                                        <div>
                                            <h4>Getting Started Guide</h4>
                                            <p>
                                                Need pointers on how to get
                                                started? Click here for a quick
                                                guide!
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >auto_fix_high</span
                                        >
                                        <div>
                                            <h4>Autotagging</h4>
                                            <p>
                                                Automatically tag your images
                                                with a local AI model.
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >integration_instructions</span
                                        >
                                        <div>
                                            <h4>Advanced Scripting</h4>
                                            <p>
                                                Unlock powerful features with
                                                the console and slash commands.
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <div
                                        class="splash-ide-info-item whats-new-item"
                                    >
                                        <span class="material-icons"
                                            >campaign</span
                                        >
                                        <div>
                                            <h4>What's New in v0.1.0</h4>
                                            <p>
                                                Initial release: Core tagging,
                                                project management, developer
                                                console, and autotagging
                                                features.
                                            </p>
                                        </div>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="app">
            <aside class="sidebar">
                <h2>Tag Groups</h2>
                <div id="tag-group-list">
                    <tag-group group-name="General">
                        <dataset-tag>1girl</dataset-tag>
                        <dataset-tag>1boy</dataset-tag>
                        <dataset-tag>solo</dataset-tag>
                        <dataset-tag>multiple boys</dataset-tag>
                        <dataset-tag>multiple girls</dataset-tag>
                    </tag-group>
                    <tag-group group-name="Angle">
                        <dataset-tag>from below</dataset-tag>
                        <dataset-tag>from above</dataset-tag>
                        <dataset-tag>from behind</dataset-tag>
                        <dataset-tag>from side</dataset-tag>
                        <dataset-tag>straight-on</dataset-tag>
                        <dataset-tag>three quarter view</dataset-tag>
                    </tag-group>
                    <tag-group group-name="Composition">
                        <dataset-tag>close-up</dataset-tag>
                        <dataset-tag>portrait</dataset-tag>
                        <dataset-tag>upper body</dataset-tag>
                        <dataset-tag>cowboy shot</dataset-tag>
                        <dataset-tag>full body</dataset-tag>
                        <dataset-tag>wide shot</dataset-tag>
                        <dataset-tag>very wide shot</dataset-tag>
                    </tag-group>
                    <tag-group group-name="Background">
                        <dataset-tag>simple background</dataset-tag>
                        <dataset-tag>indoors</dataset-tag>
                        <dataset-tag>outdoors</dataset-tag>
                        <dataset-tag>city</dataset-tag>
                        <dataset-tag>nature</dataset-tag>
                    </tag-group>
                    <tag-group group-name="Style">
                        <dataset-tag>anime coloring</dataset-tag>
                        <dataset-tag>realistic</dataset-tag>
                        <dataset-tag>sketch</dataset-tag>
                        <dataset-tag>3d</dataset-tag>
                        <dataset-tag>lineart</dataset-tag>
                        <dataset-tag>comic</dataset-tag>
                        <dataset-tag>furry</dataset-tag>
                    </tag-group>
                </div>
                <button id="btn-add-group">Add Group</button>
            </aside>

            <main class="main-view" id="main-view">
                <div class="main-view-header">
                    <h2>Dataset Entries</h2>
                    <button
                        id="autotag-all-button"
                        class="material-icons"
                        title="Autotag All Visible Entries"
                        speaker="Autotag All Visible Entries"
                    >
                        auto_awesome_stack
                    </button>
                    <input
                        type="search"
                        id="search-bar"
                        placeholder="Search tags (e.g., 1girl && smile || (cat && black_fur))"
                    />
                </div>
                <div id="main-content-area">
                    <p class="drop-hint">Drag & Drop Images Here</p>
                </div>
                <div id="developer-console">
                    <div id="console-output"></div>
                    <textarea
                        id="console-input"
                        placeholder="Press F1 to toggle. Type /help for commands, or JS code."
                    ></textarea>
                </div>
            </main>
        </div>

        <input
            type="file"
            id="project-file-input"
            accept=".loraproj"
            style="display: none"
        />

        <input
            type="file"
            id="dataset-zip-input"
            accept=".zip"
            style="display: none"
        />
        
        <autocomplete-dropdown id="tag-autocomplete-dropdown" translate="no"></autocomplete-dropdown>


        <!-- todo: bundle these with a build tool like webpack or something -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/javascript-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/comment/comment.min.js"></script>
        <script defer>
            "use strict";

            let draggedElement = null;
            const PROJECT_FILE_EXTENSION = ".loraproj";
            let mainView = null;
            let mainContentAreaElement = null;
            let appContainer = null;
            let splashScreenElement = null;
            let dropHint = null;
            let searchInput = null;
            let autotagAllButton = null;
            const AUTOTAG_API_URL = "http://localhost:8081/autotag/";
            const HEALTH_CHECK_URL = "http://localhost:8081/health";

            let globalParsedSearchTerms = [];
            let globalSearchTermColors = {};
            // now stores the entry that was the *anchor* for the last selection operation (simple click or ctrl+click)
            let globalLastClickedEntryForShiftSelect = null;

            // TODO: this should probably be its own web component
            let devConsoleElement = null;
            let consoleOutputElement = null;
            const CONSOLE_MAX_HEIGHT_PERCENT = 40;
            let isConsoleVisible = false;
            let consoleCodeMirrorInstance = null;
            let consoleHistory = [];
            let consoleHistoryIndex = -1;
            let currentConsoleInputBuffer = "";
            let hasShownConsoleWelcomeMessage = false;

            // User config defaults,
            // load from localStorage later and dynamically generate a UI from these later using their default values to infer types
            const preferences = {
                // an object means it's a section with sub-options
                // this can nest indefinitely, but the outermost key exists as a toggle to render all of its ancestors resulting UI.
                // if any other outer category's button is toggled, it will be hidden and that category's UI will become visible instead.
                importingImages: {
                    minimumHeight: 768,
                    minimumWidth: 768,
                    maximumHeight: 4096,
                    maximumWidth: 4096,
                    minimumPixelsSum: -1, // -1 means no limit
                    maximumPixelsSum: -1,
                },
                tagging: {
                    tagAutoComplete: {
                        enabled: true,
                        maxSuggestions: 10, // Maximum number of suggestions to show
                        csvFile: {
                            // any object that has a '@type' property means the option is a special type rendered differently
                            // in this case, a <select> element with <option>s
                            "@type": "select",
                            "value": "danbooru_e621_merged.csv",
                            "options": [
                                "e621.csv",
                                "danbooru.csv",    
                                "danbooru_e621_merged.csv"
                            ]
                        }
                    }
                },
                autotagging: {
                    enabled: true,
                    endpoint: AUTOTAG_API_URL,
                    batchSize: 5, // Number of images to process in a single request
                    timeout: 30000, // 30 seconds
                    autotaggingModel: {
                        "@type": "select",
                        "value": "wd-vit-tagger-v3",
                        "options": [
                            "wd-vit-tagger-v3",
                            "wd-vit-tagger-v2",
                            "wd-vit-tagger-v1"
                        ]
                    }
                }

            }


            /**
             * @type {{ [id: string]: HTMLAudioElement }}
             */
            const sfx = {
                sfxWelcome: null,
                sfxGood1: null,
                sfxGood2: null,
                sfxGood3: null,
                sfxBad: null,
                sfxGoodnight: null,
                sfxPop: null,
            };

            const fadeOutAudioContext = new AudioContext({
                sampleRate: 44100,
                latencyHint: "interactive",
            });

            for (const key in sfx) {
                const audio = document.getElementById(key);
                audio.volume = 0.1;
                sfx[key] = audio;
            };

            // Autocomplete for Booru Tags
            let booruTags = [];
            let booruTagsLoadingPromise = null;
            const MAX_SUGGESTIONS = 10;
            let globalTagAutocompleteDropdown = null;


            async function loadBooruTags() {
                if (booruTags.length > 0) return booruTags;
                if (booruTagsLoadingPromise) return booruTagsLoadingPromise;

                console.log("Initiating booru tag loading...");
                booruTagsLoadingPromise = fetch('/assets/csv/danbooru_e621_merged.csv')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status} while fetching tags.`);
                        }
                        return response.text();
                    })
                    .then(csvText => {
                        const lines = csvText.split('\n');
                        const loadedTags = [];
                        // Assuming the first line is a header: "tag_name,type_n,image_count,aliases"
                        for (let i = 1; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            const parts = [];
                            let currentPart = '';
                            let inQuotes = false;
                            for (const char of line) {
                                if (char === ',' && !inQuotes) {
                                    parts.push(currentPart);
                                    currentPart = '';
                                } else if (char === '"') {
                                    inQuotes = !inQuotes;
                                    // Don't add quotes to the part itself for aliases,
                                    // but respect them for parsing
                                } else {
                                    currentPart += char;
                                }
                            }
                            parts.push(currentPart);

                            if (parts.length >= 3) {
                                const tagName = parts[0].trim();
                                const typeN = parseInt(parts[1], 10);
                                const imageCount = parseInt(parts[2], 10);
                                // const aliases = parts[3] ? parts[3].trim() : ''; // Aliases raw string

                                if (tagName && !isNaN(typeN) && !isNaN(imageCount)) {
                                    loadedTags.push({
                                        name: tagName,
                                        type: typeN,
                                        count: imageCount,
                                    });
                                }
                            }
                        }
                        booruTags = loadedTags;
                        // Sort once after loading, by count descending for general use
                        booruTags.sort((a, b) => b.count - a.count);
                        console.log(`Loaded and sorted ${booruTags.length} booru tags.`);
                        return booruTags;
                    })
                    .catch(error => {
                        console.error("Failed to load or parse booru tags:", error);
                        booruTagsLoadingPromise = null;
                        booruTags = [];
                        return [];
                    });
                return booruTagsLoadingPromise;
            }


            async function checkBackendReady(maxRetries = 30, delay = 1000) {
                console.log(
                    `Checking backend readiness at ${HEALTH_CHECK_URL}...`
                );
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(HEALTH_CHECK_URL);
                        if (response.ok) {
                            const data = await response.json();
                            console.log("Python backend is ready:", data);
                            return true;
                        } else {
                            console.warn(
                                `Backend health check failed with status ${
                                    response.status
                                }. Attempt ${i + 1}/${maxRetries}.`
                            );
                        }
                    } catch (err) {
                        console.warn(
                            `Backend not ready yet (attempt ${
                                i + 1
                            }/${maxRetries}): ${err.message}. Retrying in ${
                                delay / 1000
                            }s...`
                        );
                    }
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
                console.error(
                    "Python backend did not become ready after multiple retries."
                );
                return false;
            }

                        const opentaggerAPI = {
                search: (...args) => {
                    const query = args.join(" ").trim();
                    if (searchInput) {
                        searchInput.value = query;
                        filterEntries(query);
                    } else {
                        filterEntries(query);
                    }
                    logToConsole(
                        `API: opentaggerAPI.search("${query}") executed.`
                    );
                    return `Search initiated for: "${query}"`;
                },
                selectEntries: (query, append = false) => {
                    if (!mainContentAreaElement) {
                        logToConsole(
                            "Error: Main content area not found.",
                            "error"
                        );
                        return "Selection failed: Main content area not found.";
                    }

                    if (!append) {
                        opentaggerAPI.deselectAllEntries(true);
                    }

                    const entries =
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry"
                        );
                    const normalizedQuery = query.trim().toLowerCase();
                    let selectionCount = 0;

                    // Get visible entries to apply selection only to them if query is empty
                    const visibleEntries = Array.from(mainContentAreaElement.querySelectorAll('dataset-entry:not([style*="display: none"])'));

                    for (const entry of entries) {
                        const isVisible = entry.style.display !== "none";
                        let match = false;

                        if (normalizedQuery === "") {
                            // If query is empty, select only visible entries
                            match = isVisible;
                        } else {
                            // If query exists, match based on query AND visibility
                            const tags = entry.getNormalizedTags();
                            match = evaluateExpression(normalizedQuery, tags) && isVisible;
                        }

                        if (match) {
                            entry.selected = true;
                            selectionCount++;
                        } else if (!append && entry.selected) {
                             // If not appending and entry is selected but doesn't match or isn't visible, deselect it
                             entry.selected = false;
                        }
                    }

                    // Update g_lastClickedEntryForShiftSelect if only one entry is selected after the operation
                    const currentlySelected = opentaggerAPI.getSelectedEntries();
                    if (currentlySelected.length === 1) {
                         globalLastClickedEntryForShiftSelect = currentlySelected[0];
                    } else {
                         globalLastClickedEntryForShiftSelect = null;
                    }


                    const message =
                        `Selected ${selectionCount} entr${
                            selectionCount === 1 ? "y" : "ies"
                        }` +
                        (query
                            ? ` matching "${query}".`
                            : append
                            ? " (appended to existing selection)."
                            : ".");
                    return message;
                },
                deselectAllEntries: (silent = false) => {
                    if (!mainContentAreaElement) {
                        if (!silent)
                            logToConsole(
                                "Error: Main content area not found.",
                                "error"
                            );
                        return "Deselection failed: Main content area not found.";
                    }
                    let deselectionCount = 0;

                    for (const entry of mainContentAreaElement.querySelectorAll(
                        "dataset-entry[selected]"
                    )) {
                        entry.selected = false;
                        deselectionCount++;
                    }

                    globalLastClickedEntryForShiftSelect = null;

                    const message = `Deselected ${deselectionCount} entr${
                        deselectionCount === 1 ? "y" : "ies"
                    }.`;
                    return message;
                },
                getSelectedEntries: () => {
                    if (!mainContentAreaElement) return [];
                    return Array.from(
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry[selected]"
                        )
                    );
                },
                filterSelectedEntries: (query) => {
                    if (!mainContentAreaElement) {
                        return "Filter failed: Main content area not found.";
                    }
                    const trimmedQuery =
                        typeof query === "string" ? query.trim() : "";
                    if (trimmedQuery === "") {
                        return "Filter query is empty. No entries changed.";
                    }

                    const selectedEntries = Array.from(
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry[selected]"
                        )
                    );
                    if (selectedEntries.length === 0) {
                        return "No entries selected to filter.";
                    }

                    let deselectedCount = 0;

                    for (const entry of selectedEntries) {
                        const tags = entry.getNormalizedTags();
                        const shouldKeep = evaluateExpression(
                            trimmedQuery,
                            tags
                        );
                        if (!shouldKeep) {
                            entry.selected = false;
                            deselectedCount++;
                        }
                    }

                    // Update g_lastClickedEntryForShiftSelect if only one entry remains selected
                    const currentlySelected = opentaggerAPI.getSelectedEntries();
                    if (currentlySelected.length === 1) {
                         globalLastClickedEntryForShiftSelect = currentlySelected[0];
                    } else if (deselectedCount > 0 && globalLastClickedEntryForShiftSelect && !globalLastClickedEntryForShiftSelect.selected) {
                         // If the last clicked entry was deselected by the filter, clear it
                         globalLastClickedEntryForShiftSelect = null;
                    }


                    const keptCount = selectedEntries.length - deselectedCount;
                    return `Filter applied to ${
                        selectedEntries.length
                    } selected entr${
                        selectedEntries.length === 1 ? "y" : "ies"
                    }. Kept: ${keptCount}, Deselected: ${deselectedCount}. Query: "${query}"`;
                },
                addTagsToSelected: (tagsArray) => {
                    const selectedEntries = opentaggerAPI.getSelectedEntries();
                    if (selectedEntries.length === 0) {
                        return "No entries selected. No tags added.";
                    }
                    if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                        return "No tags provided to add.";
                    }

                    let totalTagsAdded = 0;
                    let entriesModified = 0;

                    for (const entry of selectedEntries) {
                        let tagsAddedToThisEntry = 0;
                        for (const tag of tagsArray) {
                            if (entry.addTag(tag)) {
                                tagsAddedToThisEntry++;
                            }
                        }
                        if (tagsAddedToThisEntry > 0) {
                            totalTagsAdded += tagsAddedToThisEntry;
                            entriesModified++;
                        }
                    }
                    return `Added ${totalTagsAdded} tag(s) across ${entriesModified} selected entr${entriesModified === 1 ? "y" : "ies"}.`;
                },
                removeTagsFromSelected: (tagsArray) => {
                    const selectedEntries = opentaggerAPI.getSelectedEntries();
                    if (selectedEntries.length === 0) {
                        return "No entries selected. No tags removed.";
                    }
                    if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                        return "No tags provided to remove.";
                    }
                    if (tagsArray.length === 1 && tagsArray[0] === "*") {
                        // support wildcard removal but only if no other tags are provided for now
                        // Note: This gets tags from the *first* selected entry, which might not be representative.
                        // A better approach for '*' would be to iterate through all selected entries and remove all tags from each.
                        // Let's implement the "remove all from selected" logic directly.
                        let totalTagsRemoved = 0;
                        let entriesModified = 0;
                         for (const entry of selectedEntries) {
                             const currentTagCount = entry.getTags().length;
                             if (currentTagCount > 0) {
                                 entry.setTags([]); // setTags will trigger updates
                                 totalTagsRemoved += currentTagCount;
                                 entriesModified++;
                             }
                         }

                        return `Removed all tags from ${entriesModified} selected entr${
                            entriesModified === 1 ? "y" : "ies"
                        }. Total tags removed: ${totalTagsRemoved}.`;
                    }

                    const tagsToRemoveLower = tagsArray.map(t => String(t).trim().toLowerCase()).filter(t => t);
                    if (tagsToRemoveLower.length === 0) {
                         return "No valid tags provided to remove after processing.";
                    }

                    let totalTagsRemoved = 0;
                    let entriesModified = 0;

                    for (const entry of selectedEntries) {
                        const currentTags = entry.getTags();
                        const initialTagCount = currentTags.length;

                        const newTags = currentTags.filter(tag =>
                            !tagsToRemoveLower.includes(tag.toLowerCase())
                        );

                        if (newTags.length < initialTagCount) {
                            entry.setTags(newTags); // setTags will trigger updates
                            totalTagsRemoved += (initialTagCount - newTags.length);
                            entriesModified++;
                        }
                    }
                    return `Removed ${totalTagsRemoved} tag(s) across ${entriesModified} selected entr${entriesModified === 1 ? "y" : "ies"}.`;
                },
                rename: ({ targetTag, replaceValue, global = false }) => {
                    if (!mainContentAreaElement) {
                        return "Rename failed: Main content area not found.";
                    }
                    if (typeof targetTag !== 'string' || targetTag.trim() === '') {
                        return "Rename failed: targetTag must be a non-empty string.";
                    }
                     if (typeof replaceValue !== 'string' || replaceValue.trim() === '') {
                        return "Rename failed: replaceValue must be a non-empty string.";
                    }

                    const targetTagLower = targetTag.trim().toLowerCase();
                    const replaceValueTrimmed = replaceValue.trim();
                    const replaceValueLower = replaceValueTrimmed.toLowerCase();

                    let totalEntriesModified = 0;
                    let totalGroupsModified = 0;
                    let totalTagOccurrencesRenamed = 0;

                    // Process Dataset Entries
                    const entriesToProcess = global
                        ? Array.from(mainContentAreaElement.querySelectorAll("dataset-entry"))
                        : opentaggerAPI.getSelectedEntries();

                    for (const entry of entriesToProcess) {
                        const currentTags = entry.getTags();
                        let entryModified = false;
                        const newTags = [];
                        const newTagsLower = new Set();

                        for (const tag of currentTags) {
                            const tagLower = tag.toLowerCase();
                            if (tagLower === targetTagLower) {
                                // Replace the target tag
                                if (!newTagsLower.has(replaceValueLower)) {
                                     newTags.push(replaceValueTrimmed);
                                     newTagsLower.add(replaceValueLower);
                                     totalTagOccurrencesRenamed++;
                                     entryModified = true;
                                } else {
                                     // If replaceValue is already present, just drop the targetTag
                                     totalTagOccurrencesRenamed++; // Still count as an occurrence replaced/removed
                                     entryModified = true;
                                }
                            } else {
                                // Keep other tags, avoiding duplicates if replaceValue matches an existing tag
                                if (!newTagsLower.has(tagLower)) {
                                    newTags.push(tag);
                                    newTagsLower.add(tagLower);
                                }
                            }
                        }

                        if (entryModified) {
                            entry.setTags(newTags); // setTags handles internal updates and events
                            totalEntriesModified++;
                        }
                    }

                    // Process Tag Groups if global is true
                    if (global) {
                        const groups = document.querySelectorAll("#tag-group-list tag-group");
                        for (const group of groups) {
                            const list = group.querySelector("tag-list");
                            if (!list) continue;

                            const currentTags = list.getTags();
                            let groupModified = false;
                            const newTags = [];
                            const newTagsLower = new Set();

                             for (const tag of currentTags) {
                                const tagLower = tag.toLowerCase();
                                if (tagLower === targetTagLower) {
                                    // Replace the target tag
                                    if (!newTagsLower.has(replaceValueLower)) {
                                         newTags.push(replaceValueTrimmed);
                                         newTagsLower.add(replaceValueLower);
                                         totalTagOccurrencesRenamed++; // Count occurrences in groups too
                                         groupModified = true;
                                    } else {
                                         // If replaceValue is already present, just drop the targetTag
                                         totalTagOccurrencesRenamed++; // Still count as an occurrence replaced/removed
                                         groupModified = true;
                                    }
                                } else {
                                    // Keep other tags, avoiding duplicates
                                    if (!newTagsLower.has(tagLower)) {
                                        newTags.push(tag);
                                        newTagsLower.add(tagLower);
                                    }
                                }
                            }

                            if (groupModified) {
                                list.setTagsFromArray(newTags); // Use setTagsFromArray to update the list UI
                                totalGroupsModified++;
                            }
                        }
                    }


                    const scope = global ? "all entries and groups" : `${entriesToProcess.length} selected entr${entriesToProcess.length === 1 ? "y" : "ies"}`;
                    let message = `Renamed "${targetTag}" to "${replaceValue}".`;
                    if (totalEntriesModified > 0) {
                        message += ` Modified ${totalEntriesModified} entr${totalEntriesModified === 1 ? "y" : "ies"}.`;
                    }
                    if (global && totalGroupsModified > 0) {
                         message += ` Modified ${totalGroupsModified} group${totalGroupsModified === 1 ? "" : "s"}.`;
                    }
                    message += ` Total tag occurrences renamed: ${totalTagOccurrencesRenamed}.`;

                    if (totalEntriesModified === 0 && totalGroupsModified === 0) {
                         message = `No occurrences of "${targetTag}" found to rename in ${scope}.`;
                    }

                    return message;
                },
                 count: (tagsArray) => {
                     if (!mainContentAreaElement) {
                         return "Count failed: Main content area not found.";
                     }
                     if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                         return "Count failed: No tags provided to count.";
                     }

                     const requiredTagsLower = tagsArray.map(t => String(t).trim().toLowerCase()).filter(t => t);
                     if (requiredTagsLower.length === 0) {
                         return "Count failed: No valid tags provided after processing.";
                     }

                     const visibleEntries = Array.from(mainContentAreaElement.querySelectorAll('dataset-entry:not([style*="display: none"])'));

                     let matchCount = 0;

                     for (const entry of visibleEntries) {
                         const entryTagsLower = entry.getNormalizedTags();
                         const allRequiredTagsPresent = requiredTagsLower.every(requiredTag =>
                             entryTagsLower.includes(requiredTag)
                         );

                         if (allRequiredTagsPresent) {
                             matchCount++;
                         }
                     }

                     const tagListString = tagsArray.join(", ");
                     return `Found ${matchCount} visible entr${matchCount === 1 ? "y" : "ies"} containing all tags: "${tagListString}".`;
                },
                help: () => {
                    const apiHelp = `Available opentaggerAPI functions (callable directly in JS console):\n${Object.keys(
                        opentaggerAPI
                    )
                        .map(
                            (k) =>
                                `  ${k}${parseFunctionSignature(
                                    opentaggerAPI[k]
                                )}`
                        )
                        .join("\n")}`;
                    const cmdHelp = `\nAvailable slash commands:\n${Object.keys(
                        slashCommands
                    )
                        .map((k) => {
                            const commandObject = slashCommands[k];
                            let displaySignature = "";
                            if (
                                commandObject &&
                                commandObject.signature !== undefined
                            ) {
                                displaySignature = ` ${commandObject.signature}`;
                            } else {
                                let funcToParseForSig = commandObject.func;
                                if (
                                    commandObject.apiRef &&
                                    typeof opentaggerAPI[
                                        commandObject.apiRef
                                    ] === "function"
                                ) {
                                    funcToParseForSig =
                                        opentaggerAPI[commandObject.apiRef];
                                }
                                const parsedSig =
                                    parseFunctionSignature(funcToParseForSig);
                                if (parsedSig && parsedSig !== "()") {
                                    const paramsString = parsedSig
                                        .slice(1, -1)
                                        .trim();
                                    if (paramsString === "") {
                                        displaySignature = "";
                                    } else {
                                        const paramsList = [];
                                        let currentParam = "";
                                        let p_openBrackets = 0;
                                        let p_openParens = 0;
                                        for (
                                            let i = 0;
                                            i < paramsString.length;
                                            i++
                                        ) {
                                            const char = paramsString[i];
                                            currentParam += char;
                                            if (char === "{")
                                                p_openBrackets++;
                                            else if (char === "}")
                                                p_openBrackets--;
                                            else if (char === "(")
                                                p_openParens++;
                                            else if (char === ")")
                                                p_openParens--;
                                            else if (
                                                char === "," &&
                                                p_openBrackets === 0 &&
                                                p_openParens === 0
                                            ) {
                                                paramsList.push(
                                                    currentParam
                                                        .slice(0, -1)
                                                        .trim()
                                                );
                                                currentParam = "";
                                            }
                                        }
                                        if (currentParam.trim()) {
                                            paramsList.push(
                                                currentParam.trim()
                                            );
                                        }
                                        const transformedParams = paramsList
                                            .map((p_str) => {
                                                let p = p_str.trim();
                                                if (p.startsWith("...")) {
                                                    return `[${p}]`;
                                                } else if (p.includes("=")) {
                                                    const name = p
                                                        .split("=")[0]
                                                        .trim();
                                                    return `[${name}]`;
                                                } else if (p) {
                                                    return `<${p}>`;
                                                }
                                                return "";
                                            })
                                            .filter((p) => p)
                                            .join(" ");
                                        displaySignature = transformedParams
                                            ? ` ${transformedParams}`
                                            : "";
                                    }
                                } else {
                                    displaySignature = "";
                                }
                            }
                            return `  /${k}${
                                displaySignature.trim()
                                    ? `${displaySignature}`
                                    : ""
                            }`;
                        })
                        .join(
                            "\n"
                        )}\n\nQuery Syntax: Supports tags (e.g. cat), "quoted phrases", AND (&&), OR (||), NOT (!), and parentheses (). Example: face && (smile || !sad)\nType JavaScript code directly to execute it (e.g., 1+1, or search('tag')). Press Enter.`;
                    const helpText = `${apiHelp}\n${cmdHelp}`;
                    logToConsole(helpText, "info", true);
                    return "Help displayed in console.";
                },
                clear: () => {
                    if (consoleOutputElement)
                        consoleOutputElement.innerHTML = "";
                    return "Console cleared.";
                },
            };


            function customCodeMirrorHints(editor, options) {
                const cursor = editor.getCursor();
                const line = editor.getLine(cursor.line);
                const token = editor.getTokenAt(cursor);

                if (line.trim().startsWith("/") && cursor.ch > 0) {
                    let currentSlashCommandPart = "";
                    const textBeforeCursor = line.substring(0, cursor.ch);
                    const match = /^\/([^\s]*)/.exec(textBeforeCursor);

                    if (match && cursor.ch <= 1 + match[1].length) {
                        currentSlashCommandPart = match[1];

                        const suggestions = Object.keys(slashCommands)
                            .filter((cmd) =>
                                cmd.startsWith(currentSlashCommandPart)
                            )
                            .map((cmd) => {
                                const commandObject = slashCommands[cmd];
                                let displaySignature = "";

                                if (
                                    commandObject &&
                                    commandObject.signature !== undefined
                                ) {
                                    displaySignature =
                                        commandObject.signature.trim()
                                            ? ` ${commandObject.signature.trim()}`
                                            : "";
                                } else {
                                    let funcToParseForSig = commandObject.func;
                                    if (
                                        commandObject.apiRef &&
                                        typeof opentaggerAPI[
                                            commandObject.apiRef
                                        ] === "function"
                                    ) {
                                        funcToParseForSig =
                                            opentaggerAPI[commandObject.apiRef];
                                    }
                                    const parsedSig =
                                        parseFunctionSignature(
                                            funcToParseForSig
                                        );
                                    if (parsedSig && parsedSig !== "()") {
                                        const paramsString = parsedSig
                                            .slice(1, -1)
                                            .trim();
                                        if (paramsString === "") {
                                            displaySignature = "";
                                        } else {
                                            const paramsList = [];
                                            let currentParam = "";
                                            let p_openBrackets = 0;
                                            let p_openParens = 0;
                                            for (
                                                let i = 0;
                                                i < paramsString.length;
                                                i++
                                            ) {
                                                const char = paramsString[i];
                                                currentParam += char;
                                                if (char === "{")
                                                    p_openBrackets++;
                                                else if (char === "}")
                                                    p_openBrackets--;
                                                else if (char === "(")
                                                    p_openParens++;
                                                else if (char === ")")
                                                    p_openParens--;
                                                else if (
                                                    char === "," &&
                                                    p_openBrackets === 0 &&
                                                    p_openParens === 0
                                                ) {
                                                    paramsList.push(
                                                        currentParam
                                                            .slice(0, -1)
                                                            .trim()
                                                    );
                                                    currentParam = "";
                                                }
                                            }
                                            if (currentParam.trim()) {
                                                paramsList.push(
                                                    currentParam.trim()
                                                );
                                            }
                                            const transformedParams = paramsList
                                                .map((p_str) => {
                                                    let p = p_str.trim();
                                                    if (p.startsWith("...")) {
                                                        return `[${p}]`;
                                                    } else if (
                                                        p.includes("=")
                                                    ) {
                                                        const name = p
                                                            .split("=")[0]
                                                            .trim();
                                                        return `[${name}]`;
                                                    } else if (p) {
                                                        return `<${p}>`;
                                                    }
                                                    return "";
                                                })
                                                .filter((p) => p)
                                                .join(" ");
                                            displaySignature = transformedParams
                                                ? ` ${transformedParams}`
                                                : "";
                                        }
                                    } else {
                                        displaySignature = "";
                                    }
                                }
                                return {
                                    text: "/" + cmd + " ",
                                    displayText: `/${cmd}${displaySignature}`,
                                    render: function (element, self, data) {
                                        const cmdNameEl =
                                            document.createElement("span");
                                        cmdNameEl.textContent = "/" + cmd;
                                        cmdNameEl.style.fontWeight = "bold";
                                        element.appendChild(cmdNameEl);
                                        if (displaySignature.trim()) {
                                            const sigEl =
                                                document.createElement("span");
                                            sigEl.textContent =
                                                displaySignature;
                                            sigEl.style.color = "#777";
                                            sigEl.style.marginLeft = "5px";
                                            element.appendChild(sigEl);
                                        }
                                    },
                                    className: "CodeMirror-hint-slash-command",
                                };
                            });
                        if (suggestions.length > 0) {
                            return {
                                list: suggestions,
                                from: CodeMirror.Pos(
                                    cursor.line,
                                    textBeforeCursor.lastIndexOf("/")
                                ),
                                to: CodeMirror.Pos(cursor.line, cursor.ch),
                            };
                        }
                    }
                }

                const jsGlobals = {};

                for (const key of Object.keys(opentaggerAPI)) {
                    if (typeof opentaggerAPI[key] === "function") {
                        jsGlobals[key] = opentaggerAPI[key];
                    }
                }
                const commonBrowserGlobals = [
                    "document",
                    "window",
                    "console",
                    "Math",
                    "JSON",
                    "localStorage",
                    "sessionStorage",
                    "navigator",
                    "location",
                    "alert",
                    "prompt",
                    "confirm",
                    "setTimeout",
                    "clearTimeout",
                    "setInterval",
                    "clearInterval",
                    "fetch",
                    "Promise",
                    "URL",
                    "Image",
                    "File",
                    "Blob",
                    "FileReader",
                    "FormData",
                    "Date",
                ];

                for (const g of commonBrowserGlobals) {
                    if (typeof window[g] !== "undefined") {
                        jsGlobals[g] = window[g];
                    }
                }
                const currentWord = token.string.trim().toLowerCase();
                const topLevelSuggestions = [];
                if (!token.string.includes(".")) {
                    for (const key of Object.keys(jsGlobals)) {
                        if (key.toLowerCase().startsWith(currentWord)) {
                            const val = jsGlobals[key];
                            let displayText = key;
                            let signature = "";
                            if (typeof val === "function") {
                                signature = parseFunctionSignature(val);
                                displayText = `${key}${signature}`;
                            }
                            topLevelSuggestions.push({
                                text: key,
                                displayText: displayText,
                                render: function (element, self, data) {
                                    const nameEl =
                                        document.createElement("span");
                                    nameEl.textContent = key;
                                    nameEl.style.fontWeight = "bold";
                                    element.appendChild(nameEl);
                                    if (signature) {
                                        const sigEl =
                                            document.createElement("span");
                                        sigEl.textContent = signature;
                                        sigEl.style.color = "#555";
                                        sigEl.style.marginLeft = "6px";
                                        element.appendChild(sigEl);
                                    }
                                },
                            });
                        }
                    }
                }
                const cmJsHintOptions = { ...options, globalVars: jsGlobals };
                let cmJsHintResult = CodeMirror.hint.javascript(
                    editor,
                    cmJsHintOptions
                );
                if (cmJsHintResult && cmJsHintResult.list.length > 0) {
                    const combinedList = [...topLevelSuggestions];
                    const topLevelTexts = new Set(
                        topLevelSuggestions.map((s) => s.text)
                    );

                    for (const cmHint of cmJsHintResult.list) {
                        const hintText =
                            typeof cmHint === "string" ? cmHint : cmHint.text;
                        if (!topLevelTexts.has(hintText)) {
                            if (typeof cmHint === "string") {
                                combinedList.push({
                                    text: cmHint,
                                    displayText: cmHint,
                                });
                            } else {
                                combinedList.push(cmHint);
                            }
                        }
                    }
                    cmJsHintResult.list = combinedList;
                    if (token.string.length > 0 && token.start < cursor.ch) {
                        cmJsHintResult.from = CodeMirror.Pos(
                            cursor.line,
                            token.start
                        );
                        cmJsHintResult.to = CodeMirror.Pos(
                            cursor.line,
                            token.end
                        );
                    }
                    return cmJsHintResult;
                } else if (topLevelSuggestions.length > 0) {
                    return {
                        list: topLevelSuggestions,
                        from: CodeMirror.Pos(cursor.line, token.start),
                        to: CodeMirror.Pos(cursor.line, token.end),
                    };
                }
                return cmJsHintResult;
            }

                        const slashCommands = {
                search: {
                    func: (args) => {
                        if (args.length < 2) return "Usage: /search <query>";
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.search(query);
                    },
                    signature: "<query terms...>",
                    apiRef: "search",
                },
                select: {
                    func: (args) => {
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.selectEntries(query, false);
                    },
                    signature: "[query terms... (empty for all visible)]",
                    apiRef: "selectEntries",
                },
                selectappend: {
                    func: (args) => {
                        const query = args.slice(1).join(" ");
                        if (!query)
                            return "Usage: /selectappend <query terms...>";
                        return opentaggerAPI.selectEntries(query, true);
                    },
                    signature: "<query terms...>",
                    apiRef: "selectEntries",
                },
                filter: {
                    func: (args) => {
                        if (args.length < 2)
                            return "Usage: /filter <query terms...>";
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.filterSelectedEntries(query);
                    },
                    signature: "<query terms...>",
                    apiRef: "filterSelectedEntries",
                },
                deselectall: {
                    func: (args) => {
                        return opentaggerAPI.deselectAllEntries();
                    },
                    signature: "",
                    apiRef: "deselectAllEntries",
                },
                add: {
                    func: (args) => {
                        if (args.length < 2) return "Usage: /add <tag1>, [tag2], ...";
                        const rawTagsString = args.slice(1).join(" ");
                        const tagsArray = parseRawTagInput(rawTagsString);
                        if (tagsArray.length === 0) return "No valid tags provided.";
                        return opentaggerAPI.addTagsToSelected(tagsArray);
                    },
                    signature: "<tag1>, [tag2 with spaces], ...",
                    apiRef: "addTagsToSelected",
                },
                remove: {
                    func: (args) => {
                         if (args.length < 2) return "Usage: /remove <tag1>, [tag2], ...";
                        const rawTagsString = args.slice(1).join(" ");
                        const tagsArray = parseRawTagInput(rawTagsString);
                        if (tagsArray.length === 0) return "No valid tags provided.";
                        return opentaggerAPI.removeTagsFromSelected(tagsArray);
                    },
                    signature: "<tag1>, [tag2 with spaces], ...",
                    apiRef: "removeTagsFromSelected",
                },
                rename: {
                    func: (args) => {
                        let global = false;
                        const positionalArgs = [];
                        for(const arg of args.slice(1)) { // Skip command name
                            if (arg.toLowerCase() === '--global=true') {
                                global = true;
                            } else {
                                positionalArgs.push(arg);
                            }
                        }

                        if (positionalArgs.length < 2) {
                            return "Usage: /rename <targetTag> <replaceValue> [--global=true]";
                        }

                        const targetTag = positionalArgs[0];
                        const replaceValue = positionalArgs[1];

                        return opentaggerAPI.rename({ targetTag, replaceValue, global });
                    },
                    signature: "<targetTag> <replaceValue> [--global=true]",
                    apiRef: "rename", // Used for hints, actual call is in func
                },
                 count: {
                     func: (args) => {
                         if (args.length < 2) return "Usage: /count <tag1>, [tag2], ...";
                         const rawTagsString = args.slice(1).join(" ");
                         const tagsArray = parseRawTagInput(rawTagsString);
                         if (tagsArray.length === 0) return "No valid tags provided.";
                         return opentaggerAPI.count(tagsArray);
                     },
                     signature: "<tag1>, [tag2 with spaces], ...",
                     apiRef: "count", // Used for hints, actual call is in func
                 },
                clear: {
                    func: (args) => {
                        return opentaggerAPI.clear();
                    },
                    signature: "",
                    apiRef: "clear",
                },
                help: {
                    func: (args) => {
                        return opentaggerAPI.help();
                    },
                    signature: "",
                    apiRef: "help",
                },
            };


            function getTagText(element) {
                const span = element.querySelector("span[contenteditable]");
                return span
                    ? span.textContent.trim()
                    : element.textContent.trim();
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function parseFunctionSignature(func) {
                if (typeof func !== "function") {
                    return "";
                }
                const funcStr = func.toString();
                let paramsMatch = funcStr.match(
                    /^(?:async\s*)?(?:function(?:\s+\w*)?\s*\(|\((?!\))|\w+\s*=>\s*\()([^)]*)\)\s*=>|\)\s*{/
                );
                if (!paramsMatch) {
                    paramsMatch = funcStr.match(
                        /^(?:async\s*)?(?:\w+\s*=>|(\w+)\s*=>)/
                    );
                    if (paramsMatch && paramsMatch[1])
                        return `(${paramsMatch[1]})`;
                    if (funcStr.match(/^(?:async\s*)?\(\s*\)\s*=>/))
                        return "()";
                    return "";
                }
                let paramsStr = paramsMatch[1] || "";
                if (!paramsStr && funcStr.includes("() =>")) return "()";
                const params = [];
                let currentParam = "";
                let openBrackets = 0;
                let openParens = 0;
                for (let i = 0; i < paramsStr.length; i++) {
                    const char = paramsStr[i];
                    currentParam += char;
                    if (char === "{") openBrackets++;
                    else if (char === "}") openBrackets--;
                    else if (char === "(") openParens++;
                    else if (char === ")") openParens--;
                    else if (
                        char === "," &&
                        openBrackets === 0 &&
                        openParens === 0
                    ) {
                        params.push(currentParam.slice(0, -1).trim());
                        currentParam = "";
                    }
                }
                if (currentParam.trim()) {
                    params.push(currentParam.trim());
                }
                if (params.length === 0 && paramsStr.trim() !== "") {
                    params.push(paramsStr.trim());
                }
                const formattedParams = params.map((p) => {
                    let param = p.trim();
                    param = param.replace(/\/\*.*?\*\//g, "").trim();
                    if (param.includes("=")) {
                        const parts = param.split("=");
                        const name = parts[0].trim();
                        let defVal = parts.slice(1).join("=").trim();
                        if (defVal.startsWith("{") && defVal.endsWith("}"))
                            defVal = "{...}";
                        else if (defVal.startsWith("[") && defVal.endsWith("]"))
                            defVal = "[...]";
                        else if (defVal.length > 15) defVal = "...";
                        return `${name} = ${defVal}`;
                    }
                    return param;
                });

                return `(${formattedParams.join(", ")})`;
            }

            function sanitizeFilename(name) {
                if (!name || typeof name !== "string") return "untitled_image";
                const baseName = name.includes(".")
                    ? name.substring(0, name.lastIndexOf("."))
                    : name;
                const extension = name.includes(".")
                    ? name.substring(name.lastIndexOf("."))
                    : "";
                const sanitizedBase = baseName.replace(/[^a-zA-Z0-9_.-]/g, "_");
                const finalBase = sanitizedBase || "image";
                return finalBase + extension;
            }

            function getTagColor(tagText) {
                let hash = 0;
                for (let i = 0; i < tagText.length; i++) {
                    hash = tagText.charCodeAt(i) + ((hash << 5) - hash);
                    hash = hash & hash;
                }
                const hue = Math.abs(hash % 360);
                return `hsl(${hue}, 70%, 45%)`;
            }

            function createTimerLabelElement() {
                const label = document.createElement("span");
                label.className = "autotag-timer-label";
                label.textContent = "0.0s";
                return label;
            }

            function startTimer(updateCallback, intervalMs = 100) {
                const startTime = performance.now();
                const intervalId = setInterval(() => {
                    const elapsedMs = performance.now() - startTime;
                    updateCallback((elapsedMs / 1000).toFixed(1) + "s");
                }, intervalMs);
                return {
                    stop: () => {
                        clearInterval(intervalId);
                        const elapsedMs = performance.now() - startTime;
                        return elapsedMs / 1000;
                    },
                    getElapsedTime: () => {
                        const elapsedMs = performance.now() - startTime;
                        return (elapsedMs / 1000).toFixed(1) + "s";
                    },
                };
            }

            function evaluateExpression(expression, tags) {
                expression = expression.trim();
                if (expression === "") {
                    return false;
                }
                if (expression.toLowerCase() === "true") return true;
                if (expression.toLowerCase() === "false") return false;
                if (expression.startsWith("(") && expression.endsWith(")")) {
                    let balance = 0;
                    let fullyEnclosed = true;
                    for (let i = 0; i < expression.length - 1; i++) {
                        if (expression[i] === "(") balance++;
                        else if (expression[i] === ")") balance--;
                        if (balance === 0) {
                            fullyEnclosed = false;
                            break;
                        }
                    }
                    if (expression[expression.length - 1] === ")") balance--;
                    if (fullyEnclosed && balance === 0) {
                        const innerExpression = expression
                            .substring(1, expression.length - 1)
                            .trim();
                        if (innerExpression === "") return false;
                        return evaluateExpression(innerExpression, tags);
                    }
                }
                if (expression.startsWith("!")) {
                    const subExpression = expression.substring(1).trim();
                    return !evaluateExpression(subExpression, tags);
                }
                let balance = 0;
                for (let i = expression.length - 1; i >= 1; i--) {
                    if (expression[i] === ")") balance++;
                    else if (expression[i] === "(") balance--;
                    else if (
                        expression[i - 1] === "|" &&
                        expression[i] === "|" &&
                        balance === 0
                    ) {
                        const left = expression.substring(0, i - 1).trim();
                        const right = expression.substring(i + 1).trim();
                        return (
                            evaluateExpression(left || "false", tags) ||
                            evaluateExpression(right || "false", tags)
                        );
                    }
                }
                balance = 0;
                for (let i = expression.length - 1; i >= 1; i--) {
                    if (expression[i] === ")") balance++;
                    else if (expression[i] === "(") balance--;
                    else if (
                        expression[i - 1] === "&" &&
                        expression[i] === "&" &&
                        balance === 0
                    ) {
                        const left = expression.substring(0, i - 1).trim();
                        const right = expression.substring(i + 1).trim();
                        return (
                            evaluateExpression(left || "true", tags) &&
                            evaluateExpression(right || "true", tags)
                        );
                    }
                }
                const term = expression.toLowerCase();
                return tags.some((tag) => tag.toLowerCase().includes(term));
            }

            function getQueryLeafTerms(expression) {
                const terms = new Set();
                const termExtractionRegex = /(?:[^\s()&|!]+|"[^"]*")+/g;
                let match;
                while (
                    (match = termExtractionRegex.exec(expression)) !== null
                ) {
                    const term = match[0].replace(/^"|"$/g, "").toLowerCase();
                    if (term && term !== "true" && term !== "false") {
                        if (!/^[&|!]+$/.test(term) && term.length > 0) {
                            terms.add(term);
                        }
                    } else if (
                        (term === "true" || term === "false") &&
                        match[0].startsWith('"')
                    ) {
                        terms.add(term);
                    }
                }
                return Array.from(terms).sort();
            }

            function parseRawTagInput(rawText) {
                if (typeof rawText !== "string") return [];
                const segments = rawText.split(/(?<!\\),/g);
                return segments
                    .map((segment) => {
                        const tempPlaceholder = "##TEMP_BACKSLASH##";
                        return segment
                            .replace(/\\\\/g, tempPlaceholder)
                            .replace(/\\,/g, ",")
                            .replace(
                                new RegExp(
                                    tempPlaceholder.replace(
                                        /[.*+?^${}()|[\]\\]/g,
                                        "\\$&"
                                    ),
                                    "g"
                                ),
                                "\\"
                            )
                            .trim();
                    })
                    .filter((tagText) => tagText.length > 0);
            }

             /**
             * Generates submenu items for adding group tags to selected entries.
             * @param {Array<DatasetEntry>} targetEntries - The array of entries the action will apply to.
             * @returns {Array<Object>} Menu item definitions.
             */
            function getGroupSubmenuItems(targetEntries) {
                const cats = document.querySelectorAll(
                    "#tag-group-list tag-group"
                );
                const items = [];
                const targetCount = targetEntries.length;

                for (const cat of cats) {
                    const name = cat.getAttribute("group-name") || "...";
                    const tags = cat.getGroupTags();
                    if (tags.length > 0)
                        items.push({
                            label: `Add All from "${name}"`,
                            callback: () => {
                                for(const entry of targetEntries) {
                                    for (const tag of tags) {
                                        entry.addTag(tag);
                                    }
                                }
                            },
                        });
                }
                if (items.length === 0)
                    items.push({
                        label: "(No groups with tags)",
                        callback: null,
                        disabled: true,
                    });
                return items;
            }

            class AutocompleteDropdown extends HTMLElement {
                constructor() {
                    super();
                    this._targetElement = null;
                    this._suggestions = [];
                    this._selectedIndex = -1;
                    this._boundHandleDocumentClick = this._handleDocumentClick.bind(this);
                    this._boundHandleKeyDownPassthrough = this._handleKeyDownPassthrough.bind(this);
                }
            
                show(suggestions, targetElement) {
                    this._targetElement = targetElement;
                    this._suggestions = suggestions;
                    this._selectedIndex = -1;
                    this.innerHTML = ''; 
            
                    if (!this._targetElement || !this._suggestions || this._suggestions.length === 0) {
                        this.hide();
                        return;
                    }
            
                    this._suggestions.forEach((suggestion, index) => {
                        const item = document.createElement('div');
                        item.classList.add('suggestion-item');
                        item.dataset.index = index;
            
                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('tag-name');
                        nameSpan.textContent = suggestion.name;
                        item.appendChild(nameSpan);
            
                        const countSpan = document.createElement('span');
                        countSpan.classList.add('tag-count');
                        countSpan.textContent = `(${suggestion.count.toLocaleString()})`;
                        item.appendChild(countSpan);
            
                        item.addEventListener('mousedown', (e) => {
                            e.preventDefault(); 
                            this._selectItem(index);
                        });
                        this.appendChild(item);
                    });
            
                    // --- Positioning Logic ---
                    const currentTargetRect = this._targetElement.getBoundingClientRect();
                    const dropdown = this;
            
                    // Set minWidth based on target before measuring dropdown.
                    // The dropdown has `box-sizing: border-box` due to global `*` rule.
                    dropdown.style.minWidth = `${currentTargetRect.width}px`;
            
                    // Temporarily make it visible for measurement, but out of sight.
                    dropdown.style.visibility = 'hidden';
                    dropdown.style.position = 'absolute'; // Ensure it's absolute for correct measurement context
                    dropdown.style.display = 'flex';     // Apply styles that affect size (from .visible class)
                    dropdown.style.left = '-9999px';     // Move off-screen
                    dropdown.style.top = '-9999px';
            
                    // Get actual dimensions of the dropdown
                    const dropdownMeasuredRect = dropdown.getBoundingClientRect();
                    const dropdownWidth = dropdownMeasuredRect.width;
                    const dropdownHeight = dropdownMeasuredRect.height;
            
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const margin = 5; // Small margin from viewport edges
                    const verticalOffset = 2; // Small offset from the target element
            
                    let finalTopViewportRelative, finalLeftViewportRelative;
            
                    // Determine vertical position
                    // Candidate 1: Below target (preferred)
                    let topIfBelow = currentTargetRect.bottom + verticalOffset;
                    let fitsBelow = (topIfBelow + dropdownHeight + margin <= viewportHeight);
            
                    // Candidate 2: Above target
                    let topIfAbove = currentTargetRect.top - dropdownHeight - verticalOffset;
                    let fitsAbove = (topIfAbove >= margin); // Check against top margin
            
                    if (fitsBelow) {
                        finalTopViewportRelative = topIfBelow;
                    } else if (fitsAbove) {
                        finalTopViewportRelative = topIfAbove;
                    } else {
                        // Neither fits perfectly. Choose based on which has more space or is less clipped.
                        // If target is more in top half of screen, prefer showing below (even if clamped).
                        // If target is more in bottom half, prefer showing above (even if clamped).
                        if (currentTargetRect.top < (viewportHeight / 2)) {
                            finalTopViewportRelative = topIfBelow;
                        } else {
                            finalTopViewportRelative = topIfAbove;
                        }
                        // Alternative for when neither fits: check which would be less clipped.
                        // const overflowBelowAmount = Math.max(0, (topIfBelow + dropdownHeight + margin) - viewportHeight);
                        // const overflowAboveAmount = Math.max(0, margin - topIfAbove);
                        // if (overflowBelowAmount <= overflowAboveAmount) {
                        //    finalTopViewportRelative = topIfBelow;
                        // } else {
                        //    finalTopViewportRelative = topIfAbove;
                        // }
                    }
            
                    // Determine horizontal position
                    finalLeftViewportRelative = currentTargetRect.left; // Default: align left edges
                    if (finalLeftViewportRelative + dropdownWidth + margin > viewportWidth) {
                        // Overflowing right, try aligning to target's right edge
                        finalLeftViewportRelative = currentTargetRect.right - dropdownWidth;
                        // If aligning to target's right still makes it overflow left (e.g. target wider than dropdown and near left edge)
                        // or if dropdown is wider than target and aligning target's right pushes it left:
                        if (finalLeftViewportRelative < margin) { 
                           finalLeftViewportRelative = viewportWidth - dropdownWidth - margin; // Align to viewport's right edge
                        }
                    }
                    // Ensure it doesn't overflow left edge of viewport
                    if (finalLeftViewportRelative < margin) {
                        finalLeftViewportRelative = margin;
                    }
            
                    // Final clamping to ensure it's strictly within viewport boundaries (accounts for extreme cases)
                    finalTopViewportRelative = Math.max(margin, Math.min(finalTopViewportRelative, viewportHeight - dropdownHeight - margin));
                    finalLeftViewportRelative = Math.max(margin, Math.min(finalLeftViewportRelative, viewportWidth - dropdownWidth - margin));
            
                    // Convert viewport-relative coordinates to document-relative for absolute positioning
                    // (since the dropdown is a child of body or similarly high-level container)
                    dropdown.style.top = `${finalTopViewportRelative + window.scrollY}px`;
                    dropdown.style.left = `${finalLeftViewportRelative + window.scrollX}px`;
                    
                    // minWidth was already set for measurement. If CSS has a stronger min-width (e.g., 150px),
                    // dropdownWidth would have reflected that.
                    // If you want to ensure it's NOT NARROWER than the target, the previous style.minWidth handles it.
                    // If you want it not wider than target (unless content dictates), that's harder.
                    // Current logic: it's at least target.width, or its own content width, or css min-width, whichever is largest.

                    // Make it truly visible at the calculated position
                    dropdown.style.visibility = 'visible';
                    dropdown.classList.add('visible'); // This also ensures display:flex
            
                    // --- End Positioning Logic ---
            
                    setTimeout(() => {
                        document.addEventListener('click', this._boundHandleDocumentClick, true);
                    }, 0);
            
                    if (this._targetElement && typeof this._targetElement.addEventListener === 'function') {
                        this._targetElement.addEventListener('keydown', this._boundHandleKeyDownPassthrough, true);
                    }
            
                    if (this._suggestions.length > 0 && this._selectedIndex === -1) { // Select first item if none selected
                        this._selectedIndex = 0;
                        this._updateSelectionVisuals();
                    }
                }
            
                hide() {
                    if (!this.classList.contains('visible')) return;
            
                    this.classList.remove('visible');
                    this.style.visibility = 'hidden'; // Ensure it's hidden
                    this.style.display = 'none'; // And not taking up space

                    document.removeEventListener('click', this._boundHandleDocumentClick, true);
            
                    if (this._targetElement && typeof this._targetElement.removeEventListener === 'function') {
                        this._targetElement.removeEventListener('keydown', this._boundHandleKeyDownPassthrough, true);
                    }
                    // Don't nullify _targetElement here if hide can be called temporarily during complex interactions.
                    // However, for a typical hide, it's fine. If a new `show` call happens, _targetElement gets reset.
                    // this._targetElement = null; 
                    this.dispatchEvent(new CustomEvent('dropdown-hidden'));
                }
            
                _handleDocumentClick(event) {
                    if (!this.contains(event.target) && event.target !== this._targetElement) {
                        this.hide();
                    }
                }
            
                _handleKeyDownPassthrough(event) {
                    if (!this.classList.contains('visible')) return;
            
                    switch (event.key) {
                        case 'ArrowUp':
                            event.preventDefault();
                            event.stopPropagation();
                            this._navigate(-1);
                            break;
                        case 'ArrowDown':
                            event.preventDefault();
                            event.stopPropagation();
                            this._navigate(1);
                            break;
                        case 'Enter':
                        case 'Tab': 
                            if (this._selectedIndex !== -1) {
                                event.preventDefault();
                                event.stopPropagation();
                                this._selectItem(this._selectedIndex);
                            } else {
                                // If no item is selected but dropdown is open, Enter/Tab might mean "accept current input text"
                                // This is handled by the input's blur/keydown. Here, just hide.
                                this.hide();
                            }
                            break;
                        case 'Escape':
                            event.preventDefault();
                            event.stopPropagation();
                            this.hide();
                            // Dispatch an event so the DatasetTag can know Escape was pressed while dropdown was open
                            this.dispatchEvent(new CustomEvent('dropdown-escaped', {bubbles: true, composed: true}));
                            break;
                    }
                }
            
                _navigate(direction) {
                    if (this._suggestions.length === 0) return;
                    const newIndex = this._selectedIndex + direction;
                    if (newIndex >= 0 && newIndex < this._suggestions.length) {
                        this._selectedIndex = newIndex;
                    } else if (newIndex < 0) { // Wrap around to last item or stay at first
                        this._selectedIndex = this._suggestions.length -1; // Or 0 to not wrap
                    } else if (newIndex >= this._suggestions.length) { // Wrap around to first item or stay at last
                         this._selectedIndex = 0; // Or this._suggestions.length - 1 to not wrap
                    }
                    this._updateSelectionVisuals();
                }
            
                _updateSelectionVisuals() {
                    this.querySelectorAll('.suggestion-item').forEach((item, idx) => {
                        if (idx === this._selectedIndex) {
                            item.classList.add('selected');
                            // Ensure the selected item is visible within the scrollable dropdown
                            item.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                        } else {
                            item.classList.remove('selected');
                        }
                    });
                }
            
                _selectItem(index) {
                    if (index >= 0 && index < this._suggestions.length) {
                        const selectedSuggestion = this._suggestions[index];
                        // Let the DatasetTag (or other listener) handle the selected suggestion
                        this.dispatchEvent(new CustomEvent('suggestion-selected', { detail: selectedSuggestion }));
                        this.hide(); 
                    }
                }
            }
            customElements.define('autocomplete-dropdown', AutocompleteDropdown);

            class DatasetTag extends HTMLElement {
                constructor() {
                    super();
                    this._boundHandleDeleteClick =
                        this._handleDeleteClick.bind(this);
                    this._boundHandleDeleteMouseDown =
                        this._handleDeleteMouseDown.bind(this);
                    this._boundHandleSpanDblClick =
                        this._handleSpanDblClick.bind(this);
                    this._boundHandleSpanKeyDown =
                        this._handleSpanKeyDown.bind(this);
                    this._boundHandleSpanBlur = this._handleSpanBlur.bind(this);
                    this._boundHandleDragStart =
                        this._handleDragStart.bind(this);
                    this._boundHandleDragEnd = this._handleDragEnd.bind(this);
                    this._boundHandleContextMenu = this._handleContextMenu.bind(this);
                    this._originalText = "";

                    // For autocomplete
                    this._boundHandleAutocompleteSelection = this._handleAutocompleteSelection.bind(this);
                    this._boundHandleAutocompleteEscape = this._handleAutocompleteEscape.bind(this);
                    this._boundHandleSpanInput = this._handleSpanInput.bind(this);
                    this._debouncedHandleSpanInput = debounce(this._boundHandleSpanInput, 200); // Debounce input for suggestions
                }
                connectedCallback() {
                    let initialText = "";
                    const existingSpan = this.querySelector(
                        "span[contenteditable]"
                    );
                    if (existingSpan) {
                        initialText = existingSpan.textContent.trim();
                    } else {
                        initialText = this.textContent.trim();
                    }
                    this._originalText = initialText || "empty_tag";
                    this.innerHTML = "";
                    this.draggable = true;
                    const span = document.createElement("span");
                    span.setAttribute("contenteditable", "false");
                    span.setAttribute("translate", "no");
                    span.textContent = this._originalText;
                    const button = document.createElement("button");
                    button.classList.add("delete-tag", "material-icons");
                    button.speaker = "Delete Tag";
                    button.textContent = "close";

                    this.appendChild(span);
                    this.appendChild(button);
                    this.addEventListeners();
                }
                disconnectedCallback() {
                    this.removeEventListeners();
                     if (globalTagAutocompleteDropdown && globalTagAutocompleteDropdown.classList.contains('visible') && globalTagAutocompleteDropdown._targetElement === this.querySelector('span')) {
                        globalTagAutocompleteDropdown.hide();
                    }
                }
                addEventListeners() {
                    const d = this.querySelector(".delete-tag");
                    const s = this.querySelector("span[contenteditable]");
                    if (d) {
                        d.addEventListener(
                            "click",
                            this._boundHandleDeleteClick
                        );
                        d.addEventListener(
                            "mousedown",
                            this._boundHandleDeleteMouseDown
                        );
                    }
                    if (s) {
                        s.addEventListener(
                            "dblclick",
                            this._boundHandleSpanDblClick
                        );
                        s.addEventListener(
                            "keydown",
                            this._boundHandleSpanKeyDown
                        );
                        s.addEventListener("blur", this._boundHandleSpanBlur);
                        s.addEventListener('input', this._debouncedHandleSpanInput); // Use debounced handler
                    }
                    this.addEventListener(
                        "dragstart",
                        this._boundHandleDragStart
                    );
                    this.addEventListener("dragend", this._boundHandleDragEnd);
                    this.addEventListener("contextmenu", this._boundHandleContextMenu);

                    if (globalTagAutocompleteDropdown) {
                        globalTagAutocompleteDropdown.addEventListener('suggestion-selected', this._boundHandleAutocompleteSelection);
                        globalTagAutocompleteDropdown.addEventListener('dropdown-escaped', this._boundHandleAutocompleteEscape);
                    }
                }
                removeEventListeners() {
                    const d = this.querySelector(".delete-tag");
                    const s = this.querySelector("span[contenteditable]");
                    if (d) {
                        d.removeEventListener(
                            "click",
                            this._boundHandleDeleteClick
                        );
                        d.removeEventListener(
                            "mousedown",
                            this._boundHandleDeleteMouseDown
                        );
                    }
                    if (s) {
                        s.removeEventListener(
                            "dblclick",
                            this._boundHandleSpanDblClick
                        );
                        s.removeEventListener(
                            "keydown",
                            this._boundHandleSpanKeyDown
                        );
                        s.removeEventListener("blur", this._boundHandleSpanBlur);
                        s.removeEventListener('input', this._debouncedHandleSpanInput);
                    }
                    this.removeEventListener(
                        "dragstart",
                        this._boundHandleDragStart
                    );
                    this.removeEventListener(
                        "dragend",
                        this._boundHandleDragEnd
                    );
                     this.removeEventListener("contextmenu", this._boundHandleContextMenu);
                    if (globalTagAutocompleteDropdown) {
                        globalTagAutocompleteDropdown.removeEventListener('suggestion-selected', this._boundHandleAutocompleteSelection);
                        globalTagAutocompleteDropdown.removeEventListener('dropdown-escaped', this._boundHandleAutocompleteEscape);
                    }
                }

                _handleSpanDblClick(e) {
                    e.stopPropagation();
                    const span = e.target;
                    this._originalText = getTagText(this);
                    span.contentEditable = "true";
                    span.focus();
                    window.getSelection().selectAllChildren(span);
                }

                _handleSpanInput(e) { 
                    const span = e.target;
                    if (span.contentEditable !== 'true' || !globalTagAutocompleteDropdown || booruTags.length === 0) {
                        globalTagAutocompleteDropdown?.hide();
                        return;
                    }
                
                    const inputText = span.textContent.trim().toLowerCase();
                    if (inputText.length < 1) { 
                        globalTagAutocompleteDropdown.hide();
                        return;
                    }
                
                    const matchedTags = booruTags
                        .filter(tag => tag.name.toLowerCase().startsWith(inputText))
                        // .sort((a, b) => b.count - a.count) // Tags are already pre-sorted by count
                        .slice(0, MAX_SUGGESTIONS);
                
                    if (matchedTags.length > 0) {
                        // Pass the span itself as the target for positioning
                        globalTagAutocompleteDropdown.show(matchedTags, span);
                    } else {
                        globalTagAutocompleteDropdown.hide();
                    }
                }

                _handleSpanKeyDown(e) {
                    const span = e.target;
                    if (span.contentEditable === "true") {
                        if (globalTagAutocompleteDropdown && globalTagAutocompleteDropdown.classList.contains('visible') && e.defaultPrevented) {
                            // Autocomplete handled the key (Up, Down, Enter, Esc, Tab)
                            return;
                        }
                
                        // If autocomplete is NOT visible, or it is visible but didn't handle the key
                        if (e.key === "Enter") {
                            e.preventDefault();
                            globalTagAutocompleteDropdown.hide(); 
                            span.blur(); 
                        } else if (e.key === "Escape") {
                            e.preventDefault();
                            globalTagAutocompleteDropdown.hide(); 
                            span.textContent = this._originalText;
                            span.blur(); 
                        }
                    }
                }

                _handleSpanBlur(e) {
                    const span = e.target;
                    if (!this.isConnected) return;
                
                    setTimeout(() => {
                        if (span.contentEditable === 'false') {
                            // Already finalized by autocomplete selection or escape
                            return;
                        }
                
                        globalTagAutocompleteDropdown.hide(); 
                
                        span.contentEditable = "false";
                        const newRawText = span.textContent;
                
                        if (newRawText === this._originalText) {
                            span.textContent = this._originalText || "empty_tag";
                            return;
                        }
                        this._processEditedText(newRawText);
                    }, 50); 
                }
                
                _handleAutocompleteSelection(e) {
                    // Check if this event is relevant to this specific tag instance
                    const span = this.querySelector("span[contenteditable='true']");
                    if (span && globalTagAutocompleteDropdown._targetElement === span && e.target === globalTagAutocompleteDropdown) {
                        const selectedTag = e.detail;
                        span.textContent = selectedTag.name;
                
                        span.contentEditable = "false"; 
                        // globalTagAutocompleteDropdown.hide(); // Already hidden by dropdown's _selectItem

                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(span);
                        range.collapse(false);
                        sel.removeAllRanges();
                        sel.addRange(range);
                        
                        this._processEditedText(span.textContent); 
                    }
                }
                
                _handleAutocompleteEscape(e) {
                     const span = this.querySelector("span[contenteditable='true']");
                     // Check if this event is relevant to this specific tag instance
                    if (span && globalTagAutocompleteDropdown._targetElement === span && e.target === globalTagAutocompleteDropdown) {
                        span.textContent = this._originalText; 
                        span.contentEditable = "false"; 
                        // globalTagAutocompleteDropdown.hide(); // Already hidden by dropdown's Escape handler
                    }
                }

                _handleDeleteClick(e) {
                    e.stopPropagation();
                    const parentTagList = this.closest("tag-list");
                    this.remove();
                    if (parentTagList) {
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }
                _handleDeleteMouseDown(e) {
                    e.stopPropagation();
                }
                
                _processEditedText(rawText) {
                    const finalTagTexts = parseRawTagInput(rawText);
                    const parentTagList = this.closest("tag-list");
                    const span = this.querySelector("span[contenteditable]");
                    if (span) {
                        span.setAttribute("translate", "no");
                    }

                    if (!parentTagList) {
                        const span = this.querySelector(
                            "span[contenteditable]"
                        );
                        if (finalTagTexts.length === 1) {
                            const newText = finalTagTexts[0];
                            if (newText !== this._originalText) {
                                span.textContent = newText;
                                this._originalText = newText;
                                this.dispatchEvent(
                                    new CustomEvent("tag-updated", {
                                        bubbles: true,
                                        composed: true,
                                    })
                                );
                            } else {
                                span.textContent =
                                    this._originalText || "empty_tag";
                            }
                        } else if (finalTagTexts.length === 0) {
                            if (this.parentElement) this.remove();
                            else
                                span.textContent =
                                    this._originalText || "empty_tag";
                        } else { // Multiple tags entered, keep first in this tag, add others to list (if applicable)
                            const firstTagText = finalTagTexts[0];
                            let originalTextChanged = (firstTagText !== this._originalText);
                            span.textContent = firstTagText;
                            this._originalText = firstTagText;
                            if (originalTextChanged) {
                                this.dispatchEvent(
                                    new CustomEvent("tag-updated", {
                                        bubbles: true,
                                        composed: true,
                                    })
                                );
                            }
                        }
                        return;
                    }

                    let changeOccurred = false;

                    if (finalTagTexts.length === 0) {
                        this.remove();
                        changeOccurred = true;
                    } else if (finalTagTexts.length === 1) {
                        const newText = finalTagTexts[0];
                        if (newText === this._originalText) {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = this._originalText;
                            return; // No actual change
                        }

                        let isDuplicateOfSibling = false;
                        const siblings = Array.from(
                            parentTagList.querySelectorAll("dataset-tag")
                        );
                        for (const sibling of siblings) {
                            if (
                                sibling !== this &&
                                getTagText(sibling).toLowerCase() ===
                                    newText.toLowerCase()
                            ) {
                                isDuplicateOfSibling = true;
                                break;
                            }
                        }

                        if (isDuplicateOfSibling) {
                            this.remove(); // Remove this tag as it's now a duplicate
                        } else {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = newText;
                            this._originalText = newText;
                        }
                        changeOccurred = true;
                    } else { // Multiple tags entered via editing one
                        const firstTagText = finalTagTexts.shift(); // Take the first for the current tag

                        let isFirstDuplicateOfSibling = false;
                        const siblings = Array.from(
                            parentTagList.querySelectorAll("dataset-tag")
                        );
                        for (const sibling of siblings) {
                            if (
                                sibling !== this &&
                                getTagText(sibling).toLowerCase() ===
                                    firstTagText.toLowerCase()
                            ) {
                                isFirstDuplicateOfSibling = true;
                                break;
                            }
                        }

                        if (isFirstDuplicateOfSibling) {
                            this.remove(); // Current tag becomes a duplicate, remove it
                        } else {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = firstTagText;
                            this._originalText = firstTagText;
                        }

                        // Add the rest as new tags to the list
                        for (const text of finalTagTexts) {
                            parentTagList.addTag(text); // addTag handles its own duplication checks within the list
                        }
                        changeOccurred = true;
                    }

                    if (changeOccurred && parentTagList.isConnected) {
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }

                _handleDragStart(e) {
                    const s = this.querySelector("span[contenteditable]");
                    if (s && s.contentEditable === "true") {
                        e.preventDefault();
                        return;
                    }
                    if (e.target instanceof DatasetTag) {
                        const t = getTagText(this);
                        draggedElement = this;
                        e.dataTransfer.setData("text/plain", t);
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.target.classList.add("dragging");
                    } else {
                        e.preventDefault();
                    }
                }
                _handleDragEnd(e) {
                    if (
                        e.target instanceof DatasetTag &&
                        e.target.classList.contains("dragging")
                    ) {
                        e.target.classList.remove("dragging");
                    }
                    if (draggedElement === e.target) {
                        draggedElement = null;
                    }
                }

                _handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const tagText = getTagText(this);
                    const isInGroup = !!this.closest('tag-group');
                    const selectedCount = opentaggerAPI.getSelectedEntries().length;

                    const items = [
                         {
                             label: `Add "${tagText}" to Selection (${selectedCount})`,
                             callback: () => {
                                 const resultMsg = opentaggerAPI.addTagsToSelected([tagText]);
                                 logToConsole(resultMsg, 'info');
                             },
                             disabled: () => selectedCount === 0,
                         },
                         {
                             label: `Remove "${tagText}" from Selection (${selectedCount})`,
                             callback: () => {
                                 const resultMsg = opentaggerAPI.removeTagsFromSelected([tagText]);
                                 logToConsole(resultMsg, 'info');
                             },
                             disabled: () => selectedCount === 0,
                         },
                         { type: "divider" },
                         {
                             label: "Edit Tag (Double Click)",
                             callback: null, 
                             disabled: true, 
                         },
                         {
                             label: "Delete Tag",
                             callback: () => this._handleDeleteClick(e), 
                         }
                    ];

                    createContextMenu(items, e);
                }

                setHighlight(color) {
                    this.style.setProperty("--highlight-border-color", color);
                    this.classList.add("searched-highlight");
                }
                clearHighlight() {
                    this.classList.remove("searched-highlight");
                    this.style.removeProperty("--highlight-border-color");
                    this.style.order = "";
                }
            }
            customElements.define("dataset-tag", DatasetTag);

            class TagList extends HTMLElement {
                constructor() {
                    super();
                    this.addTagButtonElement = null;
                    this.addTagInputElement = null;
                    this.isEditingNewTag = false;
                    this._boundHandleAddTagButtonClick =
                        this._handleAddTagButtonClick.bind(this);
                    this._boundHandleAddTagInputKeyDown =
                        this._handleAddTagInputKeyDown.bind(this);
                    this._boundHandleAddTagInputBlur =
                        this._handleAddTagInputBlur.bind(this);
                }
                static observedAttributes = ["direction"];
                connectedCallback() {
                    this.setDirection();
                    this.addEventListeners();
                    if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }
                }
                disconnectedCallback() {
                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.removeEventListener(
                            "click",
                            this._boundHandleAddTagButtonClick
                        );
                    }
                    if (this.addTagInputElement) {
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }
                    this.isEditingNewTag = false;
                }
                attributeChangedCallback(name, oldValue, newValue) {
                    if (name === "direction") {
                        this.setDirection();
                    }
                }
                _createAddTagButton() {
                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.appendChild(this.addTagButtonElement);
                        return;
                    }
                    this.addTagButtonElement = document.createElement("button");
                    this.addTagButtonElement.className = "add-tag-button";
                    this.addTagButtonElement.type = "button";
                    this.addTagButtonElement.title = "Add a new tag";
                    const icon = document.createElement("span");
                    icon.className = "material-icons";
                    icon.textContent = "add_circle_outline";
                    this.addTagButtonElement.appendChild(icon);
                    this.addTagButtonElement.addEventListener(
                        "click",
                        this._boundHandleAddTagButtonClick
                    );
                    this.appendChild(this.addTagButtonElement);
                }
                _handleAddTagButtonClick(event) {
                    event.stopPropagation();
                    if (this.isEditingNewTag || !this.addTagButtonElement) {
                        return;
                    }
                    this.isEditingNewTag = true;
                    this.addTagButtonElement.style.display = "none";
                    this.addTagInputElement = document.createElement("span");
                    this.addTagInputElement.setAttribute(
                        "contenteditable",
                        "true"
                    );
                    this.addTagInputElement.className = "add-tag-input";
                    this.insertBefore(
                        this.addTagInputElement,
                        this.addTagButtonElement
                    );
                    this.addTagInputElement.addEventListener(
                        "keydown",
                        this._boundHandleAddTagInputKeyDown
                    );
                    this.addTagInputElement.addEventListener(
                        "blur",
                        this._boundHandleAddTagInputBlur
                    );
                    requestAnimationFrame(() => {
                        this.addTagInputElement.focus();

                        window
                            .getSelection()
                            .selectAllChildren(this.addTagInputElement);
                    });
                }
                _handleAddTagInputKeyDown(event) {
                    if (!this.isEditingNewTag || !this.addTagInputElement)
                        return;
                    if (event.key === "Enter") {
                        event.preventDefault();
                        this.addTagInputElement.blur();
                    } else if (event.key === "Escape") {
                        event.preventDefault();
                        this._revertAddTagButtonToPlaceholder(false);
                    }
                }
                _handleAddTagInputBlur() {
                    if (!this.isEditingNewTag || !this.addTagInputElement)
                        return;

                    queueMicrotask(() => {
                        if (!this.isEditingNewTag || !this.addTagInputElement)
                            return;
                        this._revertAddTagButtonToPlaceholder(true);
                    });
                }
                _revertAddTagButtonToPlaceholder(shouldProcessTags = false) {
                    if (!this.isEditingNewTag && !this.addTagInputElement) {
                        if (
                            this.addTagButtonElement &&
                            this.closest("dataset-entry")
                        ) {
                            this.addTagButtonElement.style.display = "";
                        }
                        return;
                    }

                    let rawInputText = "";
                    if (this.addTagInputElement) {
                        rawInputText = this.addTagInputElement.textContent;
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }

                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.style.display = "";

                        if (this.contains(this.addTagButtonElement)) {
                            this.appendChild(this.addTagButtonElement);
                        } else if (this.closest("dataset-entry")) {
                            this._createAddTagButton();
                        }
                    } else if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }

                    this.isEditingNewTag = false;

                    if (shouldProcessTags && rawInputText.trim()) {
                        const finalTagTexts = parseRawTagInput(rawInputText);
                        for (const tagText of finalTagTexts) {
                            this.addTag(tagText);
                        }
                    }
                }

                setDirection() {
                    const d = this.getAttribute("direction") || "row";
                    this.style.flexDirection = d;
                    this.style.alignItems =
                        d === "column" ? "flex-start" : "center";
                    this.style.flexWrap = d === "column" ? "nowrap" : "wrap";
                }
                addEventListeners() {
                    this.addEventListener("dragover", (e) => {
                        if (
                            !draggedElement ||
                            draggedElement.tagName !== "DATASET-TAG"
                        ) {
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        if (
                            draggedElement.closest("tag-list") !== this ||
                            this.contains(draggedElement)
                        ) {
                            e.dataTransfer.dropEffect =
                                this.determineDropEffect(draggedElement);
                            this.classList.add("drag-over");
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });
                    this.addEventListener("dragleave", (e) => {
                        if (
                            draggedElement &&
                            draggedElement.tagName === "DATASET-TAG"
                        ) {
                            const r = this.getBoundingClientRect();

                            if (
                                !this.contains(e.relatedTarget) ||
                                e.clientX < r.left ||
                                e.clientX >= r.right ||
                                e.clientY < r.top ||
                                e.clientY >= r.bottom
                            ) {
                                this.classList.remove("drag-over");
                            }
                        }
                    });
                    this.addEventListener("drop", (e) => {
                        if (!draggedElement || draggedElement.tagName !== "DATASET-TAG") return;
                        e.preventDefault();
                        e.stopPropagation();
                        this.classList.remove("drag-over");

                        const tagText = e.dataTransfer.getData("text/plain");
                        if (!tagText) return;

                        const amInDatasetEntry = !!this.closest("dataset-entry");
                        const selectedEntries = opentaggerAPI.getSelectedEntries();
                        const sourceList = draggedElement.closest("tag-list");
                        const isSourceGroup = !!draggedElement.closest("tag-group");

                        let eventHandledBySelection = false;

                        if (amInDatasetEntry && selectedEntries.length > 0 && (isSourceGroup || (sourceList && sourceList !== this))) {
                            let anyTagAddedToSelection = false;
                            for (const entry of selectedEntries) {
                                if (entry.addTag(tagText)) { 
                                    anyTagAddedToSelection = true;
                                }
                            }
                            eventHandledBySelection = true; 
                        }

                        if (!eventHandledBySelection || (sourceList === this)) { 
                            const effect = this.determineDropEffect(draggedElement);
                            const dropTargetUiElement = this.findDropTarget(e.clientX, e.clientY);

                            if (this.addTagButtonElement && (e.target === this.addTagButtonElement || this.addTagButtonElement.contains(e.target))) return;
                            if (this.addTagInputElement && (e.target === this.addTagInputElement || this.addTagInputElement.contains(e.target))) return;

                            let actionPerformedLocally = false;
                            if (effect === "copy") { 
                                if (this.addTag(tagText)) {
                                    const newTag = Array.from(this.querySelectorAll("dataset-tag")).find(t => getTagText(t) === tagText);
                                    if (newTag && dropTargetUiElement && (!this.addTagButtonElement || dropTargetUiElement !== this.addTagButtonElement)) {
                                        this.insertBefore(newTag, dropTargetUiElement);
                                    }
                                    actionPerformedLocally = true;
                                }
                            } else if (effect === "move") { 
                                if (draggedElement.parentElement === this && dropTargetUiElement !== draggedElement.nextElementSibling) {
                                    this.insertBefore(draggedElement, dropTargetUiElement);
                                    actionPerformedLocally = true;
                                }
                            }

                            if (actionPerformedLocally && !eventHandledBySelection) { 
                                this.dispatchEvent(new CustomEvent("tag-updated", { bubbles: true, composed: true }));
                                this.dispatchEvent(new CustomEvent("tag-list-changed-internally", { bubbles: true, composed: true }));
                            }
                            sfx.sfxPop.volume = 1.0;
                            sfx.sfxPop.play();
                        }
                    });
                }
                determineDropEffect(el) {
                    const sourceList = el.closest("tag-list");
                    const sourceGroup = el.closest("tag-group");
                    const targetEntry = this.closest("dataset-entry");

                    if (sourceGroup && targetEntry) return "copy";
                    if (sourceList === this) return "move";
                    return "copy";
                }
                findDropTarget(clientX, clientY) {
                    const children = Array.from(this.children).filter(
                        (c) =>
                            c.tagName === "DATASET-TAG" &&
                            !c.classList.contains("dragging")
                    );
                    let closest = null;
                    let minDist = Infinity;

                    for (const c of children) {
                        const b = c.getBoundingClientRect();
                        const dx = clientX - (b.left + b.width / 2);
                        const dy = clientY - (b.top + b.height / 2);
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < minDist) {
                            minDist = d;
                            closest = c;
                        }
                    }

                    if (closest) {
                        const b = closest.getBoundingClientRect();
                        const col = this.getAttribute("direction") === "column";
                        if (col)
                            return clientY < b.top + b.height / 2
                                ? closest
                                : closest.nextElementSibling;
                        else
                            return clientX < b.left + b.width / 2
                                ? closest
                                : closest.nextElementSibling;
                    }

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        return this.addTagButtonElement;
                    }
                    return null;
                }
                getTags() {
                    return Array.from(this.querySelectorAll("dataset-tag")).map(
                        (tag) => getTagText(tag)
                    );
                }
                getTagsAsString(separator = ", ") {
                    return this.getTags().join(separator);
                }
                setTagsFromArray(tagsArray) {
                    for (const tag of this.querySelectorAll("dataset-tag")) {
                        tag.remove();
                    }

                    if (this.addTagInputElement) {
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }
                    this.isEditingNewTag = false;

                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.removeEventListener(
                            "click",
                            this._boundHandleAddTagButtonClick
                        );
                        this.addTagButtonElement.remove();
                        this.addTagButtonElement = null;
                    }

                    let changed = false;
                    if (Array.isArray(tagsArray)) {
                        const uniqueTags = new Set();
                        for (const tagText of tagsArray) {
                            if (tagText && typeof tagText === "string") {
                                const trimmedTag = tagText.trim();
                                if (trimmedTag && !uniqueTags.has(trimmedTag.toLowerCase())) {
                                    const newTag =
                                        document.createElement("dataset-tag");
                                    newTag.textContent = trimmedTag;
                                    this.appendChild(newTag);
                                    uniqueTags.add(trimmedTag.toLowerCase());
                                    changed = true;
                                }
                            }
                        }
                    }
                    if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }

                    if (changed) {
                        this.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        this.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }
                addTag(tagText) {
                    tagText = tagText.trim();
                    if (!tagText) return false;

                    const currentTags = Array.from(
                        this.querySelectorAll("dataset-tag")
                    );
                    if (
                        currentTags.some(
                            (existingTag) =>
                                getTagText(existingTag).toLowerCase() ===
                                tagText.toLowerCase()
                        )
                    ) {
                        return false;
                    }

                    const newTag = document.createElement("dataset-tag");
                    newTag.textContent = tagText;

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.insertBefore(newTag, this.addTagButtonElement);
                    } else {
                        this.appendChild(newTag);
                    }

                    this.dispatchEvent(
                        new CustomEvent("tag-list-changed-internally", {
                            bubbles: true,
                            composed: true,
                        })
                    );
                    this.dispatchEvent(
                        new CustomEvent("tag-updated", {
                            bubbles: true,
                            composed: true,
                        })
                    );
                    return true;
                }
                applyHighlightingAndOrder(searchTerms, termColors) {
                    const children = Array.from(this.children);

                    for (const [
                        originalDOMIndex,
                        element,
                    ] of children.entries()) {
                        if (!(element instanceof DatasetTag)) continue;

                        const tagText = getTagText(element).toLowerCase();
                        let matchedSearchTerm = null;
                        let termIndexOfMatch = -1;

                        for (let i = 0; i < searchTerms.length; i++) {
                            if (tagText.includes(searchTerms[i])) {
                                matchedSearchTerm = searchTerms[i];
                                termIndexOfMatch = i;
                                break;
                            }
                        }

                        if (matchedSearchTerm !== null) {
                            element.setHighlight(termColors[matchedSearchTerm]);

                            element.style.order = termIndexOfMatch;
                        } else {
                            element.clearHighlight();

                            element.style.order =
                                searchTerms.length + originalDOMIndex;
                        }
                    }

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.addTagButtonElement.style.order =
                            children.length + 1;
                    }
                }
                clearHighlightingAndOrder() {
                    for (const element of this.children) {
                        if (element instanceof DatasetTag) {
                            element.clearHighlight();
                        }
                        element.style.order = "";
                    }
                }
            }
            customElements.define("tag-list", TagList);

            class DatasetEntry extends HTMLElement {
                constructor() {
                    super();
                    this.imageSrc = "";
                    this.imageData = null;
                    this.originalImageName = "";
                    this._selected = false;
                    this._boundCheckAndUpdate =
                        this.checkGroupRequirementsAndUpdateVisuals.bind(
                            this
                        );
                    this._boundHandleImageClick =
                        this._handleImageClick.bind(this);
                    this._boundHandleAutotagClick =
                        this._handleAutotagClick.bind(this);
                    this._boundHandleEntryClick = this._handleEntryClick.bind(this);
                     this._boundHandleContextMenu = this._handleContextMenu.bind(this);
                }
                get selected() {
                    return this.hasAttribute("selected");
                }
                set selected(value) {
                    const isSelected = Boolean(value);
                    if (isSelected) {
                        this.setAttribute("selected", "");
                        this._selected = true;
                    } else {
                        this.removeAttribute("selected");
                        this._selected = false;
                    }
                }
                toggleSelected() {
                    this.selected = !this.selected;
                }
                connectedCallback() {
                    this.classList.add("dataset-entry");
                    if (!this.querySelector(".entry-content")) {
                        this.innerHTML = `
                <div class="entry-content">
                    <img src="${this.imageSrc || ""}" alt="${
                            this.originalImageName || ""
                        }" title="Click to preview">
                    <tag-list direction="row"></tag-list>
                </div>
                <div class="entry-buttons">
                    <button class="autotag-entry material-icons" title="Autotag Image (AI)" speaker="Autotag Image">auto_awesome</button>
                </div>
                <button class="delete-entry material-icons" title="Delete Entry" speaker="Delete Entry">delete_forever</button>`;
                    }
                    this.style.position = "relative";

                    const delBtn = this.querySelector(".delete-entry");
                    delBtn.addEventListener("click", () => this.deleteEntry());

                    const autotagBtn = this.querySelector(".autotag-entry");
                    autotagBtn?.addEventListener(
                        "click",
                        this._boundHandleAutotagClick
                    );

                    this.addEventListener(
                        "tag-updated",
                        this._boundCheckAndUpdate
                    );

                    this.addEventListener(
                        "tag-list-changed-internally",
                        this._boundCheckAndUpdate
                    );

                    const img = this.querySelector("img");
                    img?.addEventListener("click", this._boundHandleImageClick);

                    this.addEventListener("click", this._boundHandleEntryClick);
                    this.addEventListener("contextmenu", this._boundHandleContextMenu);


                    this.checkGroupRequirementsAndUpdateVisuals();
                    this.addDragDropListeners();

                    if (img && this.imageSrc && !img.src) {
                        img.src = this.imageSrc;
                        img.alt = this.originalImageName;
                        img.title = "Click to preview";
                    }
                }
                disconnectedCallback() {
                    const img = this.querySelector("img");
                    if (img?.src.startsWith("blob:")) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.removeEventListener(
                        "tag-updated",
                        this._boundCheckAndUpdate
                    );
                    this.removeEventListener(
                        "tag-list-changed-internally",
                        this._boundCheckAndUpdate
                    );
                    img?.removeEventListener(
                        "click",
                        this._boundHandleImageClick
                    );
                    this.querySelector(".autotag-entry")?.removeEventListener(
                        "click",
                        this._boundHandleAutotagClick
                    );
                    this.removeEventListener("click", this._boundHandleEntryClick);
                    this.removeEventListener("contextmenu", this._boundHandleContextMenu);
                }

                _handleEntryClick(event) {
                    const clickedEntry = this;
                    const wasSelected = clickedEntry.selected;
                    const isCtrlPressed = event.ctrlKey || event.metaKey; // metaKey for macOS
                    const isShiftPressed = event.shiftKey;

                    const targetTagName = event.target.tagName.toLowerCase();
                    if (targetTagName !== 'input' && targetTagName !== 'textarea' && !event.target.isContentEditable && event.target !== clickedEntry.querySelector('img')) {
                       event.preventDefault();
                    }

                    const target = event.target;
                    if (
                        target.closest('button') ||
                        target.closest('dataset-tag') || // Allow click on tag to propagate if needed by tag itself
                        target.closest('span[contenteditable="true"]') ||
                        target.tagName === 'IMG' 
                    ) {
                        // If the dataset-tag was clicked, and it wasn't the editable span or delete button,
                        // it might be for initiating drag. Let the event propagate for that.
                        // If it was span/button, those have their own handlers.
                        if (target.closest('dataset-tag') && !target.closest('span[contenteditable]') && !target.closest('.delete-tag')) {
                            // Fine, could be drag start
                        } else {
                             return; // Otherwise, specific interactive element was clicked.
                        }
                    }
                    
                    event.stopPropagation();

                    if (isShiftPressed && globalLastClickedEntryForShiftSelect && mainContentAreaElement) {
                        const allVisibleEntries = Array.from(mainContentAreaElement.querySelectorAll('dataset-entry:not([style*="display: none"])'));
                        const currentIndex = allVisibleEntries.indexOf(clickedEntry);
                        const lastIndex = allVisibleEntries.indexOf(globalLastClickedEntryForShiftSelect);

                        if (currentIndex !== -1 && lastIndex !== -1) {
                            const start = Math.min(currentIndex, lastIndex);
                            const end = Math.max(currentIndex, lastIndex);

                            if (!isCtrlPressed) {
                                for (const entry of mainContentAreaElement.querySelectorAll('dataset-entry[selected]')) {
                                    entry.selected = false;
                                }
                            }

                            for (let i = start; i <= end; i++) {
                                if (allVisibleEntries[i]) {
                                   allVisibleEntries[i].selected = true;
                                }
                            }
                        } else {
                             clickedEntry.selected = !wasSelected;
                             globalLastClickedEntryForShiftSelect = clickedEntry.selected ? clickedEntry : null;
                        }
                    } else if (isCtrlPressed) {
                        clickedEntry.selected = !wasSelected;
                        if (clickedEntry.selected) {
                            globalLastClickedEntryForShiftSelect = clickedEntry;
                        } else if (globalLastClickedEntryForShiftSelect === clickedEntry) {
                            globalLastClickedEntryForShiftSelect = null;
                        }
                    } else {
                        const currentlySelected = opentaggerAPI.getSelectedEntries();
                        const isAlreadySolelySelected = currentlySelected.length === 1 && currentlySelected[0] === clickedEntry;

                        if (isAlreadySolelySelected && wasSelected) {
                             clickedEntry.selected = false;
                             globalLastClickedEntryForShiftSelect = null;
                        } else {
                            for (const entry of currentlySelected) {
                                entry.selected = false;
                            }
                            clickedEntry.selected = true;
                            globalLastClickedEntryForShiftSelect = clickedEntry;
                        }
                    }
                }

                _handleContextMenu(e) {
                     e.preventDefault();
                     e.stopPropagation();

                     const entry = this;
                     const targetEntries = entry.selected ? opentaggerAPI.getSelectedEntries() : [entry];
                     const targetCount = targetEntries.length;


                     const contextMenuItems = [
                         {
                             label: "Preview Image",
                             callback: () =>
                                 entry._handleImageClick(e), 
                         },
                         {
                             label: "Autotag Image (AI)",
                             callback: () =>
                                 entry.triggerAutotag(false), 
                         },
                         { type: "divider" },
                         { label: `Copy Tags (${targetCount} selected) (NYI)`, disabled: true },
                         { label: `Paste Tags (${targetCount} selected) (NYI)`, disabled: true },
                         { type: "divider" },
                         {
                             label: `Add Tags to ${targetCount} Selected... (NYI via UI)`,
                             disabled: () => targetCount === 0,
                             callback: () => { /* TODO: Prompt for tags */ }
                         },
                         {
                             label: `Remove Tags from ${targetCount} Selected... (NYI via UI)`,
                             disabled: () => targetCount === 0,
                              callback: () => { /* TODO: Prompt for tags */ }
                         },
                         { type: "divider" },
                         {
                             label: "Apply Group Tags",
                             items: getGroupSubmenuItems(targetEntries), 
                             disabled: () => targetCount === 0,
                         },
                         { type: "divider" },
                         {
                             label: "Check Requirements",
                             callback: () =>
                                 entry.checkGroupRequirementsAndUpdateVisuals(), 
                         },
                         { type: "divider" },
                         {
                             label: "Delete Entry",
                             callback: () => entry.deleteEntry(), 
                         },
                     ];

                      if (targetCount > 1) {
                         contextMenuItems.push({ type: "divider" });
                         contextMenuItems.push({
                             label: `Delete ${targetCount} Selected Entries`,
                             callback: () => {
                                 showConfirmationModal(`Are you sure you want to delete ${targetCount} selected entries?`, [
                                     { text: "Delete", class:"modal-button-confirm", onClick: () => {
                                         const entriesToDelete = [...targetEntries];
                                         for(const en of entriesToDelete) en.deleteEntry();
                                         globalLastClickedEntryForShiftSelect = null; 
                                     }},
                                     { text: "Cancel", class:"modal-button-cancel" }
                                 ]);
                             },
                             disabled: () => targetCount === 0,
                         });
                     }

                     createContextMenu(contextMenuItems, e);
                }

                _handleImageClick(e) {
                    e.stopPropagation();
                    if (this.imageSrc) {
                        showImagePreviewModal(
                            this.imageSrc,
                            this.originalImageName
                        );
                    }
                }
                deleteEntry() {
                    const img = this.querySelector("img");
                    if (img?.src.startsWith("blob:") && URL.revokeObjectURL) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.remove();
                    this.dispatchEvent(
                        new CustomEvent("entry-deleted", { bubbles: true })
                    );
                }
                async _handleAutotagClick(e) {
                    e.stopPropagation();
                    await this.triggerAutotag(false);
                }
                async triggerAutotag(silent = false) {
                    const autotagButton = this.querySelector(".autotag-entry");
                    const buttonWrapper = this.querySelector(".entry-buttons");

                    if (!autotagButton) {
                        console.error(
                            `Autotag button not found for ${this.originalImageName}.`
                        );
                        return {
                            success: false,
                            message: "Autotag button not found.",
                            tagsAddedCount: 0,
                            elapsedTime: 0,
                        };
                    }
                    if (!buttonWrapper && !silent) {
                        console.error(
                            `Button wrapper not found for ${this.originalImageName} for timer placement.`
                        );
                    }

                    if (autotagButton.disabled) {
                         if (!silent) {
                             console.warn(
                                 `Autotag for ${this.originalImageName} skipped as button is disabled.`
                             );
                         }
                         return {
                             success: false,
                             message: "Autotag action disabled.",
                             tagsAddedCount: 0,
                             elapsedTime: 0,
                         };
                    }


                    let timer = null;
                    let timerLabel = null;
                    let operationResult = {
                        success: false,
                        message: "Operation not fully completed.",
                        tagsAddedCount: 0,
                        elapsedTime: 0,
                    };

                    if (!silent && buttonWrapper) {
                        buttonWrapper
                            .querySelector(".autotag-timer-label")
                            ?.remove();
                        timerLabel = createTimerLabelElement();
                        buttonWrapper.appendChild(timerLabel);
                        timer = startTimer((timeString) => {
                            if (timerLabel) timerLabel.textContent = timeString;
                        }, 100); 
                    }

                    const originalIcon = autotagButton.textContent;
                    const originalTitle = autotagButton.getAttribute("title");

                    autotagButton.disabled = true;
                    if (!silent) {
                        autotagButton.textContent = "sync";
                        autotagButton.setAttribute(
                            "title",
                            "Autotagging in progress..."
                        );
                        autotagButton.classList.add("loading");
                    }


                    try {
                        const imageData = await this.getImageData();
                        if (!imageData) {
                            throw new Error(
                                "No image data available for autotagging."
                            );
                        }

                        const formData = new FormData();
                        formData.append(
                            "image_upload",
                            imageData,
                            this.originalImageName || "image.png"
                        );

                        const response = await fetch(AUTOTAG_API_URL, {
                            method: "POST",
                            body: formData,
                        });

                        if (!response.ok) {
                            let errorDetail = `HTTP error ${response.status}`;
                            try {
                                const errorJson = await response.json();
                                errorDetail = errorJson.detail || errorDetail;
                            } catch (jsonError) {
                                const errorText = await response.text();
                                errorDetail = errorText || errorDetail;
                            }
                            if (!silent)
                                console.error(
                                    `Autotagging HTTP error ${
                                        response.status
                                    } for ${
                                        this.originalImageName
                                    }. Details: ${errorDetail}. Full response text: ${await response
                                        .text()
                                        .catch(
                                            () => "Could not read response text"
                                        )}`
                                );
                            throw new Error(
                                `Autotagging failed: ${errorDetail}`
                            );
                        }

                        const result = await response.json();
                        const tags = result.tags;
                        let tagsAddedCount = 0;

                        if (Array.isArray(tags)) {
                            for (const tag of tags) {
                                if (this.addTag(tag)) {
                                    tagsAddedCount++;
                                }
                            }
                            if (!silent) {
                                console.log(
                                    `Autotag for ${
                                        this.originalImageName || "untitled"
                                    } complete. ${tagsAddedCount} new tag(s) added. Total AI tags: ${
                                        tags.length
                                    }.`
                                );
                            }
                            operationResult = {
                                success: true,
                                tagsAddedCount: tagsAddedCount,
                                totalAiTags: tags.length,
                                elapsedTime: 0,
                            };
                        } else {
                            throw new Error(
                                "Autotagger returned an unexpected response format."
                            );
                        }
                    } catch (error) {
                        console.error(
                            `Autotagging error for ${
                                this.originalImageName || "untitled"
                            }:`,
                            error
                        );
                        operationResult = {
                            success: false,
                            message: error.message,
                            tagsAddedCount: 0,
                            elapsedTime: 0,
                        };
                    } finally {
                        if (timer) {
                            operationResult.elapsedTime = timer.stop();
                        }
                        if (!silent && timerLabel) {
                            const finalMessage = operationResult.success
                                ? `Done: ${operationResult.elapsedTime.toFixed(
                                      1
                                  )}s`
                                : `Error: ${operationResult.elapsedTime.toFixed(
                                      1
                                  )}s`;
                            timerLabel.textContent = finalMessage;
                            timerLabel.classList.add("fade-out");
                            setTimeout(() => timerLabel.remove(), 2500);
                        }

                        if (!silent) {
                            autotagButton.textContent = originalIcon;
                            autotagButton.setAttribute("title", originalTitle);
                            autotagButton.classList.remove("loading");
                        }

                        if (!autotagAllButton.classList.contains('loading')) {
                             autotagButton.disabled = false;
                        }
                    }
                    return operationResult;
                }
                addDragDropListeners() {
                    const tagList = this.querySelector("tag-list");

                    this.addEventListener("dragenter", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const listRect = tagList.getBoundingClientRect();
                            if (
                                e.clientX >= listRect.left &&
                                e.clientX <= listRect.right &&
                                e.clientY >= listRect.top &&
                                e.clientY <= listRect.bottom
                            ) {
                                tagList.classList.add("drag-over");
                            }
                        }
                    });

                    this.addEventListener("dragover", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const listRect = tagList.getBoundingClientRect();
                            if (
                                e.clientX >= listRect.left &&
                                e.clientX <= listRect.right &&
                                e.clientY >= listRect.top &&
                                e.clientY <= listRect.bottom
                            ) {
                                e.preventDefault();
                                e.stopPropagation();
                                e.dataTransfer.dropEffect =
                                    tagList.determineDropEffect(draggedElement);
                                tagList.classList.add("drag-over");
                            } else {
                                tagList.classList.remove("drag-over");
                            }
                        } else if (e.dataTransfer.types.includes("Files")) {
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });

                    this.addEventListener("dragleave", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const entryRect = this.getBoundingClientRect();
                            if (
                                !this.contains(e.relatedTarget) ||
                                e.clientX < entryRect.left ||
                                e.clientX >= entryRect.right ||
                                e.clientY < entryRect.top ||
                                e.clientY >= entryRect.bottom
                            ) {
                                tagList.classList.remove("drag-over");
                            } else {
                                const listRect =
                                    tagList.getBoundingClientRect();
                                if (
                                    e.clientX < listRect.left ||
                                    e.clientX >= listRect.right ||
                                    e.clientY < listRect.top ||
                                    e.clientY >= listRect.bottom
                                ) {
                                    tagList.classList.remove("drag-over");
                                }
                            }
                        }
                    });

                    this.addEventListener("drop", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            tagList.classList.remove("drag-over");
                        } else if (e.dataTransfer.files?.length > 0) {
                            tagList?.classList.remove("drag-over");
                        } else {
                            tagList?.classList.remove("drag-over");
                        }
                    });
                }
                setImage(blobUrl, fileObject) {
                    const img = this.querySelector("img");
                    if (img?.src.startsWith("blob:") && img.src !== blobUrl && URL.revokeObjectURL) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.imageSrc = blobUrl;
                    this.imageData = fileObject;
                    this.originalImageName =
                        fileObject?.name || `image_${Date.now()}.png`;
                    if (img) {
                        img.src = this.imageSrc;
                        img.alt = this.originalImageName;
                        img.title = "Click to preview";
                    }
                    this.checkGroupRequirementsAndUpdateVisuals();
                }
                async getImageData() {
                    if (
                        this.imageData instanceof Blob ||
                        this.imageData instanceof File
                    ) {
                        return this.imageData;
                    }

                    if (
                        this.imageSrc.startsWith("data:") ||
                        this.imageSrc.startsWith("blob:")
                    ) {
                        try {
                            console.warn(
                                `Attempting to fetch image data from src for ${this.originalImageName}. Direct Blob/File preferred.`
                            );
                            const response = await fetch(this.imageSrc);
                            if (!response.ok)
                                throw new Error(
                                    `HTTP error! status: ${response.status}`
                                );
                            this.imageData = await response.blob();

                            const name =
                                this.originalImageName ||
                                `fetched_image_${Date.now()}.png`;
                            if (this.imageData instanceof Blob) {
                                this.imageData = new File(
                                    [this.imageData],
                                    name,
                                    { type: this.imageData.type }
                                );
                            } else {
                                console.error(
                                    "Fetched data was not a Blob, cannot create File."
                                );
                                return null;
                            }
                            return this.imageData;
                        } catch (e) {
                            console.error(
                                `Error fetching image data from src (${this.imageSrc}):`,
                                e
                            );
                            return null;
                        }
                    }
                    console.error(
                        `Could not get image data for entry: ${this.originalImageName}`
                    );
                    return null;
                }
                addTag(text) {
                    const list = this.querySelector("tag-list");
                    const added = list ? list.addTag(text) : false;

                    return added;
                }
                setTags(tagsArray) {
                    const list = this.querySelector("tag-list");
                    if (list) {
                        list.setTagsFromArray(tagsArray);
                    } else {
                        console.warn(
                            "setTags called on dataset-entry, but internal <tag-list> not found. Tags not set for:",
                            this.originalImageName
                        );
                    }
                }
                getTagsAsString(sep = ", ") {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTagsAsString(sep) : "";
                }
                getTags() {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTags() : [];
                }
                getNormalizedTags() {
                    return this.getTags().map((tag) => tag.toLowerCase());
                }
                checkGroupRequirements() {
                    const groups = document.querySelectorAll(
                        "#tag-group-list tag-group"
                    );
                    const entryTagsLower = this.getNormalizedTags();

                    for (const group of groups) {
                        const minRequired = group.minimumTags;
                        if (minRequired <= 0) continue;

                        const groupTagsLower = group
                            .getGroupTags()
                            .map((t) => t.toLowerCase());
                        if (groupTagsLower.length === 0) continue;

                        let count = 0;
                        for (const entryTag of entryTagsLower) {
                            if (groupTagsLower.includes(entryTag)) {
                                count++;
                            }
                        }
                        if (count < minRequired) {
                            return false;
                        }
                    }
                    return true;
                }
                checkGroupRequirementsAndUpdateVisuals() {
                    const requirementsMet = this.checkGroupRequirements();
                    if (requirementsMet) {
                        this.classList.remove("requirement-not-met");
                    } else {
                        this.classList.add("requirement-not-met");
                    }
                }
                applyTagHighlighting(searchTerms, termColors) {
                    const tagList = this.querySelector("tag-list");
                    tagList?.applyHighlightingAndOrder(searchTerms, termColors);
                }
                clearTagHighlighting() {
                    const tagList = this.querySelector("tag-list");
                    tagList?.clearHighlightingAndOrder();
                }
            }
            customElements.define("dataset-entry", DatasetEntry);

            class TagGroup extends HTMLElement {
                constructor() {
                    super();
                    this._minimumTags = 0;
                    this._boundUpdateMinTags = this._updateMinTags.bind(this);
                    this._boundHandleContextMenu = this._handleContextMenu.bind(this);
                }
                static observedAttributes = ["group-name"];
                get minimumTags() {
                    return this._minimumTags;
                }
                set minimumTags(value) {
                    const newMin = Math.max(0, parseInt(value, 10) || 0);
                    if (newMin !== this._minimumTags) {
                        this._minimumTags = newMin;
                        this.updateMinTagsDisplay();

                        document.dispatchEvent(
                            new CustomEvent("group-min-tags-changed", {
                                detail: { group: this },
                            })
                        );
                    }
                }
                connectedCallback() {
                    const name =
                        this.getAttribute("group-name") || "New Group";
                    const tags = Array.from(
                        this.querySelectorAll("dataset-tag")
                    );
                    this.innerHTML = `
            <div class="group-header">
                <span class="group-name" contenteditable="true">${name}</span>
                 <div class="min-tags-control">
                     <span>Min:</span>
                     <button class="min-tags-decrement material-icons" speaker="Decrease Minimum Tags">remove</button>
                     <span class="min-tags-value">0</span>
                     <button class="min-tags-increment material-icons" speaker="Increase Minimum Tags">add</button>
                 </div>
                 <button class="btn-new-tag material-icons" speaker="Add New Tag">add_circle_outline</button>
            </div>
             <tag-list direction="column"></tag-list>
             <button class="delete-group material-icons" speaker="Delete Group">delete</button>`;
                    this.style.position = "relative";

                    const delBtn = this.querySelector(".delete-group");
                    delBtn.style.cssText = `position: absolute; bottom: 5px; right: 5px; background: none; border: none; cursor: pointer; color: #aaa; font-size: 18px;`;
                    delBtn.addEventListener("click", () => {
                        this.remove();

                        document.dispatchEvent(
                            new CustomEvent("group-min-tags-changed", {
                                detail: { group: null },
                            })
                        );
                    });

                    const list = this.querySelector("tag-list");

                    for (const t of tags) {
                        list.appendChild(t);
                    }
                    this.addEventListeners();
                    this.updateMinTagsDisplay();
                }
                disconnectedCallback() {}
                attributeChangedCallback(name, oldV, newV) {
                    if (name === "group-name") {
                        const s = this.querySelector(".group-name");
                        if (s) s.textContent = newV;
                    }
                }
                addEventListeners() {
                    const addBtn = this.querySelector(".btn-new-tag");
                    const list = this.querySelector("tag-list");
                    const nameSpan = this.querySelector(".group-name");
                    const incBtn = this.querySelector(".min-tags-increment");
                    const decBtn = this.querySelector(".min-tags-decrement");

                    if (addBtn && list) {
                        addBtn.addEventListener("click", () => {
                            const added = list.addTag("new_tag");
                            if (added) {
                                const tagElements =
                                    list.querySelectorAll("dataset-tag");
                                const tag = tagElements[tagElements.length - 1];
                                if (tag) {
                                    const s = tag.querySelector(
                                        "span[contenteditable]"
                                    );
                                    if (s) {
                                        s.setAttribute(
                                            "contenteditable",
                                            "true"
                                        );
                                        tag._originalText = getTagText(tag); // Set original text before focus
                                        s.focus();

                                        window
                                            .getSelection()
                                            .selectAllChildren(s);
                                    }
                                }
                            }
                        });
                    }
                    if (nameSpan) {
                        nameSpan.addEventListener("keydown", (e) => {
                            if (e.key === "Enter") {
                                e.preventDefault();
                                nameSpan.blur();
                            } else if (e.key === "Escape") {
                                nameSpan.textContent =
                                    this.getAttribute("group-name") ||
                                    "New Cat";
                                nameSpan.blur();
                            }
                        });
                        nameSpan.addEventListener("blur", () => {
                            const n = nameSpan.textContent.trim();
                            if (
                                n &&
                                n !==
                                    (this.getAttribute("group-name") ||
                                        "New Cat")
                            ) {
                                this.setAttribute("group-name", n);
                            } else {
                                nameSpan.textContent =
                                    this.getAttribute("group-name") ||
                                    "New Cat";
                            }
                        });
                    }
                    incBtn?.addEventListener("click", () =>
                        this._updateMinTags(1)
                    );
                    decBtn?.addEventListener("click", () =>
                        this._updateMinTags(-1)
                    );

                    addBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    incBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    decBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    nameSpan?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );

                    this.addEventListener("contextmenu", this._boundHandleContextMenu);
                }
                removeEventListeners() {
                     const addBtn = this.querySelector(".btn-new-tag");
                     const nameSpan = this.querySelector(".group-name");
                     const incBtn = this.querySelector(".min-tags-increment");
                     const decBtn = this.querySelector(".min-tags-decrement");

                     addBtn?.removeEventListener("click", this._handleAddTagButtonClick); // Assuming this was a typo for actual method
                     nameSpan?.removeEventListener("keydown", this._handleSpanKeyDown); 
                     nameSpan?.removeEventListener("blur", this._handleSpanBlur); 
                     incBtn?.removeEventListener("click", this._boundUpdateMinTags); // This should be correct
                     decBtn?.removeEventListener("click", this._boundUpdateMinTags); // This should be correct

                     addBtn?.removeEventListener("mousedown", (e) => e.stopPropagation());
                     incBtn?.removeEventListener("mousedown", (e) => e.stopPropagation());
                     decBtn?.removeEventListener("mousedown", (e) => e.stopPropagation());
                     nameSpan?.removeEventListener("mousedown", (e) => e.stopPropagation());

                     this.removeEventListener("contextmenu", this._boundHandleContextMenu);
                }
                _updateMinTags(delta) {
                    this.minimumTags += delta;
                }
                updateMinTagsDisplay() {
                    const valueSpan = this.querySelector(".min-tags-value");
                    if (valueSpan) {
                        valueSpan.textContent = this._minimumTags;
                    }
                }
                getGroupTags() {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTags() : [];
                }
                setTags(tagsArray) {
                    const list = this.querySelector("tag-list");
                    list?.setTagsFromArray(tagsArray);
                }

                _handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const items = [
                        { label: "Rename Group (Double Click Name)", callback: null, disabled: true },
                        {
                            label: "Add New Tag",
                            callback: () => this.querySelector(".btn-new-tag")?.click(),
                        },
                        { type: "divider" },
                        {
                            label: "Delete Group",
                            callback: () => this.querySelector(".delete-group")?.click(),
                        },
                    ];

                    createContextMenu(items, e);
                }
            }
            customElements.define("tag-group", TagGroup);

            class MenuItem extends HTMLElement {
                constructor() {
                    super();
                    this._callback = null;
                    this.submenu = null;
                }
                connectedCallback() {
                    this.submenu = this.querySelector("context-menu");
                    if (this.submenu) {
                        const arrow = document.createElement("span");
                        arrow.className = "submenu-arrow material-icons";
                        arrow.textContent = "arrow_right";
                        this.appendChild(arrow);

                        this.addEventListener("mouseenter", () => {
                            this.submenu.style.display = "flex";
                        });
                        this.addEventListener("mouseleave", () => {
                            this.submenu.style.display = "none";
                        });

                        this.addEventListener("click", (e) => {
                            e.stopPropagation();
                        });
                    } else {
                        this.addEventListener("click", (e) => {
                            e.stopPropagation();
                            if (!this.classList.contains('disabled') && typeof this._callback === "function") {
                                this._callback(e);
                            }
                            this.closestContextMenu()?.hide();
                        });
                    }
                }
                set callback(t) {
                    this._callback = t;
                }
                closestContextMenu() {
                    let e = this.closest("context-menu");
                    while (e && e.parentElement instanceof MenuItem) {
                        e = e.parentElement.closest("context-menu");
                    }
                    return e;
                }
            }
            customElements.define("menu-item", MenuItem);

            class ContextMenu extends HTMLElement {
                constructor() {
                    super();
                    this._boundHide = this.hide.bind(this);
                    this._boundPreventContextMenu = (e) => e.preventDefault();
                }
                connectedCallback() {
                    this.style.display = "none";
                    this.addEventListener(
                        "contextmenu",
                        this._boundPreventContextMenu
                    );
                }
                disconnectedCallback() {
                    document.removeEventListener("click", this._boundHide, {
                        capture: true,
                    });
                    document.removeEventListener(
                        "contextmenu",
                        this._boundHide,
                        { capture: true }
                    );
                    this.removeEventListener(
                        "contextmenu",
                        this._boundPreventContextMenu
                    );
                }
                show(x, y, anchorElement = null) {
                    for (const menu of document.querySelectorAll(
                        "context-menu.visible"
                    )) {
                        menu.hide();
                    }

                    let targetX = x;
                    let targetY = y;

                    if (anchorElement) {
                        const anchorRect =
                            anchorElement.getBoundingClientRect();
                        targetY = anchorRect.bottom + 2;
                        targetX = anchorRect.left;
                    } else {
                        this.style.minWidth = "150px";
                    }

                    this.style.left = `${targetX}px`;
                    this.style.top = `${targetY}px`;
                    this.classList.add("visible");
                    this.style.display = "flex";

                    requestAnimationFrame(() => {
                         const rect = this.getBoundingClientRect();
                         const screenWidth = window.innerWidth;
                         const screenHeight = window.innerHeight;

                         let adjustedX = parseFloat(this.style.left);
                         let adjustedY = parseFloat(this.style.top);

                         if (rect.right > screenWidth) {
                             adjustedX = anchorElement
                                 ? anchorElement.getBoundingClientRect().right -
                                   rect.width
                                 : screenWidth - rect.width - 5;
                         }
                         if (rect.bottom > screenHeight) {
                             adjustedY = anchorElement
                                 ? anchorElement.getBoundingClientRect().top -
                                   rect.height -
                                   2
                                 : screenHeight - rect.height - 5;
                         }
                         if (adjustedX < 0) adjustedX = 5;
                         if (adjustedY < 0) adjustedY = 5;

                         this.style.left = `${adjustedX}px`;
                         this.style.top = `${adjustedY}px`;
                    });


                    setTimeout(() => {
                        document.addEventListener("click", this._boundHide, {
                            capture: true,
                            once: true,
                        });
                        document.addEventListener(
                            "contextmenu",
                            this._boundHide,
                            { capture: true, once: true }
                        );
                    }, 0);
                }
                hide() {
                    if (this.classList.contains("visible")) {
                        this.style.display = "none";
                        this.classList.remove("visible");

                        document.removeEventListener("click", this._boundHide, {
                            capture: true,
                        });
                        document.removeEventListener(
                            "contextmenu",
                            this._boundHide,
                            { capture: true }
                        );

                        for (const submenu of this.querySelectorAll(
                            "context-menu"
                        )) {
                            submenu.style.display = "none";
                        }
                    }
                }
            }
            customElements.define("context-menu", ContextMenu);

            let currentContextMenu = null;
            function createContextMenu(items, triggerElementOrEvent) {
                currentContextMenu?.remove();
                currentContextMenu = null;

                const menu = document.createElement("context-menu");

                for (const item of items) {
                    if (item.type === "divider") {
                        menu.appendChild(document.createElement("hr"));
                    } else {
                        const menuItem = document.createElement("menu-item");
                        menuItem.textContent = item.label || "Item";

                        let isHidden = false;
                        if (typeof item.hidden === 'function') {
                            isHidden = item.hidden(triggerElementOrEvent);
                        } else if (typeof item.hidden === 'boolean') {
                            isHidden = item.hidden;
                        }
                        if (isHidden) {
                            menuItem.style.display = 'none';
                        }


                        let isDisabled = false;
                         if (typeof item.disabled === 'function') {
                             isDisabled = item.disabled(triggerElementOrEvent);
                         } else if (typeof item.disabled === 'boolean') {
                             isDisabled = item.disabled;
                         }

                        if (isDisabled) {
                            menuItem.classList.add('disabled');
                        } else {
                            if (item.callback && typeof item.callback === "function") {
                                menuItem.callback = item.callback;
                            } else if (!item.items) {
                                menuItem.style.opacity = "0.5";
                                menuItem.style.pointerEvents = "none";
                            }
                        }


                        if (item.dataAction)
                            menuItem.dataset.action = item.dataAction;

                        if (item.items && item.items.length > 0) {
                            const subMenu =
                                document.createElement("context-menu");

                            for (const subItem of item.items) {
                                if (subItem.type === "divider") {
                                    subMenu.appendChild(
                                        document.createElement("hr")
                                    );
                                } else {
                                    const subMenuItem =
                                        document.createElement("menu-item");
                                    subMenuItem.textContent =
                                        subItem.label || "Sub Item";

                                     let isSubHidden = false;
                                     if (typeof subItem.hidden === 'function') {
                                         isSubHidden = subItem.hidden(triggerElementOrEvent);
                                     } else if (typeof subItem.hidden === 'boolean') {
                                         isSubHidden = subItem.hidden;
                                     }
                                     if (isSubHidden) {
                                         subMenuItem.style.display = 'none';
                                     }

                                     let isSubDisabled = false;
                                     if (typeof subItem.disabled === 'function') {
                                         isSubDisabled = subItem.disabled(triggerElementOrEvent);
                                     } else if (typeof subItem.disabled === 'boolean') {
                                         isSubDisabled = subItem.disabled;
                                     }

                                     if (isSubDisabled) {
                                         subMenuItem.classList.add('disabled');
                                     } else {
                                         if (subItem.callback && typeof subItem.callback === "function") {
                                             subMenuItem.callback = subItem.callback;
                                         } else if (!subItem.items) {
                                             subMenuItem.style.opacity = "0.5";
                                             subMenuItem.style.pointerEvents = "none";
                                         }
                                     }

                                    if (subItem.dataAction)
                                        subMenuItem.dataset.action =
                                            subItem.dataAction;
                                    subMenu.appendChild(subMenuItem);
                                }
                            }
                            menuItem.appendChild(subMenu);
                        }
                        menu.appendChild(menuItem);
                    }
                }

                document.body.appendChild(menu);
                currentContextMenu = menu;

                if (triggerElementOrEvent instanceof HTMLElement) {
                    currentContextMenu._ownerButton = triggerElementOrEvent;
                } else {
                    currentContextMenu._ownerButton = null;
                }

                if (triggerElementOrEvent instanceof Event) {
                    triggerElementOrEvent.preventDefault();
                    menu.show(
                        triggerElementOrEvent.clientX,
                        triggerElementOrEvent.clientY
                    );
                } else if (triggerElementOrEvent instanceof HTMLElement) {
                    menu.show(0, 0, triggerElementOrEvent);
                }
                return menu;
            }

            function showConfirmationModal(message, buttons) {
                document.querySelector(".modal-overlay")?.remove();

                const overlay = document.createElement("div");
                overlay.className = "modal-overlay";

                const content = document.createElement("div");
                content.className = "modal-content";

                const msgElement = document.createElement("div");
                msgElement.className = "modal-message";
                msgElement.textContent = message;
                msgElement.style.whiteSpace = "pre-wrap";

                const btnContainer = document.createElement("div");
                btnContainer.className = "modal-buttons";

                for (const btnInfo of buttons) {
                    const button = document.createElement("button");
                    button.textContent = btnInfo.text;
                    button.className = btnInfo.class || "modal-button-default";
                    button.addEventListener("click", () => {
                        overlay.remove();
                        if (typeof btnInfo.onClick === "function") {
                            btnInfo.onClick();
                        }
                    });
                    btnContainer.appendChild(button);
                }

                content.appendChild(msgElement);
                content.appendChild(btnContainer);
                overlay.appendChild(content);

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });

                document.body.appendChild(overlay);
            }

            function showImagePreviewModal(imageUrl, imageName) {
                document.querySelector(".image-preview-overlay")?.remove();

                const overlay = document.createElement("div");
                overlay.className = "image-preview-overlay";

                const content = document.createElement("div");
                content.className = "image-preview-content";

                const closeBtn = document.createElement("button");
                closeBtn.className = "image-preview-close material-icons";
                closeBtn.textContent = "close";
                closeBtn.setAttribute("title", "Close Preview");

                const imgPreview = document.createElement("img");
                imgPreview.alt = `Preview: ${imageName}`;

                const infoDiv = document.createElement("div");
                infoDiv.className = "image-preview-info";
                infoDiv.textContent = "Loading image...";

                content.appendChild(closeBtn);
                content.appendChild(imgPreview);
                content.appendChild(infoDiv);
                overlay.appendChild(content);

                const close = () => {
                    overlay.remove();
                    document.removeEventListener("keydown", escapeHandler);
                };

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        close();
                    }
                });
                closeBtn.addEventListener("click", close);

                const escapeHandler = (e) => {
                    if (e.key === "Escape") {
                        close();
                    }
                };
                document.addEventListener("keydown", escapeHandler);

                const tempImg = new Image();
                tempImg.onload = () => {
                    imgPreview.src = imageUrl;
                    infoDiv.innerHTML = `
             <strong>${imageName}</strong>
             <br>
             Dimensions: ${tempImg.naturalWidth} x ${tempImg.naturalHeight} pixels
          `;
                };
                tempImg.onerror = () => {
                    infoDiv.textContent = `Error: Could not load preview for ${imageName}.`;
                    console.error(
                        "Image Preview Modal: Failed to load",
                        imageUrl
                    );
                };
                tempImg.src = imageUrl;

                document.body.appendChild(overlay);
            }

            const checkDropHintVisibility = () => {
                if (!mainContentAreaElement || !dropHint || !searchInput) {
                    return;
                }

                const hasAnyEntries =
                    mainContentAreaElement.querySelector("dataset-entry");

                if (!hasAnyEntries) {
                    dropHint.textContent =
                        "Drag & Drop Images Here, Load Project, or Import Dataset ZIP";
                    dropHint.classList.remove("no-results");
                    dropHint.style.display = "block";
                    return;
                }

                const hasVisibleEntries = mainContentAreaElement.querySelector(
                    'dataset-entry:not([style*="display: none"])'
                );
                if (!hasVisibleEntries && searchInput.value.trim() !== "") {
                    dropHint.textContent = "";
                    dropHint.classList.add("no-results");
                    dropHint.style.display = "block";
                } else {
                    dropHint.classList.remove("no-results");
                    dropHint.style.display = "none";
                }
            };

            async function handleAutotagAllClick() {
                if (
                    !mainContentAreaElement ||
                    !autotagAllButton ||
                    autotagAllButton.disabled
                )
                    return;

                const entriesToAutotag = Array.from(
                    mainContentAreaElement.querySelectorAll(
                        'dataset-entry:not([style*="display: none"])'
                    )
                );

                if (entriesToAutotag.length === 0) {
                    showConfirmationModal("No visible entries to autotag.", [
                        { text: "OK" },
                    ]);
                    return;
                }

                const originalButtonIcon = autotagAllButton.textContent;
                const originalButtonTitle =
                    autotagAllButton.getAttribute("title");

                autotagAllButton.textContent = "sync";
                autotagAllButton.classList.add("loading");
                autotagAllButton.disabled = true;

                let globalTimerLabel =
                    autotagAllButton.parentElement.querySelector(
                        ".autotag-timer-label"
                    );
                if (!globalTimerLabel) {
                    globalTimerLabel = createTimerLabelElement();
                    autotagAllButton.insertAdjacentElement(
                        "afterend",
                        globalTimerLabel
                    );
                } else {
                    globalTimerLabel.textContent = "0.0s";
                    globalTimerLabel.classList.remove("fade-out");
                }

                let successCount = 0;
                let failCount = 0;
                const totalEntries = entriesToAutotag.length;

                let globalTimer = startTimer((timeString) => {
                    if (globalTimerLabel)
                        globalTimerLabel.textContent = timeString;
                    const processedCount = successCount + failCount;
                    autotagAllButton.setAttribute(
                        "title",
                        `Autotagging ${processedCount}/${totalEntries}... (${timeString})`
                    );
                }, 200);

                for (const entry of entriesToAutotag) {
                    const btn = entry.querySelector(".autotag-entry");
                    if (btn) btn.disabled = true;
                }

                for (let i = 0; i < totalEntries; i++) {
                    const entry = entriesToAutotag[i];
                    const entryDisplayName =
                        entry.originalImageName || `entry ${i + 1}`;
                    autotagAllButton.setAttribute(
                        "title",
                        `Autotagging ${
                            successCount + failCount + 1
                        }/${totalEntries}: ${entryDisplayName} (${globalTimer.getElapsedTime()})`
                    );
                    try {
                        const result = await entry.triggerAutotag(true);
                        if (result && result.success) {
                            successCount++;
                            console.log(
                                `Autotagged successfully: ${entryDisplayName}. New tags: ${result.tagsAddedCount}`
                            );
                        } else {
                            failCount++;
                            console.warn(
                                `Autotagging failed or no tags added for: ${entryDisplayName}. Message: ${
                                    result ? result.message : "No details"
                                }`
                            );
                        }
                    } catch (error) {
                        failCount++;
                        console.error(
                            `Critical error during autotag for entry ${entryDisplayName}:`,
                            error
                        );
                    }
                }

                const totalElapsedTime = globalTimer.stop();
                if (globalTimerLabel) {
                    globalTimerLabel.textContent = `Total: ${totalElapsedTime.toFixed(
                        1
                    )}s`;
                    globalTimerLabel.classList.add("fade-out");
                    setTimeout(() => globalTimerLabel.remove(), 3000);
                }

                autotagAllButton.textContent = originalButtonIcon;
                autotagAllButton.setAttribute("title", originalButtonTitle);
                autotagAllButton.classList.remove("loading");
                autotagAllButton.disabled = false;

                for (const entry of entriesToAutotag) {
                    const btn = entry.querySelector(".autotag-entry");
                    if (btn) btn.disabled = false;
                }

                let summaryMessage = `Autotag All complete in ${totalElapsedTime.toFixed(
                    1
                )} seconds.\nSuccessfully processed: ${successCount} entr${
                    successCount === 1 ? "y" : "ies"
                }.`;
                if (failCount > 0) {
                    summaryMessage += `\nFailed or no tags added for: ${failCount} entr${
                        failCount === 1 ? "y" : "ies"
                    }.`;
                }
                if (
                    totalEntries > 0 &&
                    successCount === 0 &&
                    failCount === totalEntries
                ) {
                    summaryMessage = `Autotag All (took ${totalElapsedTime.toFixed(
                        1
                    )}s): All entries failed or had no new tags to add.`;
                } else if (totalEntries === 0) {
                    summaryMessage = "No visible entries were processed.";
                }
                showConfirmationModal(summaryMessage, [{ text: "OK" }]);
            }


            function filterEntries(query) {
                if (!mainContentAreaElement || !searchInput) {
                    console.warn(
                        "filterEntries called but mainContentAreaElement or searchInput is not yet available."
                    );
                    return;
                }

                const entries =
                    mainContentAreaElement.querySelectorAll("dataset-entry");
                query = query.trim().toLowerCase();

                if (query === "") {
                    globalParsedSearchTerms = [];
                    globalSearchTermColors = {};
                } else {
                    globalParsedSearchTerms = getQueryLeafTerms(query);
                    globalSearchTermColors = {};

                    for (const term of globalParsedSearchTerms) {
                        globalSearchTermColors[term] = getTagColor(term);
                    }
                }


                for (const entry of entries) {
                    const tags = entry.getNormalizedTags();
                    let match =
                        query === "" ? true : evaluateExpression(query, tags);

                    entry.style.display = match ? "" : "none";

                    if (match) {
                        if (globalParsedSearchTerms.length > 0) {
                            entry.applyTagHighlighting(
                                globalParsedSearchTerms,
                                globalSearchTermColors
                            );
                        } else {
                            entry.clearTagHighlighting();
                        }
                    } else {
                        entry.clearTagHighlighting();
                    }
                }

                if (query === "") {
                    for (const entry of entries) {
                        entry.clearTagHighlighting();
                    }
                }
                checkDropHintVisibility();
            }

            function logToConsole(
                message,
                type = "info",
                isPreformatted = false
            ) {
                if (!consoleOutputElement) return;

                const messageDiv = document.createElement("div");
                messageDiv.classList.add("console-message", type);

                if (typeof message === "object") {
                    try {
                        message = JSON.stringify(message, null, 2);
                        isPreformatted = true;
                    } catch (e) {
                        message = String(message);
                    }
                } else {
                    message = String(message);
                }

                if (isPreformatted) {
                    const pre = document.createElement("pre");
                    pre.textContent = message;
                    messageDiv.appendChild(pre);
                } else {
                    messageDiv.textContent = message;
                }

                consoleOutputElement.appendChild(messageDiv);
                consoleOutputElement.scrollTop =
                    consoleOutputElement.scrollHeight;
            }

            function toggleDevConsole(focusInput = true) {
                if (!devConsoleElement || !mainView) return;

                isConsoleVisible = !isConsoleVisible;
                if (isConsoleVisible) {
                    const mainViewHeight = mainView.clientHeight;
                    const consoleHeight = Math.min(
                        mainViewHeight * (CONSOLE_MAX_HEIGHT_PERCENT / 100),
                        300
                    );
                    devConsoleElement.style.maxHeight = `${consoleHeight}px`;
                    devConsoleElement.classList.add("visible");

                    if (consoleCodeMirrorInstance && focusInput) {
                        consoleCodeMirrorInstance.focus();
                        consoleCodeMirrorInstance.refresh();
                    }

                    if (
                        !hasShownConsoleWelcomeMessage &&
                        consoleCodeMirrorInstance &&
                        consoleCodeMirrorInstance.getValue().trim() === ""
                    ) {
                        logToConsole(
                            "Console opened. Type /help or JS code. Ctrl+Space for hints. Up/Down for history.",
                            "info"
                        );
                        hasShownConsoleWelcomeMessage = true;
                    }
                } else {
                    devConsoleElement.style.maxHeight = "0";
                    devConsoleElement.classList.remove("visible");

                    if (consoleCodeMirrorInstance) {
                        consoleCodeMirrorInstance.getInputField().blur();
                    }
                }

                setTimeout(() => {
                    if (
                        isConsoleVisible &&
                        consoleCodeMirrorInstance &&
                        document.activeElement !==
                            consoleCodeMirrorInstance.getInputField() &&
                        focusInput
                    ) {
                        consoleCodeMirrorInstance.focus();
                        consoleCodeMirrorInstance.refresh();
                    }
                }, 310);
            }

            function processConsoleInput(inputValue) {
                if (inputValue.startsWith("/")) {
                    const parts =
                        inputValue.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
                    if (parts.length === 0) return;

                    const commandName = parts[0].substring(1).toLowerCase();
                    const args = parts.map((p) =>
                        p.startsWith('"') && p.endsWith('"')
                            ? p.slice(1, -1)
                            : p
                    );


                    const commandObject = slashCommands[commandName];
                    if (
                        commandObject &&
                        typeof commandObject.func === "function"
                    ) {
                        try {
                            const result = commandObject.func(args);
                            if (result !== undefined) {
                                logToConsole(
                                    result,
                                    "success",
                                    typeof result === "object" || (typeof result === "string" && result.includes("\n"))
                                );
                            }
                        } catch (e) {
                            logToConsole(
                                `Error executing command /${commandName}: ${e.message}`,
                                "error"
                            );
                            console.error(`Command /${commandName} error:`, e);
                        }
                    } else {
                        logToConsole(
                            `Unknown command: ${parts[0]}. Type /help for available commands.`,
                            "error"
                        );
                    }
                } else {
                    try {
                        const result = (function (api) {
                            const apiKeys = Object.keys(api);

                            const P = new Proxy(api, {
                                get(target, prop, receiver) {
                                    if (apiKeys.includes(prop))
                                        return target[prop];
                                    if (prop in window) {
                                        if (typeof window[prop] === "function")
                                            return window[prop].bind(window);
                                        return window[prop];
                                    }
                                    return undefined;
                                },
                            });

                            return eval.call(P, `with(this) { ${inputValue} }`);
                        })(opentaggerAPI);

                        if (result !== undefined) {
                            logToConsole(
                                result,
                                "info",
                                typeof result === "object" ||
                                    (typeof result === "string" &&
                                        result.includes("\n"))
                            );
                        }
                    } catch (e) {
                        logToConsole(String(e), "error");
                        console.error("JS execution error:", e);
                    }
                }
            }

            function showMainAppUI() {
                if (splashScreenElement) {
                    splashScreenElement.classList.add("hidden");
                }
                if (appContainer) {
                    appContainer.classList.add("loaded");

                    const sidebar = appContainer.querySelector(".sidebar");
                    const mainViewEl = appContainer.querySelector(".main-view");
                    if (sidebar) sidebar.style.display = "flex";
                    if (mainViewEl) mainViewEl.style.display = "flex";
                }

                checkDropHintVisibility();
                if (mainContentAreaElement) {
                    for (const entry of mainContentAreaElement.querySelectorAll(
                        "dataset-entry"
                    )) {
                        entry.checkGroupRequirementsAndUpdateVisuals();
                    }
                }

                sfx.sfxWelcome.play();
            }

            function clearWorkspaceForNewProject() {
                const groupListContainer =
                    document.getElementById("tag-group-list");
                if (groupListContainer) {
                    groupListContainer.innerHTML = "";
                }

                if (mainContentAreaElement) {
                    const currentEntries =
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry"
                        );

                    for (const el of currentEntries) {
                        el.deleteEntry();
                    }
                }

                if (searchInput) {
                    searchInput.value = "";
                    filterEntries("");
                }

                opentaggerAPI.deselectAllEntries(true); 

                checkDropHintVisibility();
                console.log("Workspace cleared for new project.");
            }

            document.addEventListener("DOMContentLoaded", () => {
                appContainer = document.getElementById("app");
                splashScreenElement = document.getElementById("splash-screen");
                mainView = document.getElementById("main-view");
                mainContentAreaElement =
                    document.getElementById("main-content-area");

                if (mainContentAreaElement) {
                    dropHint =
                        mainContentAreaElement.querySelector(".drop-hint");
                } else {
                    console.warn(
                        "mainContentAreaElement not found during DOMContentLoaded."
                    );
                }

                searchInput = document.getElementById("search-bar");
                autotagAllButton =
                    document.getElementById("autotag-all-button");

                devConsoleElement =
                    document.getElementById("developer-console");
                consoleOutputElement =
                    document.getElementById("console-output");
                const consoleTextArea =
                    document.getElementById("console-input");

                globalTagAutocompleteDropdown = document.getElementById('tag-autocomplete-dropdown');
                if (!globalTagAutocompleteDropdown) {
                    console.error("AutocompleteDropdown element (#tag-autocomplete-dropdown) not found in DOM!");
                }
            
                loadBooruTags().then(tags => {
                    if (tags.length > 0) {
                        console.log("Booru tags ready for autocomplete.");
                    } else {
                        console.warn("Booru tags could not be loaded. Tag autocomplete will not be available.");
                    }
                });


                if (consoleTextArea && typeof CodeMirror !== "undefined") {
                    consoleCodeMirrorInstance = CodeMirror.fromTextArea(
                        consoleTextArea,
                        {
                            mode: "javascript",
                            theme: "neat",
                            lineWrapping: true,
                            autoCloseBrackets: true,
                            matchBrackets: true,
                            extraKeys: {
                                Enter: (cm) => {
                                    const inputValue = cm.getValue().trim();
                                    if (inputValue === "") return;

                                    logToConsole(`> ${inputValue}`, "command");
                                    cm.setValue("");
                                    processConsoleInput(inputValue);

                                    if (
                                        consoleHistory.length === 0 ||
                                        consoleHistory[
                                            consoleHistory.length - 1
                                        ] !== inputValue
                                    ) {
                                        consoleHistory.push(inputValue);
                                    }
                                    if (consoleHistory.length > 50)
                                        consoleHistory.shift();
                                    consoleHistoryIndex = consoleHistory.length;
                                    currentConsoleInputBuffer = "";
                                },
                                Up: (cm) => {
                                    if (
                                        consoleHistoryIndex ===
                                            consoleHistory.length &&
                                        cm.getValue() !== ""
                                    ) {
                                        currentConsoleInputBuffer =
                                            cm.getValue();
                                    }
                                    if (consoleHistoryIndex > 0) {
                                        consoleHistoryIndex--;
                                        cm.setValue(
                                            consoleHistory[consoleHistoryIndex]
                                        );
                                        cm.setCursor(cm.lineCount(), 0);
                                    }
                                    return true;
                                },
                                Down: (cm) => {
                                    if (
                                        consoleHistoryIndex <
                                        consoleHistory.length - 1
                                    ) {
                                        consoleHistoryIndex++;
                                        cm.setValue(
                                            consoleHistory[consoleHistoryIndex]
                                        );
                                        cm.setCursor(cm.lineCount(), 0);
                                    } else if (
                                        consoleHistoryIndex ===
                                        consoleHistory.length - 1
                                    ) {
                                        consoleHistoryIndex++;
                                        cm.setValue(currentConsoleInputBuffer);
                                        currentConsoleInputBuffer = "";
                                        cm.setCursor(cm.lineCount(), 0);
                                    }
                                    return true;
                                },
                                Esc: (cm) => {
                                    if (isConsoleVisible)
                                        toggleDevConsole(false);
                                },
                                "Ctrl-Space": "autocomplete",
                            },
                            hintOptions: {
                                hint: customCodeMirrorHints,
                                completeSingle: false,
                            },
                        }
                    );

                    consoleCodeMirrorInstance.on(
                        "inputRead",
                        function (cm, event) {
                            if (
                                cm.state.completionActive ||
                                !event ||
                                event.origin === "+delete" ||
                                event.origin === "paste" ||
                                /[ ;\),\(\]\}\[\{]/.test(event.text[0]) ||
                                event.key === "Enter" ||
                                event.key === "Escape" ||
                                (event.key && event.key.includes("Arrow"))
                            ) {
                                return;
                            }
                            CodeMirror.commands.autocomplete(cm, null, {
                                completeSingle: false,
                            });
                        }
                    );
                } else if (!consoleTextArea) {
                    console.warn(
                        "Console textarea (#console-input) not found for CodeMirror."
                    );
                } else if (typeof CodeMirror === "undefined") {
                    console.warn(
                        "CodeMirror library not loaded. Console will use basic textarea."
                    );
                    if (consoleTextArea) {
                        consoleTextArea.addEventListener("keydown", (e) => {
                            if (e.key === "Enter" && !e.shiftKey) {
                                e.preventDefault();
                                const inputValue = consoleTextArea.value.trim();
                                if (inputValue === "") return;
                                logToConsole(`> ${inputValue}`, "command");
                                processConsoleInput(inputValue);
                                consoleTextArea.value = "";
                            } else if (e.key === "Escape") {
                                if (isConsoleVisible) toggleDevConsole(false);
                            }
                        });
                    }
                }

                document.addEventListener("keydown", (event) => {
                    if (event.key === "F1") {
                        event.preventDefault();
                        if (
                            splashScreenElement &&
                            !splashScreenElement.classList.contains("hidden")
                        ) {
                            return;
                        }

                        const targetTagName =
                            event.target.tagName.toLowerCase();
                        if (
                            targetTagName === "input" ||
                            targetTagName === "textarea" ||
                            event.target.isContentEditable
                        ) {
                            if (
                                consoleCodeMirrorInstance &&
                                event.target ===
                                    consoleCodeMirrorInstance.getInputField()
                            ) {
                            } else {
                                return;
                            }
                        }
                        toggleDevConsole();
                    }
                });

                if (
                    window.location.origin &&
                    window.location.origin !== "null"
                ) {
                    console.log("Frontend Origin:", window.location.origin);
                } else {
                    console.warn(
                        "Frontend Origin is 'null' or not available (likely file:// URL). Some fetch operations to localhost might be restricted by CORS if backend isn't configured for 'null' origin."
                        );
                }

                const groupListContainer =
                    document.getElementById("tag-group-list");
                const addGroupButton =
                    document.getElementById("btn-add-group");
                const projectFileInput =
                    document.getElementById("project-file-input");
                const datasetZipInput =
                    document.getElementById("dataset-zip-input");

                const splashNewProjectBtn =
                    document.getElementById("splash-new-project");
                const splashOpenProjectBtn = document.getElementById(
                    "splash-open-project"
                );

                if (splashNewProjectBtn) {
                    splashNewProjectBtn.addEventListener("click", () => {
                        clearWorkspaceForNewProject();
                        showMainAppUI();
                    });
                }
                if (splashOpenProjectBtn) {
                    splashOpenProjectBtn.addEventListener("click", () => {
                        if (projectFileInput) projectFileInput.click();
                    });
                }

                if (projectFileInput) {
                    projectFileInput.addEventListener(
                        "change",
                        handleProjectFileSelect
                    );
                }
                if (datasetZipInput) {
                    datasetZipInput.addEventListener(
                        "change",
                        handleDatasetZipSelect
                    );
                }

                if (autotagAllButton) {
                    autotagAllButton.addEventListener(
                        "click",
                        handleAutotagAllClick
                    );
                }

                if (searchInput) {
                    const debouncedFilter = debounce(filterEntries, 300);
                    searchInput.addEventListener("input", () =>
                        debouncedFilter(searchInput.value)
                    );
                }

                if (mainView) {
                    mainView.addEventListener("dragenter", (e) => {
                        if (e.dataTransfer.types.includes("Files")) {
                            e.preventDefault();
                            e.stopPropagation();
                            mainView.classList.add("drag-over");
                            e.dataTransfer.dropEffect = "copy";
                        }
                    });
                    mainView.addEventListener("dragover", (e) => {
                        if (e.dataTransfer.types.includes("Files")) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = "copy";
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });
                    mainView.addEventListener("dragleave", (e) => {
                        if (
                            !mainView.contains(e.relatedTarget) ||
                            e.target === mainView
                        ) {
                            mainView.classList.remove("drag-over");
                        }
                    });
                    mainView.addEventListener("drop", (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        mainView.classList.remove("drag-over");
                        if (
                            e.dataTransfer.files?.length > 0 &&
                            !draggedElement
                        ) {
                            const droppedFile = e.dataTransfer.files[0];
                            if (
                                droppedFile &&
                                droppedFile.name.endsWith(
                                    PROJECT_FILE_EXTENSION
                                )
                            ) {
                                handleProjectFileSelect({
                                    target: { files: [droppedFile] },
                                });
                            } else if (
                                droppedFile &&
                                droppedFile.name.endsWith(".zip")
                            ) {
                                handleDatasetZipSelect({
                                    target: { files: [droppedFile] },
                                });
                            } else {
                                handleFiles(e.dataTransfer.files);
                            }
                        } else {
                            console.log(
                                "Drop event on main-view ignored (not files or handled by child)."
                            );
                        }
                    });
                }

                function handleFiles(files) {
                    if (!mainContentAreaElement || !searchInput) return;
                    for (const file of files) {
                        if (file.type.startsWith("image/")) {
                            const blobUrl = URL.createObjectURL(file);
                            const entry =
                                document.createElement("dataset-entry");
                            entry.setImage(blobUrl, file);

                            let referenceNode = dropHint?.isConnected
                                ? dropHint
                                : null;
                            if (
                                referenceNode &&
                                referenceNode.parentElement ===
                                    mainContentAreaElement
                            ) {
                                mainContentAreaElement.insertBefore(
                                    entry,
                                    referenceNode
                                );
                            } else {
                                mainContentAreaElement.appendChild(entry);
                            }

                            if (searchInput.value.trim() !== "") {
                                const currentQuery = searchInput.value
                                    .trim()
                                    .toLowerCase();
                                const tags = entry.getNormalizedTags();
                                const isMatch = evaluateExpression(
                                    currentQuery,
                                    tags
                                );
                                entry.style.display = isMatch ? "" : "none";
                                if (isMatch && globalParsedSearchTerms.length > 0) {
                                    entry.applyTagHighlighting(
                                        globalParsedSearchTerms,
                                        globalSearchTermColors
                                    );
                                } else {
                                    entry.clearTagHighlighting();
                                }
                            } else {
                                entry.clearTagHighlighting();
                            }
                        } else if (file.name.endsWith(PROJECT_FILE_EXTENSION)) {
                            handleProjectFileSelect({
                                target: { files: [file] },
                            });
                        } else if (file.name.endsWith(".zip")) {
                            handleDatasetZipSelect({
                                target: { files: [file] },
                            });
                        } else {
                            console.warn(
                                `Skipped non-image file: ${file.name}`
                            );
                        }
                    }
                    checkDropHintVisibility();
                }

                if (addGroupButton) {
                    addGroupButton.addEventListener("click", () => {
                        const cat = document.createElement("tag-group");
                        cat.setAttribute("group-name", "New Cat");
                        if (groupListContainer)
                            groupListContainer.appendChild(cat);
                        const span = cat.querySelector(".group-name");
                        if (span) {
                            requestAnimationFrame(() => {
                                span.focus();

                                window.getSelection().selectAllChildren(span);
                            });
                        }
                    });
                }

                const menuBarButtons =
                    document.querySelectorAll("#menu-bar button");

                for (const button of menuBarButtons) {
                    button.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        if (
                            splashScreenElement &&
                            !splashScreenElement.classList.contains("hidden")
                        ) {
                            const buttonAction = button.textContent
                                .trim()
                                .toLowerCase();

                            if (
                                buttonAction === "file" ||
                                buttonAction === "new project" ||
                                buttonAction === "load project..."
                            ) {
                            } else {
                            }
                        }

                        if (
                            currentContextMenu &&
                            currentContextMenu.classList.contains("visible") &&
                            currentContextMenu._ownerButton === button
                        ) {
                            currentContextMenu.hide();
                            return;
                        }

                        const type = button.textContent.trim().toLowerCase();
                        let items = [];
                        switch (type) {
                            case "file":
                                items = [
                                    {
                                        label: "New Project",
                                        callback: () => {
                                            clearWorkspaceForNewProject();
                                            showMainAppUI();
                                        },
                                        dataAction: "new-project",
                                    },
                                    { type: "divider" },
                                    {
                                        label: "Save Project",
                                        callback: () => {
                                            if (
                                                splashScreenElement &&
                                                !splashScreenElement.classList.contains(
                                                    "hidden"
                                                )
                                            ) {
                                                showMainAppUI();
                                            }
                                            saveProject();
                                        },
                                        dataAction: "save-project",
                                    },
                                    {
                                        label: "Load Project...",
                                        callback: () =>
                                            projectFileInput?.click(),
                                    },
                                    { type: "divider" },

                                    {
                                        label: "Import Dataset (ZIP)...",
                                        callback: () =>
                                            datasetZipInput?.click(),
                                        dataAction: "import-dataset-zip",
                                    },
                                    {
                                        label: "Export Dataset (ZIP)",
                                        dataAction: "export",
                                        callback: () => {
                                            if (
                                                splashScreenElement &&
                                                !splashScreenElement.classList.contains(
                                                    "hidden"
                                                )
                                            ) {
                                                showMainAppUI();
                                            }
                                            confirmAndExportDataset();
                                        },
                                    },
                                ];
                                break;
                            case "edit":
                                items = [
                                    { label: "Undo (NYI)", disabled: true },
                                    { label: "Redo (NYI)", disabled: true },
                                    { type: "divider" },
                                    {
                                        label: "Clear Search",
                                        callback: () => {
                                            if (searchInput)
                                                searchInput.value = "";
                                            filterEntries("");
                                        },
                                    },
                                     { type: "divider" },
                                    {
                                        label: "Select All Visible",
                                        callback: () => opentaggerAPI.selectEntries("", false)
                                    },
                                    {
                                        label: "Deselect All",
                                        callback: () => opentaggerAPI.deselectAllEntries()
                                    },
                                    { type: "divider" },
                                    { label: "Prefs (NYI)", disabled: true },
                                ];
                                break;
                            case "view":
                                items = [
                                    { label: "Zoom In (NYI)", disabled: true },
                                    { label: "Zoom Out (NYI)", disabled: true },
                                    { type: "divider" },
                                    {
                                        label: "Re-check All Requirements",
                                        callback: () => {
                                            if (!mainContentAreaElement) return;

                                            for (const entry of mainContentAreaElement.querySelectorAll(
                                                "dataset-entry"
                                            )) {
                                                entry.checkGroupRequirementsAndUpdateVisuals();
                                            }
                                            console.log(
                                                "Manually re-checked all entry requirements."
                                            );
                                        },
                                    },
                                ];
                                break;
                            case "help":
                                items = [{ label: "About (NYI)", disabled: true }];
                                break;
                            default:
                                return;
                        }
                        if (items.length > 0) createContextMenu(items, button);
                    });
                }

                document.addEventListener("contextmenu", (e) => {
                    currentContextMenu?.hide();

                    if (splashScreenElement && !splashScreenElement.classList.contains("hidden")) {
                         const onSplash = e.target.closest("#splash-screen");
                         if (!onSplash) {
                             e.preventDefault(); 
                         }
                         return; 
                    }

                    if (e.target.closest('dataset-tag, dataset-entry, tag-group')) {
                        return;
                    }
                    if (globalTagAutocompleteDropdown && globalTagAutocompleteDropdown.contains(e.target)) {
                        // Allow context menu on the autocomplete dropdown itself if needed (currently not)
                        // Or prevent default here: e.preventDefault();
                        return;
                    }


                    const targetTagName = e.target.tagName.toLowerCase();
                    if (
                        e.target.closest('span[contenteditable="true"]') ||
                        targetTagName === "input" ||
                        targetTagName === "textarea" ||
                        (consoleCodeMirrorInstance &&
                            consoleCodeMirrorInstance
                                .getWrapperElement()
                                .contains(e.target))
                    ) {
                        return; 
                    }


                    e.preventDefault();
                    e.stopPropagation();

                    const generalItems = [
                        {
                            label: "Add Tags",
                            callback: () =>
                                addGroupButton?.click(),
                        },
                        { type: "divider" },
                        {
                            label: "Autotag All Visible",
                            callback: () => handleAutotagAllClick(),
                        },
                        {
                            label: "Re-check All Requirements",
                            callback: () => {
                                if (!mainContentAreaElement) return;

                                for (const entry of mainContentAreaElement.querySelectorAll(
                                    "dataset-entry"
                                )) {
                                    entry.checkGroupRequirementsAndUpdateVisuals();
                                }
                            },
                        },
                        { type: "divider" },
                        {
                            label: "Select All Visible",
                            callback: () => opentaggerAPI.selectEntries("", false)
                        },
                        {
                            label: "Deselect All",
                            callback: () => opentaggerAPI.deselectAllEntries()
                        },
                    ];
                    createContextMenu(generalItems, e);
                });

                document.addEventListener("group-min-tags-changed", () => {
                    if (!mainContentAreaElement) return;

                    for (const entry of mainContentAreaElement.querySelectorAll(
                        "dataset-entry"
                    )) {
                        entry.checkGroupRequirementsAndUpdateVisuals();
                    }
                });

                if (
                    appContainer &&
                    appContainer.classList.contains("loaded") &&
                    dropHint
                ) {
                    checkDropHintVisibility();
                }

                if (mainContentAreaElement) {
                    const mainContentObserver = new MutationObserver(
                        (mutationsList) => {
                            let listChanged = false;
                            for (const mutation of mutationsList) {
                                if (mutation.type === "childList") {
                                    const addedEntries = Array.from(
                                        mutation.addedNodes
                                    ).filter(
                                        (node) =>
                                            node.tagName === "DATASET-ENTRY"
                                    );
                                    const removedEntries = Array.from(
                                        mutation.removedNodes
                                    ).filter(
                                        (node) =>
                                            node.tagName === "DATASET-ENTRY"
                                    );

                                    if (
                                        addedEntries.length > 0 ||
                                        removedEntries.length > 0
                                    ) {
                                        listChanged = true;

                                        for (const entry of addedEntries) {
                                            requestAnimationFrame(() =>
                                                entry.checkGroupRequirementsAndUpdateVisuals()
                                            );
                                        }
                                        if (globalLastClickedEntryForShiftSelect && removedEntries.includes(globalLastClickedEntryForShiftSelect)) {
                                            globalLastClickedEntryForShiftSelect = null;
                                        }
                                        break;
                                    }
                                }
                            }
                            if (listChanged) checkDropHintVisibility();
                        }
                    );
                    mainContentObserver.observe(mainContentAreaElement, {
                        childList: true,
                    });

                    mainContentAreaElement.addEventListener(
                        "entry-deleted",
                        () => checkDropHintVisibility()
                    );
                }

                if (
                    appContainer &&
                    appContainer.classList.contains("loaded") &&
                    mainContentAreaElement
                ) {
                    for (const entry of mainContentAreaElement.querySelectorAll(
                        "dataset-entry"
                    )) {
                        entry.checkGroupRequirementsAndUpdateVisuals();
                    }
                }
            });

            async function saveProject() {
                console.log("Starting project save...");
                showConfirmationModal("Saving project...", []);

                const groups = [];

                for (const catElement of document.querySelectorAll(
                    "#tag-group-list tag-group"
                )) {
                    groups.push({
                        name:
                            catElement.getAttribute("group-name") ||
                            "Unnamed Group",
                        minimumTags: catElement.minimumTags,
                        tags: catElement.getGroupTags(),
                    });
                }

                const entries = [];
                if (!mainContentAreaElement) {
                    console.error(
                        "Cannot save project: mainContentAreaElement element not found."
                    );
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        "Error saving project: UI elements missing.",
                        [{ text: "OK" }]
                    );
                    return;
                }
                const entryElements =
                    mainContentAreaElement.querySelectorAll("dataset-entry");
                const imageSavePromises = [];
                const zip = new JSZip();
                const imagesFolder = zip.folder("images");

                const usedImageNames = new Set();

                for (const entryElement of entryElements) {
                    const originalName =
                        entryElement.originalImageName ||
                        `entry_${Date.now()}.png`;

                    let safeName = sanitizeFilename(originalName);
                    let uniqueName = safeName;
                    let counter = 1;
                    while (usedImageNames.has(uniqueName.toLowerCase())) {
                        const extension = uniqueName.includes(".")
                            ? uniqueName.substring(uniqueName.lastIndexOf("."))
                            : "";
                        const base = uniqueName.includes(".")
                            ? uniqueName.substring(
                                  0,
                                  uniqueName.lastIndexOf(".")
                              )
                            : uniqueName;

                        const baseWithoutCounter = base.replace(/_\d+$/, "");
                        uniqueName = `${baseWithoutCounter}_${counter++}${extension}`;
                    }
                    usedImageNames.add(uniqueName.toLowerCase());

                    entries.push({
                        imageName: uniqueName,
                        tags: entryElement.getTags(),
                    });

                    imageSavePromises.push(
                        entryElement
                            .getImageData()
                            .then((imageData) => {
                                if (imageData) {
                                    imagesFolder.file(uniqueName, imageData, {
                                        binary: true,
                                    });
                                } else {
                                    console.warn(
                                        `Could not get image data for entry originally named: ${originalName}. Skipping image file.`
                                    );

                                    throw new Error(
                                        `Missing image data for ${originalName}`
                                    );
                                }
                            })
                            .catch((err) => {
                                console.error(
                                    `Error processing image for ${originalName}:`,
                                    err
                                );
                                return {
                                    status: "rejected",
                                    reason: `Failed to process image: ${originalName}`,
                                };
                            })
                    );
                }

                const projectData = {
                    version: 1,
                    groups: groups,
                    entries: entries,
                };
                zip.file("project.json", JSON.stringify(projectData, null, 2));

                const results = await Promise.allSettled(imageSavePromises);
                document.querySelector(".modal-overlay")?.remove();

                const failedImages = results.filter(
                    (r) => r.status === "rejected"
                );
                if (failedImages.length > 0) {
                    console.error(
                        `${failedImages.length} image(s) failed to save.`
                    );
                    showConfirmationModal(
                        `Warning: ${failedImages.length} image(s) could not be read or saved. The project file might be incomplete. Save anyway?`,
                        [
                            {
                                text: "Save Anyway",
                                onClick: () =>
                                    generateAndDownloadZip(zip, "Save Project"),
                                class: "modal-button-confirm",
                            },
                            {
                                text: "Cancel",
                                onClick: () =>
                                    console.log(
                                        "Project save cancelled due to image errors."
                                    ),
                                class: "modal-button-cancel",
                            },
                        ]
                    );
                } else {
                    generateAndDownloadZip(zip, "Save Project");
                }
            }

            async function generateAndDownloadZip(
                zip,
                menuActionText = "Processing..."
            ) {
                const menuSave = document.querySelector(
                    'menu-item[data-action="save-project"]'
                );
                 const menuExport = document.querySelector(
                     'menu-item[data-action="export"]'
                 );
                 const targetMenuItem = menuSave || menuExport;
                 const originalText = targetMenuItem?.textContent || menuActionText;


                if (targetMenuItem) {
                    targetMenuItem.textContent = "Zipping...";
                    targetMenuItem.style.pointerEvents = "none";
                } else {
                    showConfirmationModal("Zipping project...", []);
                }

                try {
                    const blob = await zip.generateAsync(
                        {
                            type: "blob",
                            compression: "DEFLATE",
                            compressionOptions: { level: 6 },
                        },
                        (metadata) => {
                            const progressText = `Zipping... (${metadata.percent.toFixed(
                                0
                            )}%)`;
                            if (targetMenuItem) targetMenuItem.textContent = progressText;
                            else {
                                const modalMsg = document.querySelector(
                                    ".modal-overlay .modal-message"
                                );
                                if (modalMsg)
                                    modalMsg.textContent = progressText;
                            }
                        }
                    );
                    document.querySelector(".modal-overlay")?.remove();
                    const filename = menuSave ? `lora_project_${Date.now()}${PROJECT_FILE_EXTENSION}` : "lora_dataset_export.zip";
                    saveAs(
                        blob,
                        filename
                    );
                    console.log("Project saved successfully.");
                    showConfirmationModal(menuSave ? "Project saved successfully!" : "Dataset exported successfully!", [
                        { text: "OK" },
                    ]);
                } catch (err) {
                    console.error("Error generating ZIP:", err);
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        "Error generating file. Check console for details.",
                        [{ text: "OK" }]
                    );
                } finally {
                    if (targetMenuItem) {
                        targetMenuItem.textContent = originalText;
                        targetMenuItem.style.pointerEvents = "auto";
                    }
                }
            }

            function handleProjectFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                event.target.value = null;

                if (!file.name.endsWith(PROJECT_FILE_EXTENSION)) {
                    showConfirmationModal(
                        `Invalid file type. Please select a ${PROJECT_FILE_EXTENSION} file.`,
                        [{ text: "OK" }]
                    );
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const zipData = e.target.result;
                        await loadProjectFromZip(zipData);
                        showMainAppUI();
                    } catch (error) {
                        console.error("Error loading project file:", error);
                        document.querySelector(".modal-overlay")?.remove();
                        showConfirmationModal(
                            `Error loading project: ${error.message}. Check console for details.`,
                            [{ text: "OK" }]
                        );
                    }
                };
                reader.onerror = (e) => {
                    console.error("FileReader error:", e);
                    showConfirmationModal("Error reading project file.", [
                        { text: "OK" },
                    ]);
                };
                reader.readAsArrayBuffer(file);
            }

            async function loadProjectFromZip(zipData) {
                console.log("Loading project from zip data...");
                showConfirmationModal("Loading project...", []);

                let zip;
                try {
                    zip = await JSZip.loadAsync(zipData);
                } catch (e) {
                    console.error("Failed to load ZIP data:", e);
                    throw new Error(
                        "Invalid or corrupted project file (could not read as ZIP)."
                    );
                }

                const projectFile = zip.file("project.json");
                if (!projectFile) {
                    throw new Error(
                        "Invalid project file: 'project.json' not found."
                    );
                }
                let projectJson;
                try {
                    projectJson = await projectFile.async("string");
                } catch (e) {
                    console.error("Failed to read project.json:", e);
                    throw new Error(
                        "Could not read 'project.json' from the file."
                    );
                }
                let projectData;
                try {
                    projectData = JSON.parse(projectJson);
                } catch (e) {
                    console.error("Failed to parse project.json:", e);
                    throw new Error(
                        "Invalid project file: Could not parse 'project.json'."
                    );
                }

                if (
                    !projectData ||
                    typeof projectData !== "object" ||
                    projectData.version !== 1
                ) {
                    throw new Error(
                        "Invalid or unsupported project file format/version."
                    );
                }
                if (
                    !Array.isArray(projectData.groups) ||
                    !Array.isArray(projectData.entries)
                ) {
                    throw new Error(
                        "Invalid project data structure (missing groups or entries array)."
                    );
                }

                clearWorkspaceForNewProject();

                console.log(
                    `Loading ${projectData.groups.length} groups...`
                );
                const groupListContainer =
                    document.getElementById("tag-group-list");

                for (const catData of projectData.groups) {
                    const groupElement =
                        document.createElement("tag-group");
                    groupElement.setAttribute(
                        "group-name",
                        catData.name || "Unnamed"
                    );

                    requestAnimationFrame(() => {
                        groupElement.minimumTags = catData.minimumTags || 0;
                        groupElement.setTags(catData.tags || []);
                    });
                    groupListContainer.appendChild(groupElement);
                }

                console.log(`Loading ${projectData.entries.length} entries...`);
                let loadedCount = 0;
                let errorCount = 0;
                const imageLoadErrors = [];

                const loadingModalMsg = document.querySelector(
                    ".modal-overlay .modal-message"
                );
                if (loadingModalMsg)
                    loadingModalMsg.textContent = `Loading ${projectData.entries.length} entries...`;

                const entryCreationPromises = projectData.entries.map(
                    async (entryData, index) => {
                        if (
                            !entryData ||
                            typeof entryData.imageName !== "string"
                        ) {
                            console.warn(
                                `Skipping invalid entry data at index ${index}.`
                            );
                            imageLoadErrors.push(
                                `Invalid entry data at index ${index}.`
                            );
                            return null;
                        }

                        const imageName = entryData.imageName;
                        const imageFileInZip = zip.file(`images/${imageName}`);

                        if (!imageFileInZip) {
                            console.warn(
                                `Image '${imageName}' not found in project zip's images/ folder. Skipping entry.`
                                );
                            imageLoadErrors.push(
                                `Image not found in zip: images/${imageName}`
                            );
                            return null;
                        }

                        let blobUrl;
                        try {
                            const imageDataBlob = await imageFileInZip.async(
                                "blob"
                            );
                            blobUrl = URL.createObjectURL(imageDataBlob);

                            const imageFileObject = new File(
                                [imageDataBlob],
                                imageName,
                                { type: imageDataBlob.type }
                            );

                            const entryElement =
                                document.createElement("dataset-entry");
                            entryElement.setImage(blobUrl, imageFileObject);
                            return {
                                element: entryElement,
                                tags: entryData.tags || [],
                            };
                        } catch (err) {
                            console.error(
                                `Error processing entry image '${imageName}':`,
                                err
                            );
                            imageLoadErrors.push(
                                `Error loading ${imageName}: ${err.message}`
                            );
                            if (typeof blobUrl !== "undefined" && URL.revokeObjectURL)
                                URL.revokeObjectURL(blobUrl);
                            return null;
                        }
                    }
                );

                const processedEntries = await Promise.all(
                    entryCreationPromises
                );

                for (const [index, result] of processedEntries.entries()) {
                    if (result && mainContentAreaElement) {
                        let referenceNode = dropHint?.isConnected
                            ? dropHint
                            : null;
                        if (
                            referenceNode &&
                            referenceNode.parentElement ===
                                mainContentAreaElement
                        ) {
                            mainContentAreaElement.insertBefore(
                                result.element,
                                referenceNode
                            );
                        } else {
                            mainContentAreaElement.appendChild(result.element);
                        }
                        result.element.setTags(result.tags);
                        loadedCount++;
                        if (loadingModalMsg && index % 10 === 0) {
                            loadingModalMsg.textContent = `Loading entry ${
                                index + 1
                            } / ${projectData.entries.length}...`;
                        }
                    } else if (result && !mainContentAreaElement) {
                        console.error(
                            "mainContentAreaElement not available to append loaded entry. This is unexpected."
                        );
                        errorCount++;
                    } else if (!result) {
                        errorCount++;
                    }
                }

                document.querySelector(".modal-overlay")?.remove();

                let resultMessage = `Project loaded successfully. ${loadedCount} entries added.`;
                if (errorCount > 0) {
                    resultMessage += ` ${errorCount} error(s) encountered (check console for details).`;
                    console.error(
                        "Errors during project load (image or data issues):",
                        imageLoadErrors
                    );
                }
                showConfirmationModal(resultMessage, [{ text: "OK" }]);
                checkDropHintVisibility();
            }

            async function handleDatasetZipSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                event.target.value = null;

                if (!file.name.endsWith(".zip")) {
                    showConfirmationModal(
                        "Invalid file type. Please select a .zip file for dataset import.",
                        [{ text: "OK" }]
                    );
                    return;
                }

                showConfirmationModal("Importing dataset from ZIP...", []);
                console.log(`Importing dataset from: ${file.name}`);

                try {
                    const zipData = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(zipData);

                    const imageFiles = [];
                    const textFiles = {};

                    zip.forEach((relativePath, zipEntry) => {
                        if (zipEntry.dir) return;

                        const fileName = relativePath.substring(
                            relativePath.lastIndexOf("/") + 1
                        );
                        const lowerFileName = fileName.toLowerCase();

                        if (
                            /\.(jpe?g|png|webp|gif|bmp|tiff)$/i.test(
                                lowerFileName
                            )
                        ) {
                            imageFiles.push(zipEntry);
                        } else if (lowerFileName.endsWith(".txt")) {
                            const baseName = lowerFileName.substring(
                                0,
                                lowerFileName.lastIndexOf(".txt")
                            );
                            textFiles[baseName] = zipEntry.async("string");
                        }
                    });

                    if (imageFiles.length === 0) {
                        document.querySelector(".modal-overlay")?.remove();
                        showConfirmationModal(
                            "No image files found in the ZIP archive.",
                            [{ text: "OK" }]
                        );
                        return;
                    }

                    const loadingModalMsg = document.querySelector(
                        ".modal-overlay .modal-message"
                    );
                    if (loadingModalMsg)
                        loadingModalMsg.textContent = `Processing ${imageFiles.length} images...`;

                    let importedCount = 0;
                    let errorCount = 0;

                    for (let i = 0; i < imageFiles.length; i++) {
                        const imageEntry = imageFiles[i];
                        const imageName = imageEntry.name.substring(
                            imageEntry.name.lastIndexOf("/") + 1
                        );
                        if (loadingModalMsg)
                            loadingModalMsg.textContent = `Importing ${i + 1}/${
                                imageFiles.length
                            }: ${imageName}`;

                        try {
                            const imageDataBlob = await imageEntry.async(
                                "blob"
                            );
                            const blobUrl = URL.createObjectURL(imageDataBlob);
                            const imageFileObject = new File(
                                [imageDataBlob],
                                imageName,
                                { type: imageDataBlob.type }
                            );

                            const newEntryElement =
                                document.createElement("dataset-entry");
                            newEntryElement.setImage(blobUrl, imageFileObject);

                            const imageBaseName = imageName
                                .substring(0, imageName.lastIndexOf("."))
                                .toLowerCase();
                            if (textFiles[imageBaseName]) {
                                const tagsString = await textFiles[
                                    imageBaseName
                                ];
                                const tagsArray = parseRawTagInput(tagsString);
                                newEntryElement.setTags(tagsArray);
                            }

                            if (mainContentAreaElement) {
                                let referenceNode = dropHint?.isConnected
                                    ? dropHint
                                    : null;
                                if (
                                    referenceNode &&
                                    referenceNode.parentElement ===
                                        mainContentAreaElement
                                ) {
                                    mainContentAreaElement.insertBefore(
                                        newEntryElement,
                                        referenceNode
                                    );
                                } else {
                                    mainContentAreaElement.appendChild(
                                        newEntryElement
                                    );
                                }
                                importedCount++;
                            } else {
                                console.error(
                                    "mainContentAreaElement not found, cannot add imported entry."
                                );
                                errorCount++;
                            }
                        } catch (err) {
                            console.error(
                                `Error processing image ${imageName} from ZIP:`,
                                err
                            );
                            errorCount++;
                        }
                    }

                    document.querySelector(".modal-overlay")?.remove();
                    let resultMessage = `Dataset import complete. ${importedCount} entries added.`;
                    if (errorCount > 0) {
                        resultMessage += ` ${errorCount} error(s) occurred.`;
                    }
                    showConfirmationModal(resultMessage, [{ text: "OK" }]);
                    showMainAppUI();
                    checkDropHintVisibility();
                } catch (error) {
                    console.error("Error importing dataset from ZIP:", error);
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        `Error importing dataset: ${error.message}. Check console for details.`,
                        [{ text: "OK" }]
                    );
                }
            }

            function confirmAndExportDataset() {
                if (!mainContentAreaElement || !searchInput) {
                    showConfirmationModal(
                        "Cannot export: UI elements missing.",
                        [{ text: "OK" }]
                    );
                    return;
                }

                const entries =
                    mainContentAreaElement.querySelectorAll("dataset-entry");
                const searchIsActive = searchInput.value.trim() !== "";
                const entriesToCheck = searchIsActive
                    ? Array.from(entries).filter(
                          (entry) => entry.style.display !== "none"
                      )
                    : Array.from(entries);

                if (entriesToCheck.length === 0) {
                    if (searchIsActive && entries.length > 0) {
                        showConfirmationModal(
                            "No entries match the current filter. Export all entries instead?",
                            [
                                {
                                    text: "Export All (" + entries.length + ")",
                                    onClick: () =>
                                        exportDataset(Array.from(entries)),
                                    class: "modal-button-confirm",
                                },
                                {
                                    text: "Cancel",
                                    onClick: () => {},
                                    class: "modal-button-cancel",
                                },
                            ]
                        );
                    } else {
                        showConfirmationModal(
                            "Dataset is empty. Nothing to export.",
                            [{ text: "OK" }]
                        );
                    }
                    return;
                }

                let requirementsMet = true;
                let failingEntriesCount = 0;
                for (const entry of entriesToCheck) {
                    if (!entry.checkGroupRequirements()) {
                        requirementsMet = false;
                        failingEntriesCount++;
                    }
                }

                const exportTargetDescription = searchIsActive
                    ? "filtered"
                    : "all";
                const countDescription = `${
                    entriesToCheck.length
                } ${exportTargetDescription} entr${
                    entriesToCheck.length === 1 ? "y" : "ies"
                }`;

                if (requirementsMet) {
                    exportDataset(
                        entriesToCheck,
                        `Exporting ${countDescription}...`
                    );
                } else {
                    showConfirmationModal(
                        `Warning: ${failingEntriesCount} of the ${countDescription} do not meet minimum tag requirements. Export anyway?`,
                        [
                            {
                                text: "Export Anyway",
                                onClick: () =>
                                    exportDataset(
                                        entriesToCheck,
                                        `Exporting ${countDescription} (with warnings)...`
                                    ),
                                class: "modal-button-confirm",
                            },
                            {
                                text: "Cancel",
                                onClick: () => {},
                                class: "modal-button-cancel",
                            },
                        ]
                    );
                }
            }

            async function exportDataset(
                entriesToExport,
                description = "Exporting dataset..."
            ) {
                if (
                    typeof JSZip === "undefined" ||
                    typeof saveAs === "undefined"
                ) {
                    showConfirmationModal(
                        "Export libraries (JSZip, FileSaver) not loaded.",
                        [{ text: "OK" }]
                    );
                    return;
                }
                if (!entriesToExport || entriesToExport.length === 0) {
                    showConfirmationModal("No entries to export.", [
                        { text: "OK" },
                    ]);
                    return;
                }

                const zip = new JSZip();
                const folder = zip.folder("lora_dataset");
                let count = 0,
                    errors = 0;
                console.log(description);

                const exportMenuItem = document.querySelector(
                    'menu-item[data-action="export"]'
                );
                let originalMenuText = "Export Dataset (ZIP)";
                if (exportMenuItem) {
                    originalMenuText = exportMenuItem.textContent;
                    exportMenuItem.textContent = "Exporting...";
                    exportMenuItem.style.pointerEvents = "none";
                } else {
                    showConfirmationModal("Exporting dataset...", []);
                }

                const names = new Set();
                for (const entry of entriesToExport) {
                    count++;
                    const imgElement = entry.querySelector("img");
                    const baseNameSource =
                        entry.originalImageName || imgElement?.alt || "";

                    let baseName = baseNameSource.includes(".")
                        ? baseNameSource.substring(
                              0,
                              baseNameSource.lastIndexOf(".")
                          )
                        : baseNameSource;
                    baseName =
                        baseName || `image_${String(count).padStart(4, "0")}`;
                    baseName = sanitizeFilename(baseName);

                    const imageData = await entry.getImageData();
                    if (!imageData) {
                        console.warn(
                            `Skipping entry ${count} (${baseNameSource}): Failed to get image data.`
                        );
                        errors++;
                        continue;
                    }

                    let extension = "png";
                    if (imageData.type) {
                        const mimeType = imageData.type.split("/")[1];
                        if (mimeType === "jpeg") extension = "jpg";
                        else if (
                            ["png", "webp", "gif", "bmp", "tiff"].includes(
                                mimeType
                            )
                        )
                            extension = mimeType;
                    } else if (
                        entry.originalImageName &&
                        entry.originalImageName.includes(".")
                    ) {
                        let origExt = entry.originalImageName
                            .substring(
                                entry.originalImageName.lastIndexOf(".") + 1
                            )
                            .toLowerCase();
                        if (
                            [
                                "png",
                                "jpg",
                                "jpeg",
                                "webp",
                                "gif",
                                "bmp",
                                "tiff",
                            ].includes(origExt)
                        ) {
                            extension = origExt === "jpeg" ? "jpg" : origExt;
                        }
                    }
                    extension = extension.startsWith(".")
                        ? extension.substring(1)
                        : extension;

                    let uniqueFullName = `${baseName}.${extension}`;
                    let nameCounter = 1;
                    while (names.has(uniqueFullName.toLowerCase())) {
                        const tempBaseName = baseName.replace(/_\d+$/, "");
                        uniqueFullName = `${tempBaseName}_${nameCounter++}.${extension}`;
                    }
                    names.add(uniqueFullName.toLowerCase());

                    const tags = entry.getTagsAsString(", ");

                    folder.file(uniqueFullName, imageData, {
                        binary: true,
                    });
                    folder.file(
                        `${uniqueFullName.substring(
                            0,
                            uniqueFullName.lastIndexOf(".")
                        )}.txt`,
                        tags
                    );
                }

                document.querySelector(".modal-overlay")?.remove();

                let exportMessage = "";
                if (entriesToExport.length === 0 && errors === 0)
                    exportMessage = "No entries were exported.";
                else if (errors > 0)
                    exportMessage = `Export finished with ${errors} error(s). ${
                        entriesToExport.length - errors
                    } entries exported successfully. Check console for details.`;
                else
                    exportMessage = `Export successful! ${entriesToExport.length} entries packaged.`;

                if (
                    entriesToExport.length > 0 &&
                    errors < entriesToExport.length
                ) {
                    try {
                        const blob = await zip.generateAsync(
                            {
                                type: "blob",
                                compression: "DEFLATE",
                                compressionOptions: { level: 6 },
                            },
                            (meta) => {
                                if (exportMenuItem)
                                    exportMenuItem.textContent = `Exporting... (${meta.percent.toFixed(
                                        0
                                    )}%)`;
                            }
                        );
                        saveAs(blob, "lora_dataset_export.zip");
                        showConfirmationModal(exportMessage, [{ text: "OK" }]);
                    } catch (err) {
                        console.error("Error generating ZIP file:", err);
                        showConfirmationModal(
                            "Error generating ZIP file. Check console.",
                            [{ text: "OK" }]
                        );
                    }
                } else {
                    showConfirmationModal(exportMessage, [{ text: "OK" }]);
                }

                if (exportMenuItem) {
                    exportMenuItem.textContent = originalMenuText;
                    exportMenuItem.style.pointerEvents = "auto";
                }
            }
        </script>
    </body>
</html>
