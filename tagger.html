<!DOCTYPE html>
<html lang="en">
    <head>
        <title>opentagger</title>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="theme-color" content="#f0f0f0" />
        <link
            rel="icon"
            href="/assets/images/favicon.ico"
            type="image/x-icon"
        />

        <!-- third-party imports -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css"
        />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/neat.min.css"
        />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css"
        />
        <link
            href="https://fonts.googleapis.com/icon?family=Material+Icons"
            rel="stylesheet"
        />

        <!-- opengraph metadata -->
        <meta property="og:title" content="opentagger" />
        <meta
            property="og:description"
            content="The easiest way to tag your images."
        />
        <meta property="og:image" content="/assets/images/opentagger.png" />
        <meta property="og:url" content="https://opentagger.org" />
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="opentagger" />
        <meta property="og:locale" content="en_US" />
        <meta property="og:locale:alternate" content="en_GB" />
        <meta property="og:locale:alternate" content="en_CA" />
        <meta property="og:locale:alternate" content="en_AU" />

        <!-- twitter metadata -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="opentagger" />
        <meta
            name="twitter:description"
            content="The easiest way to tag your images."
        />
        <meta name="twitter:image" content="/assets/images/opentagger.png" />

        <style>
            :root {
                --menu-bar-height: 28px;
                --splash-ide-bg: #f3f3f3;
                --splash-ide-content-bg: #fcfcfc;
                --splash-ide-text-primary: #222222;
                --splash-ide-text-secondary: #555555;
                --splash-ide-accent: #007acc;
                --splash-ide-border: #dcdcdc;
                --splash-ide-hover-bg: rgba(0, 122, 204, 0.08);
            }

            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji",
                    "Segoe UI Emoji", "Segoe UI Symbol";
                display: flex;
                flex-direction: column;
                height: 100vh;
                overflow: hidden;
                background-color: #f0f0f0;
                color: #333;
            }

            #menu-bar {
                background-color: #e0e0e0;
                padding: 2px 5px;
                border-bottom: 1px solid #ccc;
                flex-shrink: 0;
                height: var(--menu-bar-height);
                display: flex;
                align-items: center;
            }

            #menu-bar button {
                background: none;
                border: none;
                padding: 4px 8px;
                cursor: pointer;
                font-size: 0.85em;
            }

            #menu-bar button:hover {
                background-color: #d0d0d0;
            }

            #app {
                /* This now targets the tab-container */
                display: flex; /* Provided by tab-container's :host style if more specific */
                flex-grow: 1;
                overflow: hidden;
                height: calc(100vh - var(--menu-bar-height));
            }

            /* These rules are no longer needed as sidebar/main-view are inside a tab panel */
            /*
            #app > .sidebar,
            #app > .main-view {
                display: none;
            }

            #app.loaded > .sidebar,
            #app.loaded > .main-view {
                display: flex;
            }
            */

            #tagging-panel {
                /* display: flex; */ /* Removed - This is now controlled by the tab-container component */
                flex-direction: row;
                flex-grow: 1;
                overflow: hidden;
                height: 100%; /* Ensure it fills the tab panel area */
            }

            #preferences-panel {
                padding: 20px;
                overflow-y: auto;
                height: 100%; /* Ensure it fills and can scroll */
            }

            .preferences-section {
                margin-bottom: 25px;
                padding: 15px;
                border: 1px solid #e0e0e0;
                border-radius: 5px;
                background-color: #f9f9f9;
            }

            .preferences-section h3,
            .preferences-section h4 {
                margin-top: 0;
                margin-bottom: 15px;
                font-size: 1.2em;
                color: #333;
                border-bottom: 1px solid #ddd;
                padding-bottom: 8px;
            }
            .preferences-section h4 {
                /* For nested sections */
                font-size: 1.1em;
                color: #444;
            }

            .preference-item {
                display: flex;
                align-items: center;
                margin-bottom: 12px;
                gap: 10px;
            }

            .preference-item label {
                flex-basis: 220px; /* Adjust as needed */
                flex-shrink: 0;
                font-size: 0.95em;
                color: #555;
                word-wrap: break-word;
            }

            .preference-item input[type="number"],
            .preference-item input[type="text"],
            .preference-item select {
                flex-grow: 1;
                padding: 6px 8px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 0.9em;
                min-width: 100px; /* Ensure inputs have some minimum width */
            }
            .preference-item input[type="checkbox"] {
                margin-left: 5px;
                height: 16px;
                width: 16px;
                flex-shrink: 0;
            }

            .preferences-section .preferences-section {
                /* Nested sections */
                margin-left: 0; /* Let padding handle indentation */
                margin-top: 20px;
                padding: 15px;
                background-color: #fff;
                border: 1px solid #d5d5d5;
            }

            #splash-screen {
                position: fixed;
                top: var(--menu-bar-height);
                left: 0;
                right: 0;
                bottom: 0;
                background-color: var(--splash-ide-bg);
                z-index: 500;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                transition: opacity 0.4s ease-out, visibility 0.4s ease-out;
            }

            #splash-screen.hidden {
                opacity: 0;
                visibility: hidden;
                pointer-events: none;
            }

            .splash-ide-container {
                width: 90vw;
                max-width: 1050px;
                height: auto;
                max-height: calc(100vh - var(--menu-bar-height) - 40px);
                background-color: var(--splash-ide-content-bg);
                border: 1px solid var(--splash-ide-border);
                border-radius: 6px;
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .splash-ide-header {
                padding: 25px 35px 15px 35px;
                border-bottom: 1px solid var(--splash-ide-border);
            }
            .splash-ide-header h1 {
                font-size: 2em;
                font-weight: 600;
                color: var(--splash-ide-text-primary);
                margin-bottom: 2px;
            }
            .splash-ide-header p {
                font-size: 0.95em;
                color: var(--splash-ide-text-secondary);
            }

            .splash-ide-content-area {
                display: flex;
                flex-grow: 1;
                padding: 25px 35px;
                gap: 35px;
                overflow-y: auto;
            }

            .splash-ide-column {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 25px;
                min-width: 0;
            }
            .splash-ide-column:first-child {
                flex-basis: 55%;
            }
            .splash-ide-column:last-child {
                flex-basis: 45%;
            }

            .splash-ide-section h2 {
                font-size: 1.05em;
                font-weight: 500;
                color: var(--splash-ide-text-secondary);
                margin-bottom: 12px;
            }

            .splash-ide-list {
                list-style: none;
                padding: 0;
                margin: 0;
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .splash-ide-list li button,
            .splash-ide-list li a.splash-ide-info-item,
            .splash-ide-list li div.splash-ide-info-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 10px;
                border-radius: 4px;
                background: none;
                border: none;
                text-align: left;
                cursor: pointer;
                width: 100%;
                color: var(--splash-ide-text-primary);
                font-size: 0.9em;
                transition: background-color 0.15s ease-in-out;
                text-decoration: none;
            }
            .splash-ide-list li button:hover,
            .splash-ide-list li a.splash-ide-info-item:hover {
                background-color: var(--splash-ide-hover-bg);
                color: var(--splash-ide-accent);
            }
            .splash-ide-list li button:hover .material-icons,
            .splash-ide-list li a.splash-ide-info-item:hover .material-icons {
                color: var(--splash-ide-accent);
            }

            .splash-ide-list li button .material-icons,
            .splash-ide-list li .splash-ide-info-item .material-icons {
                color: var(--splash-ide-accent);
                font-size: 22px;
                flex-shrink: 0;
            }
            .splash-ide-list li button span:last-of-type,
            .splash-ide-list li .splash-ide-info-item div {
                flex-grow: 1;
                line-height: 1.4;
            }

            .splash-ide-info-item div h4 {
                margin: 0 0 2px 0;
                font-size: 0.9em;
                font-weight: 500;
                color: var(--splash-ide-text-primary);
            }
            .splash-ide-info-item div p {
                margin: 0;
                font-size: 0.82em;
                color: var(--splash-ide-text-secondary);
                line-height: 1.45;
            }

            .splash-ide-list.large-icons
                li
                .splash-ide-info-item
                .material-icons {
                font-size: 26px;
                background-color: var(--splash-ide-hover-bg);
                padding: 6px;
                border-radius: 4px;
                margin-right: 4px;
            }
            .splash-ide-list.large-icons
                li
                a.splash-ide-info-item:hover
                .material-icons,
            .splash-ide-list.large-icons
                li
                div.splash-ide-info-item
                .material-icons {
                color: var(--splash-ide-accent);
            }

            .splash-ide-list-placeholder {
                display: flex !important;
                align-items: center;
                gap: 10px;
                padding: 12px 10px !important;
                color: #777;
                font-size: 0.85em !important;
                border: 1px dashed #ddd;
                border-radius: 4px;
                background-color: transparent;
                cursor: default !important;
            }
            .splash-ide-list-placeholder:hover {
                background-color: transparent !important;
            }
            .splash-ide-list-placeholder .material-icons {
                color: #777 !important;
                font-size: 20px !important;
            }

            .splash-anim {
                opacity: 0;
                transform: translateY(15px);
                animation: splash-item-fade-in 0.5s
                    cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            }

            @keyframes splash-item-fade-in {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .sidebar {
                min-width: 250px;
                width: 20svw;
                background-color: #f8f8f8;
                border-right: 1px solid #ccc;
                padding: 15px;
                display: flex;
                flex-direction: column;
                overflow-y: auto;
                flex-shrink: 0;
            }

            .sidebar h2 {
                margin-bottom: 15px;
                font-size: 1.1em;
                color: #555;
                border-bottom: 1px solid #eee;
                padding-bottom: 5px;
            }

            #tag-group-list {
                flex-grow: 1;
                margin-bottom: 10px;
            }

            #btn-add-group {
                padding: 8px;
                background-color: #5c85d6;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                margin-top: auto;
            }
            #btn-add-group:hover {
                background-color: #4a6aaa;
            }

            .main-view {
                flex-grow: 1;
                background-color: #fff;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .main-view-header {
                display: flex;
                align-items: center;

                gap: 10px;
                padding: 15px 15px 10px 15px;
                flex-shrink: 0;
                border-bottom: 1px solid #eee;
            }
            .main-view-header h2 {
                margin-bottom: 0;
                flex-shrink: 0;
                font-size: 1.1em;
                color: #555;
            }

            #main-content-area {
                flex-grow: 1;
                overflow-y: auto;
                padding: 15px;
                position: relative;
            }

            #main-content-area .drop-hint {
                text-align: center;
                color: #aaa;
                padding: 40px;
                border: 2px dashed #ddd;
                border-radius: 5px;
                margin-bottom: 20px;
            }

            #main-content-area .drop-hint.no-results {
                border-style: solid;
                color: #888;
            }
            #main-content-area .drop-hint.no-results::before {
                content: "No entries match your search.";
                display: block;
                font-weight: bold;
                margin-bottom: 10px;
            }

            #autotag-all-button {
                background: none;
                border: none;
                border-radius: 8px;
                padding: 5px;
                cursor: pointer;
                font-family: "Material Icons";
                font-size: 20px;
                color: #666;
                line-height: 1;
                transition: background-color 0.2s, color 0.2s, border-color 0.2s;
                width: 28px;
                background: none !important;
            }

            #autotag-all-button:hover:not(:disabled) {
                background-color: #e0e0e0;
                border-color: #bbb;
                color: #333;
            }
            #autotag-all-button.loading {
                color: #5c5cff;
                animation: spin 1s linear infinite;
                cursor: default;
                background: none;
            }
            #autotag-all-button:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                background-color: #f0f0f0;
            }

            #search-bar {
                padding: 6px 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 0.9em;
                min-width: 200px;
                max-width: 400px;
                flex-grow: 1;
                margin-left: auto;
            }

            #search-bar:focus {
                outline: none;
                border-color: #5c85d6;
                box-shadow: 0 0 0 2px rgba(92, 133, 214, 0.2);
            }

            dataset-tag {
                display: inline-flex;
                align-items: center;
                background-color: #e7f0ff;
                border: 1px solid #b3d1ff;
                border-radius: 12px;
                padding: 3px 8px 3px 10px;
                margin: 3px;
                font-size: 0.9em;
                cursor: grab;
                user-select: none;
                transition: background-color 0.2s ease;
                min-width: 50px;
                position: relative; /* For autocomplete positioning context */
            }

            dataset-tag:active {
                cursor: grabbing;
            }

            dataset-tag span[contenteditable] {
                outline: none;
                flex-grow: 1;
                min-width: 10px;
                padding-right: 5px;
            }
            dataset-tag span[contenteditable]:focus {
                background-color: #fff;
                box-shadow: 0 0 0 1px #b3d1ff;
            }

            dataset-tag .delete-tag {
                font-family: "Material Icons";
                font-size: 16px;
                cursor: pointer;
                color: #aaa;
                margin-left: 5px;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 2px;
                border-radius: 50%;
                border-color: #b3d1ff;
                line-height: 1;
            }

            dataset-tag .delete-tag:hover {
                color: #ff4d4d;
                background-color: #ffe0e0;
            }

            dataset-entry img,
            dataset-entry span:not([contenteditable]),
            dataset-entry button {
                user-select: none;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-button {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                margin: 3px;
                border: 1px dashed #ccc;
                border-radius: 12px;
                cursor: pointer;
                color: #777;
                min-width: 26px;
                width: 26px;
                height: 26px;
                box-sizing: border-box;
                background-color: #f9f9f9;
                transition: all 0.2s ease;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-button:hover {
                border-color: #5c85d6;
                color: #5c85d6;
                background-color: #e7f0ff;
            }

            dataset-entry
                > .entry-content
                > tag-list
                > .add-tag-button
                .material-icons {
                font-size: 20px;
                line-height: 1;
            }

            dataset-entry > .entry-content > tag-list > .add-tag-input {
                outline: none;
                background-color: #fff;
                border: 1px solid #b3d1ff;
                box-shadow: 0 0 0 1px #b3d1ff;
                border-radius: 12px;
                padding: 3px 8px 3px 10px;
                margin: 3px;
                font-size: 0.9em;
                min-width: 70px;
                height: 28px;
                box-sizing: border-box;
                line-height: normal;
                vertical-align: middle;
            }

            tag-list {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                padding: 5px;
                min-height: 30px;
                border-radius: 4px;
                transition: background-color 0.2s ease;
            }

            tag-list[direction="column"] {
                flex-direction: column;
                align-items: flex-start;
                flex-wrap: nowrap;
            }

            tag-list[direction="row"] {
                flex-direction: row;
                align-items: center;
            }

            .drag-over {
                background-color: #e0ffe0 !important;
                border: 1px dashed #8fbc8f;
            }
            dataset-tag.dragging {
                opacity: 0.5;
            }

            dataset-tag.searched-highlight {
                border: 2px solid var(--highlight-border-color, #ff0000);
                padding: 2px 7px 2px 9px;
            }

            dataset-entry {
                display: flex;
                flex-direction: column;
                border: 1px solid #ddd;
                border-radius: 5px;
                margin-bottom: 15px;
                padding: 10px;
                background-color: #fdfdfd;
                transition: box-shadow 0.2s ease, border-color 0.3s ease;
                position: relative;
                cursor: default; /* For selection clicks */
            }

            dataset-entry.requirement-not-met {
                border-color: #ff7b7b;
                box-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
            }

            dataset-entry[selected] {
                border-color: #5c85d6;
                background-color: #e7f0ff;
                box-shadow: 0 0 8px rgba(92, 133, 214, 0.5);
            }

            dataset-entry[selected]::before {
                content: "check_circle";
                font-family: "Material Icons";
                position: absolute;
                top: 8px;
                left: 8px;
                font-size: 22px;
                color: #4a6aaa;
                background-color: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                padding: 2px;
                z-index: 2;
                pointer-events: none;
            }

            dataset-entry[selected].requirement-not-met::after {
            }

            #developer-console {
                background-color: #f7f7f7;
                color: #333;
                border-top: 1px solid #ccc;
                display: flex;
                flex-direction: column;
                z-index: 50;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease-in-out;
                flex-shrink: 0;
            }

            #developer-console.visible {
            }

            #console-output {
                flex-grow: 1;
                padding: 8px;
                overflow-y: auto;
                font-family: "Consolas", "Monaco", monospace;
                font-size: 0.85em;
                line-height: 1.5;
                min-height: 2em;
            }

            #console-output .console-message {
                padding: 3px 5px;
                border-bottom: 1px solid #e8e8e8;
                word-break: break-all;
            }
            #console-output .console-message:nth-child(even) {
                background-color: #efefef;
            }
            #console-output .console-message:last-child {
                border-bottom: none;
            }

            #console-output .console-message.command {
                color: #005cbb;
                font-weight: bold;
            }
            #console-output .console-message.error {
                color: #c00;
            }
            #console-output .console-message.success {
                color: #007700;
            }
            #console-output .console-message.info {
                color: #555;
            }
            #console-output .console-message pre {
                white-space: pre-wrap;
                word-wrap: break-word; /* Use word-wrap for older browsers */
                overflow-wrap: break-word; /* Use overflow-wrap for modern browsers */
                margin: 0;
                font-family: inherit;
            }

            .CodeMirror {
                border-top: 1px solid #ccc;
                font-family: "Consolas", "Monaco", monospace;
                font-size: 0.9em;
                height: auto;
                min-height: 2.5em;
                max-height: 15em;
            }
            .CodeMirror-scroll {
                min-height: 2.5em;
            }
            .CodeMirror-hints {
                position: absolute;
                background: #fff;
                border: 1px solid #ddd;
                box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
                z-index: 101; /* Ensure it's above CodeMirror itself */
                max-height: 10em;
                overflow-y: auto;
            }
            .CodeMirror-hint {
                color: #333;
                padding: 2px 5px;
            }
            li.CodeMirror-hint-active {
                background: #e7f0ff;
                color: #005cbb;
            }

            autocomplete-dropdown {
                position: absolute;
                background-color: #fff;
                border: 1px solid #ccc;
                box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15);
                padding: 3px 0;
                min-width: 150px;
                z-index: 2500;
                display: none;
                flex-direction: column;
                max-height: 200px;
                overflow-y: auto;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, Helvetica, Arial, sans-serif;
                font-size: 0.9em;
            }

            autocomplete-dropdown.visible {
                display: flex;
            }

            autocomplete-dropdown div.suggestion-item {
                padding: 5px 10px;
                cursor: pointer;
                white-space: nowrap;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            autocomplete-dropdown div.suggestion-item:hover,
            autocomplete-dropdown div.suggestion-item.selected {
                background-color: #e7f0ff;
                color: #005cbb;
            }
            autocomplete-dropdown div.suggestion-item.selected .tag-count {
                color: #005cbb; /* Match text color */
            }

            autocomplete-dropdown div.suggestion-item .tag-name {
                font-weight: normal; /* Default, can be overridden */
            }
            autocomplete-dropdown div.suggestion-item.selected .tag-name {
                font-weight: bold;
            }

            autocomplete-dropdown div.suggestion-item .tag-count {
                font-size: 0.85em;
                color: #777;
                margin-left: 8px;
            }

            dataset-entry.requirement-not-met::after {
                content: "warning";
                font-family: "Material Icons";
                position: absolute;
                top: 5px;

                right: 76px;
                color: #ff4d4d;
                font-size: 20px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                padding: 4px;
                pointer-events: none;
                z-index: 2;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 28px;
                height: 28px;
            }

            dataset-entry:hover {
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            }

            dataset-entry .entry-content {
                display: flex;
                flex-direction: row;
                gap: 10px;
                align-items: flex-start;
            }

            dataset-entry img {
                max-width: 150px;
                max-height: 150px;
                height: auto;
                object-fit: contain;
                border-radius: 3px;
                flex-shrink: 0;
                cursor: pointer;
            }

            dataset-entry tag-list {
                flex-grow: 1;
                border: 1px solid #eee;
                align-self: stretch;
            }

            dataset-entry .entry-buttons {
                position: absolute;
                top: 5px;
                right: 38px;
                display: flex;
                align-items: center;
                gap: 5px;
                z-index: 1;
            }

            dataset-entry .autotag-entry {
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #aaa;
                font-family: "Material Icons";
                font-size: 20px;
                padding: 4px;
                width: 28px;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                transition: background-color 0.2s, color 0.2s;
            }

            dataset-entry .delete-entry {
                position: absolute;
                top: 5px;
                right: 5px;
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #aaa;
                font-family: "Material Icons";
                font-size: 20px;
                padding: 4px;
                width: 28px;
                height: 28px;
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 1;
                z-index: 1;
                transition: background-color 0.2s, color 0.2s;
            }

            dataset-entry .delete-entry:hover {
                background-color: #ffe0e0;
                color: #ff4d4d;
            }

            dataset-entry .autotag-entry:hover:not(:disabled) {
                background-color: #e0e0ff;
                color: #5c5cff;
            }
            dataset-entry .autotag-entry.loading {
                color: #5c5cff;
                animation: spin 1s linear infinite;
            }
            dataset-entry .autotag-entry.loading:hover {
                background-color: rgba(255, 255, 255, 0.7);
            }
            dataset-entry .autotag-entry:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                background-color: rgba(230, 230, 230, 0.7);
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            tag-group {
                display: block;
                margin-bottom: 15px;
                border: 1px solid #e0e0e0;
                padding: 10px;
                border-radius: 4px;
                background-color: #fff;
                position: relative;
            }

            tag-group .group-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
                cursor: default;
                gap: 5px;
            }

            tag-group .group-name {
                font-weight: bold;
                color: #666;
                padding: 3px 5px;
                border-radius: 3px;
                cursor: text;
                outline: none;
                flex-grow: 1;
                min-width: 50px;
                margin-right: 5px;
            }
            tag-group .group-name:hover {
                background-color: #f0f0f0;
            }
            tag-group .group-name:focus {
                background-color: #e7f0ff;
                box-shadow: 0 0 0 1px #b3d1ff;
            }

            tag-group .min-tags-control {
                display: flex;
                align-items: center;
                gap: 3px;
                color: #777;
                font-size: 0.85em;
                margin-left: auto;
                flex-shrink: 0;
            }
            tag-group .min-tags-control button {
                font-family: "Material Icons";
                font-size: 18px;
                cursor: pointer;
                color: #999;
                padding: 0;
                border: none;
                background: none;
                line-height: 1;
                width: 18px;
                height: 18px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                border-radius: 3px;
            }
            tag-group .min-tags-control button:hover {
                background-color: #eee;
                color: #333;
            }
            tag-group .min-tags-value {
                min-width: 15px;
                text-align: center;
                font-weight: bold;
            }

            tag-group .btn-new-tag {
                font-family: "Material Icons";
                font-size: 20px;
                cursor: pointer;
                color: #5c85d6;
                padding: 2px;
                border-radius: 50%;
                background: none;
                border: none;
                flex-shrink: 0;
            }

            tag-group .btn-new-tag:hover {
                background-color: #e7f0ff;
                color: #4a6aaa;
            }

            tag-group tag-list {
                min-height: 40px;
                padding-bottom: 10px;
                position: relative;
            }

            context-menu {
                position: absolute;
                background-color: #fff;
                border: 1px solid #ccc;
                box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15);
                padding: 3px 0;
                min-width: 150px;
                z-index: 1000;
                display: none;
                flex-direction: column;
            }

            context-menu.visible {
                display: flex;
            }

            menu-item {
                display: flex;
                align-items: center;
                padding: 5px 12px;
                cursor: pointer;
                font-size: 0.85em;
                white-space: nowrap;
                position: relative;
            }

            menu-item:hover {
                background-color: #e7f0ff;
            }

            menu-item.disabled {
                opacity: 0.5;
                pointer-events: none;
                cursor: default;
            }

            menu-item .submenu-arrow {
                margin-left: auto;
                font-size: 14px;
                color: #777;
            }
            menu-item context-menu {
                top: -6px;
                left: 100%;
                margin-left: -5px;
                display: none;
            }

            menu-item:hover > context-menu {
                display: flex;
            }

            context-menu hr {
                border: none;
                border-top: 1px solid #eee;
                margin: 3px 5px;
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 2000;
            }

            .modal-content {
                background-color: #fff;
                padding: 25px 30px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 450px;
                width: 90%;
                text-align: center;
            }

            .modal-message {
                margin-bottom: 20px;
                font-size: 1.1em;
                line-height: 1.5;
                color: #444;
                white-space: pre-wrap;
            }

            .modal-buttons {
                display: flex;
                justify-content: center;
                gap: 15px;
            }

            .modal-buttons button {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 1em;
                min-width: 80px;
                transition: background-color 0.2s ease;
            }

            .modal-buttons .modal-button-confirm {
                background-color: #5c85d6;
                color: white;
            }
            .modal-buttons .modal-button-confirm:hover {
                background-color: #4a6aaa;
            }

            .modal-buttons .modal-button-cancel {
                background-color: #ccc;
                color: #333;
            }
            .modal-buttons .modal-button-cancel:hover {
                background-color: #bbb;
            }

            .modal-buttons .modal-button-default {
                background-color: #e0e0e0;
                color: #333;
            }
            .modal-buttons .modal-button-default:hover {
                background-color: #d0d0d0;
            }

            .image-preview-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.65);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1500;
                padding: 2vh;
            }

            .image-preview-content {
                position: relative;
                background-color: #fff;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                max-width: 90vw;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }
            .image-preview-content img {
                display: block;
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
                margin-bottom: 15px;
                flex-shrink: 1;
                flex-grow: 1;
                min-height: 50px;
            }

            .image-preview-info {
                flex-shrink: 0;
                text-align: center;
                margin-top: auto;
                font-size: 0.95em;
                color: #333;
                line-height: 1.4;
            }
            .image-preview-info strong {
                word-break: break-all;
            }

            .image-preview-close {
                position: absolute;
                top: 5px;
                right: 5px;
                font-size: 24px;
                background: rgba(255, 255, 255, 0.7);
                border: none;
                border-radius: 50%;
                cursor: pointer;
                color: #555;
                padding: 3px;
                z-index: 1501;
                line-height: 1;
            }
            .image-preview-close:hover {
                color: #000;
                background: rgba(255, 255, 255, 0.9);
            }

            .autotag-timer-label {
                display: inline-block;
                background-color: #e9e9e9;
                border: 1px solid #dcdcdc;
                border-radius: 10px;
                padding: 2px 7px;
                margin-left: 6px;
                font-size: 0.8em;
                color: #555;
                line-height: 1.2;
                vertical-align: middle;
                opacity: 1;
                transition: opacity 0.5s ease-out 1.5s;
            }

            .autotag-timer-label.fade-out {
                opacity: 0;
            }
        </style>
    </head>
    <body>
        <audio id="sfxWelcome" src="assets/audio/jingle.ogg"></audio>
        <audio id="sfxGood1" src="assets/audio/sweet.ogg"></audio>
        <audio id="sfxGood2" src="assets/audio/sweet2.ogg"></audio>
        <audio id="sfxGood3" src="assets/audio/sweet3.ogg"></audio>
        <audio id="sfxBad" src="assets/audio/uhoh.ogg"></audio>
        <audio id="sfxGoodnight" src="assets/audio/goodnight.ogg"></audio>
        <audio id="sfxPop" src="assets/audio/pop.ogg"></audio>

        <nav id="menu-bar">
            <button>File</button>
            <button>Edit</button>
            <button>Select</button>
            <!-- Selection-related actions -->
            <button>View</button>
            <button>Help</button>
        </nav>

        <div id="splash-screen">
            <div
                class="splash-ide-container splash-anim"
                style="animation-delay: 0s"
            >
                <div
                    class="splash-ide-header splash-anim"
                    style="animation-delay: 0.05s"
                >
                    <h1>opentagger</h1>
                    <p>Really simple image tagging</p>
                </div>

                <div
                    class="splash-ide-content-area splash-anim"
                    style="animation-delay: 0.1s"
                >
                    <div class="splash-ide-column">
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.15s"
                        >
                            <h2>Start</h2>
                            <ul class="splash-ide-list">
                                <li>
                                    <button id="splash-new-project">
                                        <span class="material-icons"
                                            >add_box</span
                                        >
                                        <span>New Project...</span>
                                    </button>
                                </li>
                                <li>
                                    <button id="splash-open-project">
                                        <span class="material-icons"
                                            >folder_open</span
                                        >
                                        <span>Open Project...</span>
                                    </button>
                                </li>
                            </ul>
                        </div>
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.2s"
                        >
                            <h2>Recent</h2>
                            <ul
                                class="splash-ide-list"
                                id="splash-recent-projects-list"
                            >
                                <li class="splash-ide-list-placeholder">
                                    <span class="material-icons">history</span>
                                    <span
                                        >No recent projects to show. Feature
                                        coming soon™</span
                                    >
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div class="splash-ide-column">
                        <div
                            class="splash-ide-section splash-anim"
                            style="animation-delay: 0.25s"
                        >
                            <h2>Learn & Discover</h2>
                            <ul class="splash-ide-list large-icons">
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >school</span
                                        >
                                        <div>
                                            <h4>Getting Started Guide</h4>
                                            <p>
                                                Need pointers on how to get
                                                started? Click here for a quick
                                                guide!
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >auto_fix_high</span
                                        >
                                        <div>
                                            <h4>Autotagging</h4>
                                            <p>
                                                Automatically tag your images
                                                with a local AI model.
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <a href="#" class="splash-ide-info-item">
                                        <span class="material-icons"
                                            >integration_instructions</span
                                        >
                                        <div>
                                            <h4>Advanced Scripting</h4>
                                            <p>
                                                Unlock powerful features with
                                                the console and slash commands.
                                            </p>
                                        </div>
                                    </a>
                                </li>
                                <li>
                                    <div
                                        class="splash-ide-info-item whats-new-item"
                                    >
                                        <span class="material-icons"
                                            >campaign</span
                                        >
                                        <div>
                                            <h4>What's New in v0.1.0</h4>
                                            <p>
                                                Initial release: Core tagging,
                                                project management, developer
                                                console, and autotagging
                                                features.
                                            </p>
                                        </div>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <tab-container id="app" active-tab="tagging">
            <div tab="tagging" tab-label="Tagging" id="tagging-panel">
                <aside class="sidebar">
                    <h2>Tag Groups</h2>
                    <div id="tag-group-list">
                        <tag-group group-name="General">
                            <dataset-tag>1girl</dataset-tag>
                            <dataset-tag>1boy</dataset-tag>
                            <dataset-tag>solo</dataset-tag>
                            <dataset-tag>multiple boys</dataset-tag>
                            <dataset-tag>multiple girls</dataset-tag>
                        </tag-group>
                        <tag-group group-name="Angle">
                            <dataset-tag>from below</dataset-tag>
                            <dataset-tag>from above</dataset-tag>
                            <dataset-tag>from behind</dataset-tag>
                            <dataset-tag>from side</dataset-tag>
                            <dataset-tag>straight-on</dataset-tag>
                            <dataset-tag>three quarter view</dataset-tag>
                        </tag-group>
                        <tag-group group-name="Composition">
                            <dataset-tag>close-up</dataset-tag>
                            <dataset-tag>portrait</dataset-tag>
                            <dataset-tag>upper body</dataset-tag>
                            <dataset-tag>cowboy shot</dataset-tag>
                            <dataset-tag>full body</dataset-tag>
                            <dataset-tag>wide shot</dataset-tag>
                            <dataset-tag>very wide shot</dataset-tag>
                        </tag-group>
                        <tag-group group-name="Background">
                            <dataset-tag>simple background</dataset-tag>
                            <dataset-tag>indoors</dataset-tag>
                            <dataset-tag>outdoors</dataset-tag>
                            <dataset-tag>city</dataset-tag>
                            <dataset-tag>nature</dataset-tag>
                        </tag-group>
                        <tag-group group-name="Style">
                            <dataset-tag>anime coloring</dataset-tag>
                            <dataset-tag>realistic</dataset-tag>
                            <dataset-tag>sketch</dataset-tag>
                            <dataset-tag>3d</dataset-tag>
                            <dataset-tag>lineart</dataset-tag>
                            <dataset-tag>comic</dataset-tag>
                            <dataset-tag>furry</dataset-tag>
                        </tag-group>
                    </div>
                    <button id="btn-add-group">Add Group</button>
                </aside>

                <main class="main-view" id="main-view">
                    <div class="main-view-header">
                        <h2>Dataset Entries</h2>
                        <button
                            id="autotag-all-button"
                            class="material-icons"
                            title="Autotag All Visible Entries"
                            speaker="Autotag All Visible Entries"
                        >
                            auto_awesome_stack
                        </button>
                        <input
                            type="search"
                            id="search-bar"
                            placeholder="Search tags (e.g., 1girl && smile || (cat && black_fur))"
                        />
                    </div>
                    <div id="main-content-area">
                        <p class="drop-hint">Drag & Drop Images Here</p>
                    </div>
                    <div id="developer-console">
                        <div id="console-output"></div>
                        <textarea
                            id="console-input"
                            placeholder="Press F1 to toggle. Type /help for commands, or JS code."
                        ></textarea>
                    </div>
                </main>
            </div>
            <div
                tab="preferences"
                tab-label="Preferences"
                id="preferences-panel"
            ></div>
        </tab-container>

        <input
            type="file"
            id="project-file-input"
            accept=".loraproj"
            style="display: none"
        />

        <input
            type="file"
            id="dataset-zip-input"
            accept=".zip"
            style="display: none"
        />

        <autocomplete-dropdown
            id="tag-autocomplete-dropdown"
            translate="no"
        ></autocomplete-dropdown>

        <!-- todo: bundle these with a build tool like webpack or something -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.0/FileSaver.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/javascript-hint.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/comment/comment.min.js"></script>
        <script defer>
            "use strict";

            /**
             * ## <tab-container>
             * A web component that provides a tabbed interface for organizing content into panels.
             */
            class HTMLTabContainerElement extends HTMLElement {
                static get observedAttributes() {
                    return ["active-tab"];
                }

                #tabBar;
                #slot;
                #observer;
                #buttonsByTabId = new Map();
                #panelsByTabId = new Map();
                #activeTabId = null; // Stores the SANITIZED ID of the active tab

                #boundHandleTabBarKeyDown;
                #boundProcessSlottedChildren;
                #boundHandleMutations;

                constructor() {
                    super();
                    this.attachShadow({ mode: "open" });
                    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: flex;
          flex-direction: column;
          border: var(--tab-container-border, 1px solid #ccc);
          border-radius: var(--tab-container-radius, 0px); /* Adjusted for seamless integration */
          overflow: hidden;
          flex-grow: 1; /* Ensure it can grow if its parent is flex */
          height: 100%; /* Often useful to fill parent height */
        }
        #tab-bar {
          display: flex;
          flex-wrap: nowrap;
          overflow-x: auto;
          background-color: var(--tab-bar-bg, #f0f0f0);
          border-bottom: var(--tab-bar-border-bottom, 1px solid #ccc);
          scrollbar-width: thin;
          scrollbar-color: var(--tab-bar-scrollbar-thumb-bg, #aaa) var(--tab-bar-scrollbar-track-bg, #f0f0f0);
          flex-shrink: 0; /* Prevent tab bar from shrinking */
        }
        #tab-bar::-webkit-scrollbar { height: 6px; }
        #tab-bar::-webkit-scrollbar-track { background: var(--tab-bar-scrollbar-track-bg, #f0f0f0); }
        #tab-bar::-webkit-scrollbar-thumb {
            background-color: var(--tab-bar-scrollbar-thumb-bg, #aaa);
            border-radius: 3px;
        }
        #tab-bar button {
          padding: var(--tab-button-padding, 8px 15px);
          border: none;
          background-color: transparent;
          cursor: pointer;
          font-size: var(--tab-button-font-size, 0.9em);
          color: var(--tab-button-color, #333);
          border-right: var(--tab-button-separator, 1px solid #ccc);
          white-space: nowrap;
          transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        #tab-bar button:last-of-type { border-right: none; }
        #tab-bar button:hover {
          background-color: var(--tab-button-bg-hover, #e0e0e0);
          color: var(--tab-button-color-hover, #000);
        }
        #tab-bar button.active {
          background-color: var(--tab-button-bg-active, #fff);
          color: var(--tab-button-color-active, #007bff);
          font-weight: bold;
          border-bottom: 2px solid var(--tab-active-indicator-color, #007bff);
          margin-bottom: -1px; /* Overlap with tab-bar border to connect indicator */
        }
        #tab-bar button:focus-visible {
          outline: 2px solid var(--tab-focus-ring-color, #007bff);
          outline-offset: -2px;
          z-index:1;
        }
        #tab-panels {
          padding: var(--tab-panels-padding, 0); /* Panels manage their own padding */
          flex-grow: 1;
          overflow: hidden; /* Let panels manage their own overflow */
          display: flex; 
          flex-direction: column;
        }
        ::slotted([role="tabpanel"]) { 
            display: none; 
            width: 100%;
            height: 100%;
            overflow: hidden; /* Default, panel can override */
            flex-grow: 1;
        }
        ::slotted([role="tabpanel"][aria-hidden="false"]) { 
            display: flex; /* Use flex for active panel */
            /* Panel itself defines its children's layout (e.g. flex-direction: row for tagging) */
        }
      </style>
      <div id="tab-bar" role="tablist" part="tab-bar"></div>
      <div id="tab-panels" part="tab-panels">
        <slot></slot>
      </div>
    `;

                    this.#tabBar = this.shadowRoot.querySelector("#tab-bar");
                    this.#slot = this.shadowRoot.querySelector("slot");

                    this.#boundHandleMutations =
                        this.#handleMutations.bind(this);
                    this.#boundHandleTabBarKeyDown =
                        this.#handleTabBarKeyDown.bind(this);
                    this.#boundProcessSlottedChildren =
                        this.#processSlottedChildren.bind(this);
                }

                connectedCallback() {
                    this.#tabBar.addEventListener(
                        "keydown",
                        this.#boundHandleTabBarKeyDown
                    );
                    this.#slot.addEventListener(
                        "slotchange",
                        this.#boundProcessSlottedChildren
                    );

                    this.#observer = new MutationObserver(
                        this.#boundHandleMutations
                    );
                    this.#observer.observe(this, {
                        childList: true,
                        attributes: true,
                        attributeOldValue: true,
                        subtree: true, // Observe subtree for attribute changes on panels
                        attributeFilter: ["tab", "tab-label", "id"], // Added 'id' to track user changes
                    });

                    this.#processSlottedChildren();
                }

                disconnectedCallback() {
                    if (this.#observer) this.#observer.disconnect();
                    this.#tabBar.removeEventListener(
                        "keydown",
                        this.#boundHandleTabBarKeyDown
                    );
                    this.#slot.removeEventListener(
                        "slotchange",
                        this.#boundProcessSlottedChildren
                    );
                }

                attributeChangedCallback(name, oldValue, newValue) {
                    if (name === "active-tab" && oldValue !== newValue) {
                        const sanitizedNewValue = newValue
                            ? this.#sanitizeId(newValue)
                            : null;
                        if (
                            sanitizedNewValue &&
                            this.#buttonsByTabId.has(sanitizedNewValue)
                        ) {
                            this.activateTab(sanitizedNewValue);
                        } else if (!sanitizedNewValue && this.#activeTabId) {
                            // If active-tab is removed or set to empty, deactivate current tab
                            // and let #ensureActiveTab pick a default if available.
                            this.activeTab = null;
                        }
                    }
                }

                #sanitizeId(id) {
                    // Sanitize the user-provided 'tab' attribute value for internal use as a key.
                    // This does not change the 'tab' attribute itself on the panel.
                    return String(id ?? "")
                        .replace(/[^a-zA-Z0-9_-]+/g, "_")
                        .replace(/^[^a-zA-Z_]+/, (match) => `_${match}`);
                }

                #handleMutations(mutationsList) {
                    let tabsStructureChanged = false;

                    for (const mutation of mutationsList) {
                        if (
                            mutation.type === "childList" &&
                            mutation.target === this
                        ) {
                            // Direct children added/removed
                            mutation.addedNodes.forEach((node) => {
                                if (
                                    node.nodeType === Node.ELEMENT_NODE &&
                                    node.hasAttribute("tab") &&
                                    node.hasAttribute("tab-label")
                                ) {
                                    this.#addTab(node);
                                    tabsStructureChanged = true;
                                }
                            });
                            mutation.removedNodes.forEach((node) => {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    const tabIdAttr = node.getAttribute("tab");
                                    if (tabIdAttr) {
                                        this.#removeTab(
                                            this.#sanitizeId(tabIdAttr)
                                        ); // Use sanitized ID for removal
                                        tabsStructureChanged = true;
                                    }
                                }
                            });
                        } else if (
                            mutation.type === "attributes" &&
                            mutation.target.parentElement === this
                        ) {
                            // Attributes changed on direct children
                            const panelElement = mutation.target;
                            const tabIdAttr = panelElement.getAttribute("tab");
                            const sanitizedCurrentTabId = tabIdAttr
                                ? this.#sanitizeId(tabIdAttr)
                                : null;

                            if (mutation.attributeName === "tab") {
                                const oldTabIdAttr = mutation.oldValue;
                                if (oldTabIdAttr)
                                    this.#removeTab(
                                        this.#sanitizeId(oldTabIdAttr)
                                    );
                                if (panelElement.hasAttribute("tab-label")) {
                                    // Only add if it's a valid tab panel
                                    this.#addTab(panelElement);
                                }
                                tabsStructureChanged = true;
                            } else if (mutation.attributeName === "tab-label") {
                                if (sanitizedCurrentTabId)
                                    this.#updateTabLabel(
                                        sanitizedCurrentTabId,
                                        panelElement.getAttribute("tab-label")
                                    );
                            } else if (mutation.attributeName === "id") {
                                // If user changes panel's ID, we might need to update aria-controls if we were using it.
                                // The current #addTab logic prefers user's ID, so this should be less of an issue.
                                // Re-processing the tab might be safest if its ID changes.
                                if (
                                    sanitizedCurrentTabId &&
                                    this.#panelsByTabId.has(
                                        sanitizedCurrentTabId
                                    )
                                ) {
                                    const button = this.#buttonsByTabId.get(
                                        sanitizedCurrentTabId
                                    );
                                    if (button)
                                        button.setAttribute(
                                            "aria-controls",
                                            panelElement.id ||
                                                `panel-for-${button.id}`
                                        );
                                }
                            }
                        }
                    }

                    if (tabsStructureChanged) {
                        this.#ensureActiveTab();
                    }
                }

                #processSlottedChildren() {
                    const currentSlottedPanels = this.#slot
                        .assignedElements({ flatten: true })
                        .filter(
                            (el) =>
                                el.nodeType === Node.ELEMENT_NODE &&
                                el.hasAttribute("tab") &&
                                el.hasAttribute("tab-label")
                        );

                    // Add new tabs
                    for (const panel of currentSlottedPanels) {
                        const tabIdAttr = panel.getAttribute("tab");
                        // Use sanitized ID for internal map keys
                        if (
                            tabIdAttr &&
                            !this.#buttonsByTabId.has(
                                this.#sanitizeId(tabIdAttr)
                            )
                        ) {
                            this.#addTab(panel);
                        }
                    }

                    // Remove tabs that are no longer in the slot
                    const currentSanitizedIdsInSlot = new Set(
                        currentSlottedPanels.map((p) =>
                            this.#sanitizeId(p.getAttribute("tab"))
                        )
                    );
                    for (const internalSanitizedId of this.#buttonsByTabId.keys()) {
                        if (
                            !currentSanitizedIdsInSlot.has(internalSanitizedId)
                        ) {
                            this.#removeTab(internalSanitizedId);
                        }
                    }
                    this.#ensureActiveTab();
                }

                #ensureActiveTab() {
                    const hostActiveTabAttr = this.getAttribute("active-tab"); // User-provided 'tab' attribute value
                    const sanitizedHostActiveTab = hostActiveTabAttr
                        ? this.#sanitizeId(hostActiveTabAttr)
                        : null;

                    if (
                        sanitizedHostActiveTab &&
                        this.#buttonsByTabId.has(sanitizedHostActiveTab)
                    ) {
                        if (this.#activeTabId !== sanitizedHostActiveTab) {
                            this.activateTab(sanitizedHostActiveTab, false);
                        }
                    } else if (
                        !this.#activeTabId &&
                        this.#buttonsByTabId.size > 0
                    ) {
                        // Activate the first tab if no active tab is set and there are tabs
                        this.activateTab(
                            this.#buttonsByTabId.keys().next().value,
                            false
                        );
                    } else if (
                        this.#activeTabId &&
                        !this.#buttonsByTabId.has(this.#activeTabId)
                    ) {
                        // If current active tab was removed, try to activate another or clear
                        this.#activeTabId = null;
                        if (this.#buttonsByTabId.size > 0) {
                            this.activateTab(
                                this.#buttonsByTabId.keys().next().value,
                                false
                            );
                        } else {
                            // No tabs left, ensure host attribute is cleared
                            if (this.getAttribute("active-tab"))
                                this.removeAttribute("active-tab");
                        }
                    } else if (!hostActiveTabAttr && this.#activeTabId) {
                        // Host attribute was removed, but an internal tab is still active.
                        // This case might imply deselecting all, or re-syncing host attribute.
                        // For now, let's assume if host attribute is removed, we try to pick a default or clear.
                        // This is mostly handled by the `this.activeTab = null` in attributeChangedCallback.
                    }
                }

                #addTab(panelElement) {
                    const userTabIdAttr = panelElement.getAttribute("tab"); // e.g., "tagging"
                    const tabLabel = panelElement.getAttribute("tab-label");

                    if (!userTabIdAttr || typeof tabLabel !== "string") return;

                    // Internal key for maps, based on the user's 'tab' attribute.
                    const sanitizedInternalKey =
                        this.#sanitizeId(userTabIdAttr);

                    if (this.#buttonsByTabId.has(sanitizedInternalKey)) {
                        this.#updateTabLabel(sanitizedInternalKey, tabLabel);
                        this.#panelsByTabId.set(
                            sanitizedInternalKey,
                            panelElement
                        ); // Ensure panel reference is up-to-date
                        return;
                    }

                    const button = document.createElement("button");
                    button.setAttribute("role", "tab");
                    button.setAttribute("aria-selected", "false");
                    button.tabIndex = -1; // Initially not focusable until active

                    // Button ID needs to be unique and stable for ARIA
                    const buttonGeneratedId = `tab-btn-${sanitizedInternalKey}-${Math.random()
                        .toString(36)
                        .slice(2, 7)}`;
                    button.id = buttonGeneratedId;
                    button.textContent = tabLabel;
                    button.addEventListener("click", () =>
                        this.activateTab(sanitizedInternalKey)
                    );

                    // Determine the panel's ID for ARIA attributes
                    // Prefer user-defined ID on the panelElement, otherwise generate one.
                    let panelActualId = panelElement.id;
                    if (!panelActualId) {
                        panelActualId = `panel-content-${sanitizedInternalKey}-${Math.random()
                            .toString(36)
                            .slice(2, 7)}`;
                        panelElement.id = panelActualId; // Assign generated ID if panel didn't have one
                    }

                    button.setAttribute("aria-controls", panelActualId);

                    this.#tabBar.appendChild(button);
                    this.#buttonsByTabId.set(sanitizedInternalKey, button);
                    this.#panelsByTabId.set(sanitizedInternalKey, panelElement);

                    panelElement.setAttribute("role", "tabpanel");
                    panelElement.setAttribute(
                        "aria-labelledby",
                        buttonGeneratedId
                    );
                    panelElement.setAttribute("aria-hidden", "true"); // Initially hidden
                }

                #removeTab(sanitizedInternalKey) {
                    const button =
                        this.#buttonsByTabId.get(sanitizedInternalKey);
                    if (button) {
                        button.remove();
                        this.#buttonsByTabId.delete(sanitizedInternalKey);
                    }
                    const panel = this.#panelsByTabId.get(sanitizedInternalKey);
                    if (panel) {
                        // Don't remove user-set ID, just ARIA roles if they were set by this component
                        panel.removeAttribute("role");
                        // panel.removeAttribute('id'); // NO! Keep user's ID or generated one if we set it.
                        panel.removeAttribute("aria-labelledby");
                        panel.setAttribute("aria-hidden", "true"); // Ensure it's hidden
                        this.#panelsByTabId.delete(sanitizedInternalKey);
                    }

                    if (this.#activeTabId === sanitizedInternalKey) {
                        this.#activeTabId = null;
                        // #ensureActiveTab will handle selecting a new default if necessary
                    }
                }

                #updateTabLabel(sanitizedInternalKey, newLabel) {
                    const button =
                        this.#buttonsByTabId.get(sanitizedInternalKey);
                    if (button && button.textContent !== newLabel) {
                        button.textContent = newLabel;
                    }
                }

                activateTab(sanitizedTabIdToActivate, focusButton = true) {
                    if (
                        !sanitizedTabIdToActivate ||
                        !this.#buttonsByTabId.has(sanitizedTabIdToActivate)
                    ) {
                        // If the target tab doesn't exist, try to activate the first available one.
                        if (this.#buttonsByTabId.size > 0) {
                            const firstTabKey = this.#buttonsByTabId
                                .keys()
                                .next().value;
                            if (this.#activeTabId !== firstTabKey)
                                this.activateTab(firstTabKey, focusButton);
                        } else {
                            // No tabs to activate, clear active state
                            if (this.#activeTabId) {
                                const oldButton = this.#buttonsByTabId.get(
                                    this.#activeTabId
                                );
                                const oldPanel = this.#panelsByTabId.get(
                                    this.#activeTabId
                                );
                                if (oldButton) {
                                    oldButton.classList.remove("active");
                                    oldButton.setAttribute(
                                        "aria-selected",
                                        "false"
                                    );
                                    oldButton.tabIndex = -1;
                                }
                                if (oldPanel)
                                    oldPanel.setAttribute(
                                        "aria-hidden",
                                        "true"
                                    );
                            }
                            this.#activeTabId = null;
                            if (this.getAttribute("active-tab"))
                                this.removeAttribute("active-tab");
                        }
                        return;
                    }

                    if (this.#activeTabId === sanitizedTabIdToActivate) {
                        const currentButton = this.#buttonsByTabId.get(
                            sanitizedTabIdToActivate
                        );
                        if (
                            focusButton &&
                            currentButton &&
                            document.activeElement !== currentButton
                        ) {
                            currentButton.focus();
                        }
                        return; // Already active
                    }

                    // Deactivate previously active tab
                    if (this.#activeTabId) {
                        const oldActiveButton = this.#buttonsByTabId.get(
                            this.#activeTabId
                        );
                        const oldActivePanel = this.#panelsByTabId.get(
                            this.#activeTabId
                        );
                        if (oldActiveButton) {
                            oldActiveButton.classList.remove("active");
                            oldActiveButton.setAttribute(
                                "aria-selected",
                                "false"
                            );
                            oldActiveButton.tabIndex = -1;
                        }
                        if (oldActivePanel)
                            oldActivePanel.setAttribute("aria-hidden", "true");
                    }

                    // Activate new tab
                    const newActiveButton = this.#buttonsByTabId.get(
                        sanitizedTabIdToActivate
                    );
                    const newActivePanel = this.#panelsByTabId.get(
                        sanitizedTabIdToActivate
                    );

                    if (newActiveButton && newActivePanel) {
                        newActiveButton.classList.add("active");
                        newActiveButton.setAttribute("aria-selected", "true");
                        newActiveButton.tabIndex = 0; // Make active tab focusable
                        newActivePanel.setAttribute("aria-hidden", "false");

                        this.#activeTabId = sanitizedTabIdToActivate;

                        // Get the original 'tab' attribute value for the host attribute
                        const originalUserProvidedTabId =
                            newActivePanel.getAttribute("tab");
                        if (
                            this.getAttribute("active-tab") !==
                            originalUserProvidedTabId
                        ) {
                            this.setAttribute(
                                "active-tab",
                                originalUserProvidedTabId
                            );
                        }

                        if (focusButton) newActiveButton.focus();
                        newActiveButton.scrollIntoView({
                            behavior: "smooth",
                            block: "nearest",
                            inline: "nearest",
                        });

                        this.dispatchEvent(
                            new CustomEvent("tab-change", {
                                bubbles: true,
                                composed: true,
                                detail: {
                                    activeTabId: originalUserProvidedTabId, // Dispatch user-provided ID
                                    relatedPanel: newActivePanel,
                                },
                            })
                        );
                    }
                }

                #handleTabBarKeyDown(event) {
                    const buttons = Array.from(
                        this.#tabBar.querySelectorAll('button[role="tab"]')
                    );
                    if (buttons.length === 0) return;

                    let currentIndex = buttons.findIndex(
                        (btn) => btn.getAttribute("aria-selected") === "true"
                    );

                    // If no tab is selected (e.g., on init before first activation), default to first for arrow keys
                    if (currentIndex === -1 && buttons.length > 0)
                        currentIndex = 0;

                    let newIndex = currentIndex;
                    let shouldPreventDefault = true;

                    switch (event.key) {
                        case "ArrowLeft":
                            newIndex =
                                (currentIndex - 1 + buttons.length) %
                                buttons.length;
                            break;
                        case "ArrowRight":
                            newIndex = (currentIndex + 1) % buttons.length;
                            break;
                        case "Home":
                            newIndex = 0;
                            break;
                        case "End":
                            newIndex = buttons.length - 1;
                            break;
                        default:
                            shouldPreventDefault = false;
                            return; // Do not interfere with other keys
                    }

                    if (shouldPreventDefault) event.preventDefault();

                    // Find the sanitized key corresponding to the new button to activate
                    const newButtonToActivate = buttons[newIndex];
                    // We need to find the sanitizedInternalKey associated with this button.
                    // This is a bit indirect; ideally, the button would store its sanitized key.
                    let targetSanitizedKey = null;
                    for (const [key, btn] of this.#buttonsByTabId.entries()) {
                        if (btn === newButtonToActivate) {
                            targetSanitizedKey = key;
                            break;
                        }
                    }
                    if (targetSanitizedKey) {
                        this.activateTab(targetSanitizedKey); // activateTab handles focus
                    }
                }

                /**
                 * Gets the user-provided 'tab' attribute value of the currently active tab.
                 * @returns {string | null}
                 */
                get activeTab() {
                    return this.#activeTabId
                        ? this.#panelsByTabId
                              .get(this.#activeTabId)
                              ?.getAttribute("tab")
                        : null;
                }

                /**
                 * Sets the active tab using its user-provided 'tab' attribute value.
                 * @param {string | null} userTabIdAttr - The 'tab' attribute value of the panel to activate.
                 */
                set activeTab(userTabIdAttr) {
                    if (userTabIdAttr) {
                        const sanitizedId = this.#sanitizeId(userTabIdAttr);
                        if (this.#buttonsByTabId.has(sanitizedId)) {
                            this.activateTab(sanitizedId);
                        } else {
                            console.warn(
                                `Tab with id "${userTabIdAttr}" (sanitized: "${sanitizedId}") not found.`
                            );
                        }
                    } else if (this.#activeTabId) {
                        // Deactivate current tab if setting to null/empty
                        const oldActiveButton = this.#buttonsByTabId.get(
                            this.#activeTabId
                        );
                        const oldActivePanel = this.#panelsByTabId.get(
                            this.#activeTabId
                        );
                        if (oldActiveButton) {
                            oldActiveButton.classList.remove("active");
                            oldActiveButton.setAttribute(
                                "aria-selected",
                                "false"
                            );
                            oldActiveButton.tabIndex = -1;
                        }
                        if (oldActivePanel)
                            oldActivePanel.setAttribute("aria-hidden", "true");

                        this.#activeTabId = null;
                        if (this.getAttribute("active-tab"))
                            this.removeAttribute("active-tab");
                        // #ensureActiveTab might pick a new default if one is available
                        this.#ensureActiveTab();
                    }
                }
            }

            customElements.define("tab-container", HTMLTabContainerElement);

            let draggedElement = null;
            const PROJECT_FILE_EXTENSION = ".loraproj";
            let mainView = null;
            let mainContentAreaElement = null;
            let appContainer = null;
            let splashScreenElement = null;
            let dropHint = null;
            let searchInput = null;
            let autotagAllButton = null;
            const AUTOTAG_API_URL = "http://localhost:8081/autotag/";
            const HEALTH_CHECK_URL = "http://localhost:8081/health";

            let globalParsedSearchTerms = [];
            let globalSearchTermColors = {};
            // now stores the entry that was the *anchor* for the last selection operation (simple click or ctrl+click)
            let globalLastClickedEntryForShiftSelect = null;

            // TODO: this should probably be its own web component
            let devConsoleElement = null;
            let consoleOutputElement = null;
            const CONSOLE_MAX_HEIGHT_PERCENT = 40;
            let isConsoleVisible = false;
            let consoleCodeMirrorInstance = null;
            let consoleHistory = [];
            let consoleHistoryIndex = -1;
            let currentConsoleInputBuffer = "";
            let hasShownConsoleWelcomeMessage = false;

            const preferences = {
                importingImages: {
                    minimumHeight: 768,
                    minimumWidth: 768,
                    maximumHeight: 4096,
                    maximumWidth: 4096,
                    minimumPixelsSum: -1,
                    maximumPixelsSum: -1,
                },
                tagging: {
                    autocompleteSuggestions: {
                        enabled: true,
                        maxSuggestions: 10,
                        csvFile: {
                            "@type": "select",
                            value: "danbooru_e621_merged.csv",
                            options: [
                                "e621.csv",
                                "danbooru.csv",
                                "danbooru_e621_merged.csv",
                            ],
                        },
                    },
                    autotagging: {
                        enabled: true,
                        timeout: 30000,
                        autotaggingModel: {
                            "@type": "select",
                            value: "wd-vit-tagger-v3",
                            options: [
                                "wd-vit-tagger-v3",
                                "it_so400m_patch14_siglip_384",
                            ],
                        },
                    },
                },
            };

            function keyToLabel(key) {
                if (typeof key !== "string") return "";
                const result = key.replace(/([A-Z])/g, " $1");
                return result.charAt(0).toUpperCase() + result.slice(1);
            }

            function updatePreference(path, value) {
                const keys = path.split(".");
                let obj = preferences;
                for (let i = 0; i < keys.length - 1; i++) {
                    obj = obj[keys[i]];
                    if (typeof obj !== "object" || obj === null) {
                        console.error(
                            `Invalid path for preference update: ${path}`
                        );
                        return;
                    }
                }
                const lastKey = keys[keys.length - 1];
                const currentValue = obj[lastKey];

                if (typeof currentValue === "number") {
                    obj[lastKey] = Number(value);
                } else if (typeof currentValue === "boolean") {
                    obj[lastKey] = Boolean(value);
                } else {
                    obj[lastKey] = value;
                }

                console.log(
                    `Preference updated: ${path} =`,
                    obj[lastKey],
                    preferences
                );
                // TODO: Add logic here to actually *apply* the preference if needed immediately
            }

            function generatePreferencesUI(
                config,
                parentElement,
                currentPath = "",
                level = 0
            ) {
                for (const [key, value] of Object.entries(config)) {
                    const itemPath = currentPath
                        ? `${currentPath}.${key}`
                        : key;
                    const labelText = keyToLabel(key);

                    if (
                        typeof value === "object" &&
                        value !== null &&
                        !value["@type"]
                    ) {
                        const section = document.createElement("div");
                        section.className = "preferences-section";

                        const title = document.createElement(
                            level === 0 ? "h3" : "h4"
                        );
                        title.textContent = labelText;
                        section.appendChild(title);

                        generatePreferencesUI(
                            value,
                            section,
                            itemPath,
                            level + 1
                        );
                        parentElement.appendChild(section);
                    } else {
                        const itemDiv = document.createElement("div");
                        itemDiv.className = "preference-item";

                        const label = document.createElement("label");
                        label.textContent = labelText;
                        label.htmlFor = `pref-${itemPath}`;
                        itemDiv.appendChild(label);

                        if (
                            typeof value === "object" &&
                            value !== null &&
                            value["@type"] === "select"
                        ) {
                            const select = document.createElement("select");
                            select.id = `pref-${itemPath}`;
                            select.value = value.value;
                            value.options.forEach((opt) => {
                                const option = document.createElement("option");
                                option.value = opt;
                                option.textContent = opt;
                                if (opt === value.value) option.selected = true;
                                select.appendChild(option);
                            });
                            select.addEventListener("change", (e) =>
                                updatePreference(
                                    itemPath + ".value",
                                    e.target.value
                                )
                            );
                            itemDiv.appendChild(select);
                        } else if (typeof value === "boolean") {
                            const checkbox = document.createElement("input");
                            checkbox.type = "checkbox";
                            checkbox.id = `pref-${itemPath}`;
                            checkbox.checked = value;
                            checkbox.addEventListener("change", (e) =>
                                updatePreference(itemPath, e.target.checked)
                            );
                            itemDiv.appendChild(checkbox);
                        } else if (typeof value === "number") {
                            const numInput = document.createElement("input");
                            numInput.type = "number";
                            numInput.id = `pref-${itemPath}`;
                            numInput.value = value;
                            if (key.toLowerCase().includes("pixels"))
                                numInput.step = 1000; // Example specific step
                            else if (key.toLowerCase().includes("timeout"))
                                numInput.step = 1000;
                            else if (key.toLowerCase().includes("suggestions"))
                                numInput.step = 1;
                            else numInput.step = 1; // Default step for numbers
                            numInput.addEventListener("change", (e) =>
                                updatePreference(
                                    itemPath,
                                    parseFloat(e.target.value)
                                )
                            );
                            itemDiv.appendChild(numInput);
                        } else if (typeof value === "string") {
                            const textInput = document.createElement("input");
                            textInput.type = "text";
                            textInput.id = `pref-${itemPath}`;
                            textInput.value = value;
                            textInput.addEventListener("change", (e) =>
                                updatePreference(itemPath, e.target.value)
                            );
                            itemDiv.appendChild(textInput);
                        }
                        parentElement.appendChild(itemDiv);
                    }
                }
            }

            /**
             * @type {{ [id: string]: HTMLAudioElement }}
             */
            const sfx = {
                sfxWelcome: null,
                sfxGood1: null,
                sfxGood2: null,
                sfxGood3: null,
                sfxBad: null,
                sfxGoodnight: null,
                sfxPop: null,
            };

            const fadeOutAudioContext = new AudioContext({
                sampleRate: 44100,
                latencyHint: "interactive",
            });

            for (const key in sfx) {
                const audio = document.getElementById(key);
                audio.volume = 0.1;
                sfx[key] = audio;
            }

            // Autocomplete for Booru Tags
            let booruTags = [];
            let booruTagsLoadingPromise = null;
            const MAX_SUGGESTIONS = 10;
            let globalTagAutocompleteDropdown = null;

            async function loadBooruTags() {
                if (booruTags.length > 0) return booruTags;
                if (booruTagsLoadingPromise) return booruTagsLoadingPromise;

                console.log("Initiating booru tag loading...");
                booruTagsLoadingPromise = fetch(
                    "/assets/csv/danbooru_e621_merged.csv"
                )
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error(
                                `HTTP error! status: ${response.status} while fetching tags.`
                            );
                        }
                        return response.text();
                    })
                    .then((csvText) => {
                        const lines = csvText.split("\n");
                        const loadedTags = [];
                        // Assuming the first line is a header: "tag_name,type_n,image_count,aliases"
                        for (let i = 1; i < lines.length; i++) {
                            const line = lines[i].trim();
                            if (!line) continue;

                            const parts = [];
                            let currentPart = "";
                            let inQuotes = false;
                            for (const char of line) {
                                if (char === "," && !inQuotes) {
                                    parts.push(currentPart);
                                    currentPart = "";
                                } else if (char === '"') {
                                    inQuotes = !inQuotes;
                                    // Don't add quotes to the part itself for aliases,
                                    // but respect them for parsing
                                } else {
                                    currentPart += char;
                                }
                            }
                            parts.push(currentPart);

                            if (parts.length >= 3) {
                                const tagName = parts[0].trim();
                                const typeN = parseInt(parts[1], 10);
                                const imageCount = parseInt(parts[2], 10);
                                // const aliases = parts[3] ? parts[3].trim() : ''; // Aliases raw string

                                if (
                                    tagName &&
                                    !isNaN(typeN) &&
                                    !isNaN(imageCount)
                                ) {
                                    loadedTags.push({
                                        name: tagName,
                                        type: typeN,
                                        count: imageCount,
                                    });
                                }
                            }
                        }
                        booruTags = loadedTags;
                        // Sort once after loading, by count descending for general use
                        booruTags.sort((a, b) => b.count - a.count);
                        console.log(
                            `Loaded and sorted ${booruTags.length} booru tags.`
                        );
                        return booruTags;
                    })
                    .catch((error) => {
                        console.error(
                            "Failed to load or parse booru tags:",
                            error
                        );
                        booruTagsLoadingPromise = null;
                        booruTags = [];
                        return [];
                    });
                return booruTagsLoadingPromise;
            }

            async function checkBackendReady(maxRetries = 30, delay = 1000) {
                console.log(
                    `Checking backend readiness at ${HEALTH_CHECK_URL}...`
                );
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(HEALTH_CHECK_URL);
                        if (response.ok) {
                            const data = await response.json();
                            console.log("Python backend is ready:", data);
                            return true;
                        } else {
                            console.warn(
                                `Backend health check failed with status ${
                                    response.status
                                }. Attempt ${i + 1}/${maxRetries}.`
                            );
                        }
                    } catch (err) {
                        console.warn(
                            `Backend not ready yet (attempt ${
                                i + 1
                            }/${maxRetries}): ${err.message}. Retrying in ${
                                delay / 1000
                            }s...`
                        );
                    }
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
                console.error(
                    "Python backend did not become ready after multiple retries."
                );
                return false;
            }

            const opentaggerAPI = {
                search: (...args) => {
                    const query = args.join(" ").trim();
                    if (searchInput) {
                        searchInput.value = query;
                        filterEntries(query);
                    } else {
                        filterEntries(query);
                    }
                    logToConsole(
                        `API: opentaggerAPI.search("${query}") executed.`
                    );
                    return `Search initiated for: "${query}"`;
                },
                selectEntries: (query, append = false) => {
                    if (!mainContentAreaElement) {
                        logToConsole(
                            "Error: Main content area not found.",
                            "error"
                        );
                        return "Selection failed: Main content area not found.";
                    }

                    if (!append) {
                        opentaggerAPI.deselectAllEntries(true);
                    }

                    const entries =
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry"
                        );
                    const normalizedQuery = query.trim().toLowerCase();
                    let selectionCount = 0;

                    // Get visible entries to apply selection only to them if query is empty
                    const visibleEntries = Array.from(
                        mainContentAreaElement.querySelectorAll(
                            'dataset-entry:not([style*="display: none"])'
                        )
                    );

                    for (const entry of entries) {
                        const isVisible = entry.style.display !== "none";
                        let match = false;

                        if (normalizedQuery === "") {
                            // If query is empty, select only visible entries
                            match = isVisible;
                        } else {
                            // If query exists, match based on query AND visibility
                            const tags = entry.getNormalizedTags();
                            match =
                                evaluateExpression(normalizedQuery, tags) &&
                                isVisible;
                        }

                        if (match) {
                            entry.selected = true;
                            selectionCount++;
                        } else if (!append && entry.selected) {
                            // If not appending and entry is selected but doesn't match or isn't visible, deselect it
                            entry.selected = false;
                        }
                    }

                    // Update g_lastClickedEntryForShiftSelect if only one entry is selected after the operation
                    const currentlySelected =
                        opentaggerAPI.getSelectedEntries();
                    if (currentlySelected.length === 1) {
                        globalLastClickedEntryForShiftSelect =
                            currentlySelected[0];
                    } else {
                        globalLastClickedEntryForShiftSelect = null;
                    }

                    const message =
                        `Selected ${selectionCount} entr${
                            selectionCount === 1 ? "y" : "ies"
                        }` +
                        (query
                            ? ` matching "${query}".`
                            : append
                            ? " (appended to existing selection)."
                            : ".");
                    return message;
                },
                deselectAllEntries: (silent = false) => {
                    if (!mainContentAreaElement) {
                        if (!silent)
                            logToConsole(
                                "Error: Main content area not found.",
                                "error"
                            );
                        return "Deselection failed: Main content area not found.";
                    }
                    let deselectionCount = 0;

                    for (const entry of mainContentAreaElement.querySelectorAll(
                        "dataset-entry[selected]"
                    )) {
                        entry.selected = false;
                        deselectionCount++;
                    }

                    globalLastClickedEntryForShiftSelect = null;

                    const message = `Deselected ${deselectionCount} entr${
                        deselectionCount === 1 ? "y" : "ies"
                    }.`;
                    return message;
                },
                getSelectedEntries: () => {
                    if (!mainContentAreaElement) return [];
                    return Array.from(
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry[selected]"
                        )
                    );
                },
                filterSelectedEntries: (query) => {
                    if (!mainContentAreaElement) {
                        return "Filter failed: Main content area not found.";
                    }
                    const trimmedQuery =
                        typeof query === "string" ? query.trim() : "";
                    if (trimmedQuery === "") {
                        return "Filter query is empty. No entries changed.";
                    }

                    const selectedEntries = Array.from(
                        mainContentAreaElement.querySelectorAll(
                            "dataset-entry[selected]"
                        )
                    );
                    if (selectedEntries.length === 0) {
                        return "No entries selected to filter.";
                    }

                    let deselectedCount = 0;

                    for (const entry of selectedEntries) {
                        const tags = entry.getNormalizedTags();
                        const shouldKeep = evaluateExpression(
                            trimmedQuery,
                            tags
                        );
                        if (!shouldKeep) {
                            entry.selected = false;
                            deselectedCount++;
                        }
                    }

                    // Update g_lastClickedEntryForShiftSelect if only one entry remains selected
                    const currentlySelected =
                        opentaggerAPI.getSelectedEntries();
                    if (currentlySelected.length === 1) {
                        globalLastClickedEntryForShiftSelect =
                            currentlySelected[0];
                    } else if (
                        deselectedCount > 0 &&
                        globalLastClickedEntryForShiftSelect &&
                        !globalLastClickedEntryForShiftSelect.selected
                    ) {
                        // If the last clicked entry was deselected by the filter, clear it
                        globalLastClickedEntryForShiftSelect = null;
                    }

                    const keptCount = selectedEntries.length - deselectedCount;
                    return `Filter applied to ${
                        selectedEntries.length
                    } selected entr${
                        selectedEntries.length === 1 ? "y" : "ies"
                    }. Kept: ${keptCount}, Deselected: ${deselectedCount}. Query: "${query}"`;
                },
                addTagsToSelected: (tagsArray) => {
                    const selectedEntries = opentaggerAPI.getSelectedEntries();
                    if (selectedEntries.length === 0) {
                        return "No entries selected. No tags added.";
                    }
                    if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                        return "No tags provided to add.";
                    }

                    let totalTagsAdded = 0;
                    let entriesModified = 0;

                    for (const entry of selectedEntries) {
                        let tagsAddedToThisEntry = 0;
                        for (const tag of tagsArray) {
                            if (entry.addTag(tag)) {
                                tagsAddedToThisEntry++;
                            }
                        }
                        if (tagsAddedToThisEntry > 0) {
                            totalTagsAdded += tagsAddedToThisEntry;
                            entriesModified++;
                        }
                    }
                    return `Added ${totalTagsAdded} tag(s) across ${entriesModified} selected entr${
                        entriesModified === 1 ? "y" : "ies"
                    }.`;
                },
                removeTagsFromSelected: (tagsArray) => {
                    const selectedEntries = opentaggerAPI.getSelectedEntries();
                    if (selectedEntries.length === 0) {
                        return "No entries selected. No tags removed.";
                    }
                    if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                        return "No tags provided to remove.";
                    }
                    if (tagsArray.length === 1 && tagsArray[0] === "*") {
                        // support wildcard removal but only if no other tags are provided for now
                        // Note: This gets tags from the *first* selected entry, which might not be representative.
                        // A better approach for '*' would be to iterate through all selected entries and remove all tags from each.
                        // Let's implement the "remove all from selected" logic directly.
                        let totalTagsRemoved = 0;
                        let entriesModified = 0;
                        for (const entry of selectedEntries) {
                            const currentTagCount = entry.getTags().length;
                            if (currentTagCount > 0) {
                                entry.setTags([]); // setTags will trigger updates
                                totalTagsRemoved += currentTagCount;
                                entriesModified++;
                            }
                        }

                        return `Removed all tags from ${entriesModified} selected entr${
                            entriesModified === 1 ? "y" : "ies"
                        }. Total tags removed: ${totalTagsRemoved}.`;
                    }

                    const tagsToRemoveLower = tagsArray
                        .map((t) => String(t).trim().toLowerCase())
                        .filter((t) => t);
                    if (tagsToRemoveLower.length === 0) {
                        return "No valid tags provided to remove after processing.";
                    }

                    let totalTagsRemoved = 0;
                    let entriesModified = 0;

                    for (const entry of selectedEntries) {
                        const currentTags = entry.getTags();
                        const initialTagCount = currentTags.length;

                        const newTags = currentTags.filter(
                            (tag) =>
                                !tagsToRemoveLower.includes(tag.toLowerCase())
                        );

                        if (newTags.length < initialTagCount) {
                            entry.setTags(newTags); // setTags will trigger updates
                            totalTagsRemoved +=
                                initialTagCount - newTags.length;
                            entriesModified++;
                        }
                    }
                    return `Removed ${totalTagsRemoved} tag(s) across ${entriesModified} selected entr${
                        entriesModified === 1 ? "y" : "ies"
                    }.`;
                },
                rename: ({ targetTag, replaceValue, global = false }) => {
                    if (!mainContentAreaElement) {
                        return "Rename failed: Main content area not found.";
                    }
                    if (
                        typeof targetTag !== "string" ||
                        targetTag.trim() === ""
                    ) {
                        return "Rename failed: targetTag must be a non-empty string.";
                    }
                    if (
                        typeof replaceValue !== "string" ||
                        replaceValue.trim() === ""
                    ) {
                        return "Rename failed: replaceValue must be a non-empty string.";
                    }

                    const targetTagLower = targetTag.trim().toLowerCase();
                    const replaceValueTrimmed = replaceValue.trim();
                    const replaceValueLower = replaceValueTrimmed.toLowerCase();

                    let totalEntriesModified = 0;
                    let totalGroupsModified = 0;
                    let totalTagOccurrencesRenamed = 0;

                    // Process Dataset Entries
                    const entriesToProcess = global
                        ? Array.from(
                              mainContentAreaElement.querySelectorAll(
                                  "dataset-entry"
                              )
                          )
                        : opentaggerAPI.getSelectedEntries();

                    for (const entry of entriesToProcess) {
                        const currentTags = entry.getTags();
                        let entryModified = false;
                        const newTags = [];
                        const newTagsLower = new Set();

                        for (const tag of currentTags) {
                            const tagLower = tag.toLowerCase();
                            if (tagLower === targetTagLower) {
                                // Replace the target tag
                                if (!newTagsLower.has(replaceValueLower)) {
                                    newTags.push(replaceValueTrimmed);
                                    newTagsLower.add(replaceValueLower);
                                    totalTagOccurrencesRenamed++;
                                    entryModified = true;
                                } else {
                                    // If replaceValue is already present, just drop the targetTag
                                    totalTagOccurrencesRenamed++; // Still count as an occurrence replaced/removed
                                    entryModified = true;
                                }
                            } else {
                                // Keep other tags, avoiding duplicates if replaceValue matches an existing tag
                                if (!newTagsLower.has(tagLower)) {
                                    newTags.push(tag);
                                    newTagsLower.add(tagLower);
                                }
                            }
                        }

                        if (entryModified) {
                            entry.setTags(newTags); // setTags handles internal updates and events
                            totalEntriesModified++;
                        }
                    }

                    // Process Tag Groups if global is true
                    if (global) {
                        const groups = document.querySelectorAll(
                            "#tag-group-list tag-group"
                        );
                        for (const group of groups) {
                            const list = group.querySelector("tag-list");
                            if (!list) continue;

                            const currentTags = list.getTags();
                            let groupModified = false;
                            const newTags = [];
                            const newTagsLower = new Set();

                            for (const tag of currentTags) {
                                const tagLower = tag.toLowerCase();
                                if (tagLower === targetTagLower) {
                                    // Replace the target tag
                                    if (!newTagsLower.has(replaceValueLower)) {
                                        newTags.push(replaceValueTrimmed);
                                        newTagsLower.add(replaceValueLower);
                                        totalTagOccurrencesRenamed++; // Count occurrences in groups too
                                        groupModified = true;
                                    } else {
                                        // If replaceValue is already present, just drop the targetTag
                                        totalTagOccurrencesRenamed++; // Still count as an occurrence replaced/removed
                                        groupModified = true;
                                    }
                                } else {
                                    // Keep other tags, avoiding duplicates
                                    if (!newTagsLower.has(tagLower)) {
                                        newTags.push(tag);
                                        newTagsLower.add(tagLower);
                                    }
                                }
                            }

                            if (groupModified) {
                                list.setTagsFromArray(newTags); // Use setTagsFromArray to update the list UI
                                totalGroupsModified++;
                            }
                        }
                    }

                    const scope = global
                        ? "all entries and groups"
                        : `${entriesToProcess.length} selected entr${
                              entriesToProcess.length === 1 ? "y" : "ies"
                          }`;
                    let message = `Renamed "${targetTag}" to "${replaceValue}".`;
                    if (totalEntriesModified > 0) {
                        message += ` Modified ${totalEntriesModified} entr${
                            totalEntriesModified === 1 ? "y" : "ies"
                        }.`;
                    }
                    if (global && totalGroupsModified > 0) {
                        message += ` Modified ${totalGroupsModified} group${
                            totalGroupsModified === 1 ? "" : "s"
                        }.`;
                    }
                    message += ` Total tag occurrences renamed: ${totalTagOccurrencesRenamed}.`;

                    if (
                        totalEntriesModified === 0 &&
                        totalGroupsModified === 0
                    ) {
                        message = `No occurrences of "${targetTag}" found to rename in ${scope}.`;
                    }

                    return message;
                },
                count: (tagsArray) => {
                    if (!mainContentAreaElement) {
                        return "Count failed: Main content area not found.";
                    }
                    if (!Array.isArray(tagsArray) || tagsArray.length === 0) {
                        return "Count failed: No tags provided to count.";
                    }

                    const requiredTagsLower = tagsArray
                        .map((t) => String(t).trim().toLowerCase())
                        .filter((t) => t);
                    if (requiredTagsLower.length === 0) {
                        return "Count failed: No valid tags provided after processing.";
                    }

                    const visibleEntries = Array.from(
                        mainContentAreaElement.querySelectorAll(
                            'dataset-entry:not([style*="display: none"])'
                        )
                    );

                    let matchCount = 0;

                    for (const entry of visibleEntries) {
                        const entryTagsLower = entry.getNormalizedTags();
                        const allRequiredTagsPresent = requiredTagsLower.every(
                            (requiredTag) =>
                                entryTagsLower.includes(requiredTag)
                        );

                        if (allRequiredTagsPresent) {
                            matchCount++;
                        }
                    }

                    const tagListString = tagsArray.join(", ");
                    return `Found ${matchCount} visible entr${
                        matchCount === 1 ? "y" : "ies"
                    } containing all tags: "${tagListString}".`;
                },
                help: () => {
                    const apiHelp = `Available opentaggerAPI functions (callable directly in JS console):\n${Object.keys(
                        opentaggerAPI
                    )
                        .map(
                            (k) =>
                                `  ${k}${parseFunctionSignature(
                                    opentaggerAPI[k]
                                )}`
                        )
                        .join("\n")}`;
                    const cmdHelp = `\nAvailable slash commands:\n${Object.keys(
                        slashCommands
                    )
                        .map((k) => {
                            const commandObject = slashCommands[k];
                            let displaySignature = "";
                            if (
                                commandObject &&
                                commandObject.signature !== undefined
                            ) {
                                displaySignature = ` ${commandObject.signature}`;
                            } else {
                                let funcToParseForSig = commandObject.func;
                                if (
                                    commandObject.apiRef &&
                                    typeof opentaggerAPI[
                                        commandObject.apiRef
                                    ] === "function"
                                ) {
                                    funcToParseForSig =
                                        opentaggerAPI[commandObject.apiRef];
                                }
                                const parsedSig =
                                    parseFunctionSignature(funcToParseForSig);
                                if (parsedSig && parsedSig !== "()") {
                                    const paramsString = parsedSig
                                        .slice(1, -1)
                                        .trim();
                                    if (paramsString === "") {
                                        displaySignature = "";
                                    } else {
                                        const paramsList = [];
                                        let currentParam = "";
                                        let p_openBrackets = 0;
                                        let p_openParens = 0;
                                        for (
                                            let i = 0;
                                            i < paramsString.length;
                                            i++
                                        ) {
                                            const char = paramsString[i];
                                            currentParam += char;
                                            if (char === "{") p_openBrackets++;
                                            else if (char === "}")
                                                p_openBrackets--;
                                            else if (char === "(")
                                                p_openParens++;
                                            else if (char === ")")
                                                p_openParens--;
                                            else if (
                                                char === "," &&
                                                p_openBrackets === 0 &&
                                                p_openParens === 0
                                            ) {
                                                paramsList.push(
                                                    currentParam
                                                        .slice(0, -1)
                                                        .trim()
                                                );
                                                currentParam = "";
                                            }
                                        }
                                        if (currentParam.trim()) {
                                            paramsList.push(
                                                currentParam.trim()
                                            );
                                        }
                                        const transformedParams = paramsList
                                            .map((p_str) => {
                                                let p = p_str.trim();
                                                if (p.startsWith("...")) {
                                                    return `[${p}]`;
                                                } else if (p.includes("=")) {
                                                    const name = p
                                                        .split("=")[0]
                                                        .trim();
                                                    return `[${name}]`;
                                                } else if (p) {
                                                    return `<${p}>`;
                                                }
                                                return "";
                                            })
                                            .filter((p) => p)
                                            .join(" ");
                                        displaySignature = transformedParams
                                            ? ` ${transformedParams}`
                                            : "";
                                    }
                                } else {
                                    displaySignature = "";
                                }
                            }
                            return `  /${k}${
                                displaySignature.trim()
                                    ? `${displaySignature}`
                                    : ""
                            }`;
                        })
                        .join(
                            "\n"
                        )}\n\nQuery Syntax: Supports tags (e.g. cat), "quoted phrases", AND (&&), OR (||), NOT (!), and parentheses (). Example: face && (smile || !sad)\nType JavaScript code directly to execute it (e.g., 1+1, or search('tag')). Press Enter.`;
                    const helpText = `${apiHelp}\n${cmdHelp}`;
                    logToConsole(helpText, "info", true);
                    return "Help displayed in console.";
                },
                clear: () => {
                    if (consoleOutputElement)
                        consoleOutputElement.innerHTML = "";
                    return "Console cleared.";
                },
            };

            function customCodeMirrorHints(editor, options) {
                const cursor = editor.getCursor();
                const line = editor.getLine(cursor.line);
                const token = editor.getTokenAt(cursor);

                if (line.trim().startsWith("/") && cursor.ch > 0) {
                    let currentSlashCommandPart = "";
                    const textBeforeCursor = line.substring(0, cursor.ch);
                    const match = /^\/([^\s]*)/.exec(textBeforeCursor);

                    if (match && cursor.ch <= 1 + match[1].length) {
                        currentSlashCommandPart = match[1];

                        const suggestions = Object.keys(slashCommands)
                            .filter((cmd) =>
                                cmd.startsWith(currentSlashCommandPart)
                            )
                            .map((cmd) => {
                                const commandObject = slashCommands[cmd];
                                let displaySignature = "";

                                if (
                                    commandObject &&
                                    commandObject.signature !== undefined
                                ) {
                                    displaySignature =
                                        commandObject.signature.trim()
                                            ? ` ${commandObject.signature.trim()}`
                                            : "";
                                } else {
                                    let funcToParseForSig = commandObject.func;
                                    if (
                                        commandObject.apiRef &&
                                        typeof opentaggerAPI[
                                            commandObject.apiRef
                                        ] === "function"
                                    ) {
                                        funcToParseForSig =
                                            opentaggerAPI[commandObject.apiRef];
                                    }
                                    const parsedSig =
                                        parseFunctionSignature(
                                            funcToParseForSig
                                        );
                                    if (parsedSig && parsedSig !== "()") {
                                        const paramsString = parsedSig
                                            .slice(1, -1)
                                            .trim();
                                        if (paramsString === "") {
                                            displaySignature = "";
                                        } else {
                                            const paramsList = [];
                                            let currentParam = "";
                                            let p_openBrackets = 0;
                                            let p_openParens = 0;
                                            for (
                                                let i = 0;
                                                i < paramsString.length;
                                                i++
                                            ) {
                                                const char = paramsString[i];
                                                currentParam += char;
                                                if (char === "{")
                                                    p_openBrackets++;
                                                else if (char === "}")
                                                    p_openBrackets--;
                                                else if (char === "(")
                                                    p_openParens++;
                                                else if (char === ")")
                                                    p_openParens--;
                                                else if (
                                                    char === "," &&
                                                    p_openBrackets === 0 &&
                                                    p_openParens === 0
                                                ) {
                                                    paramsList.push(
                                                        currentParam
                                                            .slice(0, -1)
                                                            .trim()
                                                    );
                                                    currentParam = "";
                                                }
                                            }
                                            if (currentParam.trim()) {
                                                paramsList.push(
                                                    currentParam.trim()
                                                );
                                            }
                                            const transformedParams = paramsList
                                                .map((p_str) => {
                                                    let p = p_str.trim();
                                                    if (p.startsWith("...")) {
                                                        return `[${p}]`;
                                                    } else if (
                                                        p.includes("=")
                                                    ) {
                                                        const name = p
                                                            .split("=")[0]
                                                            .trim();
                                                        return `[${name}]`;
                                                    } else if (p) {
                                                        return `<${p}>`;
                                                    }
                                                    return "";
                                                })
                                                .filter((p) => p)
                                                .join(" ");
                                            displaySignature = transformedParams
                                                ? ` ${transformedParams}`
                                                : "";
                                        }
                                    } else {
                                        displaySignature = "";
                                    }
                                }
                                return {
                                    text: "/" + cmd + " ",
                                    displayText: `/${cmd}${displaySignature}`,
                                    render: function (element, self, data) {
                                        const cmdNameEl =
                                            document.createElement("span");
                                        cmdNameEl.textContent = "/" + cmd;
                                        cmdNameEl.style.fontWeight = "bold";
                                        element.appendChild(cmdNameEl);
                                        if (displaySignature.trim()) {
                                            const sigEl =
                                                document.createElement("span");
                                            sigEl.textContent =
                                                displaySignature;
                                            sigEl.style.color = "#777";
                                            sigEl.style.marginLeft = "5px";
                                            element.appendChild(sigEl);
                                        }
                                    },
                                    className: "CodeMirror-hint-slash-command",
                                };
                            });
                        if (suggestions.length > 0) {
                            return {
                                list: suggestions,
                                from: CodeMirror.Pos(
                                    cursor.line,
                                    textBeforeCursor.lastIndexOf("/")
                                ),
                                to: CodeMirror.Pos(cursor.line, cursor.ch),
                            };
                        }
                    }
                }

                const jsGlobals = {};

                for (const key of Object.keys(opentaggerAPI)) {
                    if (typeof opentaggerAPI[key] === "function") {
                        jsGlobals[key] = opentaggerAPI[key];
                    }
                }
                const commonBrowserGlobals = [
                    "document",
                    "window",
                    "console",
                    "Math",
                    "JSON",
                    "localStorage",
                    "sessionStorage",
                    "navigator",
                    "location",
                    "alert",
                    "prompt",
                    "confirm",
                    "setTimeout",
                    "clearTimeout",
                    "setInterval",
                    "clearInterval",
                    "fetch",
                    "Promise",
                    "URL",
                    "Image",
                    "File",
                    "Blob",
                    "FileReader",
                    "FormData",
                    "Date",
                ];

                for (const g of commonBrowserGlobals) {
                    if (typeof window[g] !== "undefined") {
                        jsGlobals[g] = window[g];
                    }
                }
                const currentWord = token.string.trim().toLowerCase();
                const topLevelSuggestions = [];
                if (!token.string.includes(".")) {
                    for (const key of Object.keys(jsGlobals)) {
                        if (key.toLowerCase().startsWith(currentWord)) {
                            const val = jsGlobals[key];
                            let displayText = key;
                            let signature = "";
                            if (typeof val === "function") {
                                signature = parseFunctionSignature(val);
                                displayText = `${key}${signature}`;
                            }
                            topLevelSuggestions.push({
                                text: key,
                                displayText: displayText,
                                render: function (element, self, data) {
                                    const nameEl =
                                        document.createElement("span");
                                    nameEl.textContent = key;
                                    nameEl.style.fontWeight = "bold";
                                    element.appendChild(nameEl);
                                    if (signature) {
                                        const sigEl =
                                            document.createElement("span");
                                        sigEl.textContent = signature;
                                        sigEl.style.color = "#555";
                                        sigEl.style.marginLeft = "6px";
                                        element.appendChild(sigEl);
                                    }
                                },
                            });
                        }
                    }
                }
                const cmJsHintOptions = { ...options, globalVars: jsGlobals };
                let cmJsHintResult = CodeMirror.hint.javascript(
                    editor,
                    cmJsHintOptions
                );
                if (cmJsHintResult && cmJsHintResult.list.length > 0) {
                    const combinedList = [...topLevelSuggestions];
                    const topLevelTexts = new Set(
                        topLevelSuggestions.map((s) => s.text)
                    );

                    for (const cmHint of cmJsHintResult.list) {
                        const hintText =
                            typeof cmHint === "string" ? cmHint : cmHint.text;
                        if (!topLevelTexts.has(hintText)) {
                            if (typeof cmHint === "string") {
                                combinedList.push({
                                    text: cmHint,
                                    displayText: cmHint,
                                });
                            } else {
                                combinedList.push(cmHint);
                            }
                        }
                    }
                    cmJsHintResult.list = combinedList;
                    if (token.string.length > 0 && token.start < cursor.ch) {
                        cmJsHintResult.from = CodeMirror.Pos(
                            cursor.line,
                            token.start
                        );
                        cmJsHintResult.to = CodeMirror.Pos(
                            cursor.line,
                            token.end
                        );
                    }
                    return cmJsHintResult;
                } else if (topLevelSuggestions.length > 0) {
                    return {
                        list: topLevelSuggestions,
                        from: CodeMirror.Pos(cursor.line, token.start),
                        to: CodeMirror.Pos(cursor.line, token.end),
                    };
                }
                return cmJsHintResult;
            }

            const slashCommands = {
                search: {
                    func: (args) => {
                        if (args.length < 2) return "Usage: /search <query>";
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.search(query);
                    },
                    signature: "<query terms...>",
                    apiRef: "search",
                },
                select: {
                    func: (args) => {
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.selectEntries(query, false);
                    },
                    signature: "[query terms... (empty for all visible)]",
                    apiRef: "selectEntries",
                },
                selectappend: {
                    func: (args) => {
                        const query = args.slice(1).join(" ");
                        if (!query)
                            return "Usage: /selectappend <query terms...>";
                        return opentaggerAPI.selectEntries(query, true);
                    },
                    signature: "<query terms...>",
                    apiRef: "selectEntries",
                },
                filter: {
                    func: (args) => {
                        if (args.length < 2)
                            return "Usage: /filter <query terms...>";
                        const query = args.slice(1).join(" ");
                        return opentaggerAPI.filterSelectedEntries(query);
                    },
                    signature: "<query terms...>",
                    apiRef: "filterSelectedEntries",
                },
                deselectall: {
                    func: (args) => {
                        return opentaggerAPI.deselectAllEntries();
                    },
                    signature: "",
                    apiRef: "deselectAllEntries",
                },
                add: {
                    func: (args) => {
                        if (args.length < 2)
                            return "Usage: /add <tag1>, [tag2], ...";
                        const rawTagsString = args.slice(1).join(" ");
                        const tagsArray = parseRawTagInput(rawTagsString);
                        if (tagsArray.length === 0)
                            return "No valid tags provided.";
                        return opentaggerAPI.addTagsToSelected(tagsArray);
                    },
                    signature: "<tag1>, [tag2 with spaces], ...",
                    apiRef: "addTagsToSelected",
                },
                remove: {
                    func: (args) => {
                        if (args.length < 2)
                            return "Usage: /remove <tag1>, [tag2], ...";
                        const rawTagsString = args.slice(1).join(" ");
                        const tagsArray = parseRawTagInput(rawTagsString);
                        if (tagsArray.length === 0)
                            return "No valid tags provided.";
                        return opentaggerAPI.removeTagsFromSelected(tagsArray);
                    },
                    signature: "<tag1>, [tag2 with spaces], ...",
                    apiRef: "removeTagsFromSelected",
                },
                rename: {
                    func: (args) => {
                        let global = false;
                        const positionalArgs = [];
                        for (const arg of args.slice(1)) {
                            // Skip command name
                            if (arg.toLowerCase() === "--global=true") {
                                global = true;
                            } else {
                                positionalArgs.push(arg);
                            }
                        }

                        if (positionalArgs.length < 2) {
                            return "Usage: /rename <targetTag> <replaceValue> [--global=true]";
                        }

                        const targetTag = positionalArgs[0];
                        const replaceValue = positionalArgs[1];

                        return opentaggerAPI.rename({
                            targetTag,
                            replaceValue,
                            global,
                        });
                    },
                    signature: "<targetTag> <replaceValue> [--global=true]",
                    apiRef: "rename", // Used for hints, actual call is in func
                },
                count: {
                    func: (args) => {
                        if (args.length < 2)
                            return "Usage: /count <tag1>, [tag2], ...";
                        const rawTagsString = args.slice(1).join(" ");
                        const tagsArray = parseRawTagInput(rawTagsString);
                        if (tagsArray.length === 0)
                            return "No valid tags provided.";
                        return opentaggerAPI.count(tagsArray);
                    },
                    signature: "<tag1>, [tag2 with spaces], ...",
                    apiRef: "count", // Used for hints, actual call is in func
                },
                clear: {
                    func: (args) => {
                        return opentaggerAPI.clear();
                    },
                    signature: "",
                    apiRef: "clear",
                },
                help: {
                    func: (args) => {
                        return opentaggerAPI.help();
                    },
                    signature: "",
                    apiRef: "help",
                },
            };

            function getTagText(element) {
                const span = element.querySelector("span[contenteditable]");
                return span
                    ? span.textContent.trim()
                    : element.textContent.trim();
            }

            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            function parseFunctionSignature(func) {
                if (typeof func !== "function") {
                    return "";
                }
                const funcStr = func.toString();
                let paramsMatch = funcStr.match(
                    /^(?:async\s*)?(?:function(?:\s+\w*)?\s*\(|\((?!\))|\w+\s*=>\s*\()([^)]*)\)\s*=>|\)\s*{/
                );
                if (!paramsMatch) {
                    paramsMatch = funcStr.match(
                        /^(?:async\s*)?(?:\w+\s*=>|(\w+)\s*=>)/
                    );
                    if (paramsMatch && paramsMatch[1])
                        return `(${paramsMatch[1]})`;
                    if (funcStr.match(/^(?:async\s*)?\(\s*\)\s*=>/))
                        return "()";
                    return "";
                }
                let paramsStr = paramsMatch[1] || "";
                if (!paramsStr && funcStr.includes("() =>")) return "()";
                const params = [];
                let currentParam = "";
                let openBrackets = 0;
                let openParens = 0;
                for (let i = 0; i < paramsStr.length; i++) {
                    const char = paramsStr[i];
                    currentParam += char;
                    if (char === "{") openBrackets++;
                    else if (char === "}") openBrackets--;
                    else if (char === "(") openParens++;
                    else if (char === ")") openParens--;
                    else if (
                        char === "," &&
                        openBrackets === 0 &&
                        openParens === 0
                    ) {
                        params.push(currentParam.slice(0, -1).trim());
                        currentParam = "";
                    }
                }
                if (currentParam.trim()) {
                    params.push(currentParam.trim());
                }
                if (params.length === 0 && paramsStr.trim() !== "") {
                    params.push(paramsStr.trim());
                }
                const formattedParams = params.map((p) => {
                    let param = p.trim();
                    param = param.replace(/\/\*.*?\*\//g, "").trim();
                    if (param.includes("=")) {
                        const parts = param.split("=");
                        const name = parts[0].trim();
                        let defVal = parts.slice(1).join("=").trim();
                        if (defVal.startsWith("{") && defVal.endsWith("}"))
                            defVal = "{...}";
                        else if (defVal.startsWith("[") && defVal.endsWith("]"))
                            defVal = "[...]";
                        else if (defVal.length > 15) defVal = "...";
                        return `${name} = ${defVal}`;
                    }
                    return param;
                });

                return `(${formattedParams.join(", ")})`;
            }

            function sanitizeFilename(name) {
                if (!name || typeof name !== "string") return "untitled_image";
                const baseName = name.includes(".")
                    ? name.substring(0, name.lastIndexOf("."))
                    : name;
                const extension = name.includes(".")
                    ? name.substring(name.lastIndexOf("."))
                    : "";
                const sanitizedBase = baseName.replace(/[^a-zA-Z0-9_.-]/g, "_");
                const finalBase = sanitizedBase || "image";
                return finalBase + extension;
            }

            function getTagColor(tagText) {
                let hash = 0;
                for (let i = 0; i < tagText.length; i++) {
                    hash = tagText.charCodeAt(i) + ((hash << 5) - hash);
                    hash = hash & hash;
                }
                const hue = Math.abs(hash % 360);
                return `hsl(${hue}, 70%, 45%)`;
            }

            function createTimerLabelElement() {
                const label = document.createElement("span");
                label.className = "autotag-timer-label";
                label.textContent = "0.0s";
                return label;
            }

            function startTimer(updateCallback, intervalMs = 100) {
                const startTime = performance.now();
                const intervalId = setInterval(() => {
                    const elapsedMs = performance.now() - startTime;
                    updateCallback((elapsedMs / 1000).toFixed(1) + "s");
                }, intervalMs);
                return {
                    stop: () => {
                        clearInterval(intervalId);
                        const elapsedMs = performance.now() - startTime;
                        return elapsedMs / 1000;
                    },
                    getElapsedTime: () => {
                        const elapsedMs = performance.now() - startTime;
                        return (elapsedMs / 1000).toFixed(1) + "s";
                    },
                };
            }

            function evaluateExpression(expression, tags) {
                expression = expression.trim();
                if (expression === "") {
                    return false;
                }
                if (expression.toLowerCase() === "true") return true;
                if (expression.toLowerCase() === "false") return false;
                if (expression.startsWith("(") && expression.endsWith(")")) {
                    let balance = 0;
                    let fullyEnclosed = true;
                    for (let i = 0; i < expression.length - 1; i++) {
                        if (expression[i] === "(") balance++;
                        else if (expression[i] === ")") balance--;
                        if (balance === 0) {
                            fullyEnclosed = false;
                            break;
                        }
                    }
                    if (expression[expression.length - 1] === ")") balance--;
                    if (fullyEnclosed && balance === 0) {
                        const innerExpression = expression
                            .substring(1, expression.length - 1)
                            .trim();
                        if (innerExpression === "") return false;
                        return evaluateExpression(innerExpression, tags);
                    }
                }
                if (expression.startsWith("!")) {
                    const subExpression = expression.substring(1).trim();
                    return !evaluateExpression(subExpression, tags);
                }
                let balance = 0;
                for (let i = expression.length - 1; i >= 1; i--) {
                    if (expression[i] === ")") balance++;
                    else if (expression[i] === "(") balance--;
                    else if (
                        expression[i - 1] === "|" &&
                        expression[i] === "|" &&
                        balance === 0
                    ) {
                        const left = expression.substring(0, i - 1).trim();
                        const right = expression.substring(i + 1).trim();
                        return (
                            evaluateExpression(left || "false", tags) ||
                            evaluateExpression(right || "false", tags)
                        );
                    }
                }
                balance = 0;
                for (let i = expression.length - 1; i >= 1; i--) {
                    if (expression[i] === ")") balance++;
                    else if (expression[i] === "(") balance--;
                    else if (
                        expression[i - 1] === "&" &&
                        expression[i] === "&" &&
                        balance === 0
                    ) {
                        const left = expression.substring(0, i - 1).trim();
                        const right = expression.substring(i + 1).trim();
                        return (
                            evaluateExpression(left || "true", tags) &&
                            evaluateExpression(right || "true", tags)
                        );
                    }
                }
                const term = expression.toLowerCase();
                return tags.some((tag) => tag.toLowerCase().includes(term));
            }

            function getQueryLeafTerms(expression) {
                const terms = new Set();
                const termExtractionRegex = /(?:[^\s()&|!]+|"[^"]*")+/g;
                let match;
                while (
                    (match = termExtractionRegex.exec(expression)) !== null
                ) {
                    const term = match[0].replace(/^"|"$/g, "").toLowerCase();
                    if (term && term !== "true" && term !== "false") {
                        if (!/^[&|!]+$/.test(term) && term.length > 0) {
                            terms.add(term);
                        }
                    } else if (
                        (term === "true" || term === "false") &&
                        match[0].startsWith('"')
                    ) {
                        terms.add(term);
                    }
                }
                return Array.from(terms).sort();
            }

            function parseRawTagInput(rawText) {
                if (typeof rawText !== "string") return [];
                const segments = rawText.split(/(?<!\\),/g);
                return segments
                    .map((segment) => {
                        const tempPlaceholder = "##TEMP_BACKSLASH##";
                        return segment
                            .replace(/\\\\/g, tempPlaceholder)
                            .replace(/\\,/g, ",")
                            .replace(
                                new RegExp(
                                    tempPlaceholder.replace(
                                        /[.*+?^${}()|[\]\\]/g,
                                        "\\$&"
                                    ),
                                    "g"
                                ),
                                "\\"
                            )
                            .trim();
                    })
                    .filter((tagText) => tagText.length > 0);
            }

            /**
             * Generates submenu items for adding group tags to selected entries.
             * @param {Array<DatasetEntry>} targetEntries - The array of entries the action will apply to.
             * @returns {Array<Object>} Menu item definitions.
             */
            function getGroupSubmenuItems(targetEntries) {
                const cats = document.querySelectorAll(
                    "#tag-group-list tag-group"
                );
                const items = [];
                const targetCount = targetEntries.length;

                for (const cat of cats) {
                    const name = cat.getAttribute("group-name") || "...";
                    const tags = cat.getGroupTags();
                    if (tags.length > 0)
                        items.push({
                            label: `Add All from "${name}"`,
                            callback: () => {
                                for (const entry of targetEntries) {
                                    for (const tag of tags) {
                                        entry.addTag(tag);
                                    }
                                }
                            },
                        });
                }
                if (items.length === 0)
                    items.push({
                        label: "(No groups with tags)",
                        callback: null,
                        disabled: true,
                    });
                return items;
            }

            class AutocompleteDropdown extends HTMLElement {
                constructor() {
                    super();
                    this._targetElement = null;
                    this._suggestions = [];
                    this._selectedIndex = -1;
                    this._boundHandleDocumentClick =
                        this._handleDocumentClick.bind(this);
                    this._boundHandleKeyDownPassthrough =
                        this._handleKeyDownPassthrough.bind(this);
                }

                show(suggestions, targetElement) {
                    this._targetElement = targetElement;
                    this._suggestions = suggestions;
                    this._selectedIndex = -1;
                    this.innerHTML = "";

                    if (
                        !this._targetElement ||
                        !this._suggestions ||
                        this._suggestions.length === 0
                    ) {
                        this.hide();
                        return;
                    }

                    this._suggestions.forEach((suggestion, index) => {
                        const item = document.createElement("div");
                        item.classList.add("suggestion-item");
                        item.dataset.index = index;

                        const nameSpan = document.createElement("span");
                        nameSpan.classList.add("tag-name");
                        nameSpan.textContent = suggestion.name;
                        item.appendChild(nameSpan);

                        const countSpan = document.createElement("span");
                        countSpan.classList.add("tag-count");
                        countSpan.textContent = `(${suggestion.count.toLocaleString()})`;
                        item.appendChild(countSpan);

                        item.addEventListener("mousedown", (e) => {
                            e.preventDefault();
                            this._selectItem(index);
                        });
                        this.appendChild(item);
                    });

                    // --- Positioning Logic ---
                    const currentTargetRect =
                        this._targetElement.getBoundingClientRect();
                    const dropdown = this;

                    // Set minWidth based on target before measuring dropdown.
                    // The dropdown has `box-sizing: border-box` due to global `*` rule.
                    dropdown.style.minWidth = `${currentTargetRect.width}px`;

                    // Temporarily make it visible for measurement, but out of sight.
                    dropdown.style.visibility = "hidden";
                    dropdown.style.position = "absolute"; // Ensure it's absolute for correct measurement context
                    dropdown.style.display = "flex"; // Apply styles that affect size (from .visible class)
                    dropdown.style.left = "-9999px"; // Move off-screen
                    dropdown.style.top = "-9999px";

                    // Get actual dimensions of the dropdown
                    const dropdownMeasuredRect =
                        dropdown.getBoundingClientRect();
                    const dropdownWidth = dropdownMeasuredRect.width;
                    const dropdownHeight = dropdownMeasuredRect.height;

                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const margin = 5; // Small margin from viewport edges
                    const verticalOffset = 2; // Small offset from the target element

                    let finalTopViewportRelative, finalLeftViewportRelative;

                    // Determine vertical position
                    // Candidate 1: Below target (preferred)
                    let topIfBelow = currentTargetRect.bottom + verticalOffset;
                    let fitsBelow =
                        topIfBelow + dropdownHeight + margin <= viewportHeight;

                    // Candidate 2: Above target
                    let topIfAbove =
                        currentTargetRect.top - dropdownHeight - verticalOffset;
                    let fitsAbove = topIfAbove >= margin; // Check against top margin

                    if (fitsBelow) {
                        finalTopViewportRelative = topIfBelow;
                    } else if (fitsAbove) {
                        finalTopViewportRelative = topIfAbove;
                    } else {
                        // Neither fits perfectly. Choose based on which has more space or is less clipped.
                        // If target is more in top half of screen, prefer showing below (even if clamped).
                        // If target is more in bottom half, prefer showing above (even if clamped).
                        if (currentTargetRect.top < viewportHeight / 2) {
                            finalTopViewportRelative = topIfBelow;
                        } else {
                            finalTopViewportRelative = topIfAbove;
                        }
                        // Alternative for when neither fits: check which would be less clipped.
                        // const overflowBelowAmount = Math.max(0, (topIfBelow + dropdownHeight + margin) - viewportHeight);
                        // const overflowAboveAmount = Math.max(0, margin - topIfAbove);
                        // if (overflowBelowAmount <= overflowAboveAmount) {
                        //    finalTopViewportRelative = topIfBelow;
                        // } else {
                        //    finalTopViewportRelative = topIfAbove;
                        // }
                    }

                    // Determine horizontal position
                    finalLeftViewportRelative = currentTargetRect.left; // Default: align left edges
                    if (
                        finalLeftViewportRelative + dropdownWidth + margin >
                        viewportWidth
                    ) {
                        // Overflowing right, try aligning to target's right edge
                        finalLeftViewportRelative =
                            currentTargetRect.right - dropdownWidth;
                        // If aligning to target's right still makes it overflow left (e.g. target wider than dropdown and near left edge)
                        // or if dropdown is wider than target and aligning target's right pushes it left:
                        if (finalLeftViewportRelative < margin) {
                            finalLeftViewportRelative =
                                viewportWidth - dropdownWidth - margin; // Align to viewport's right edge
                        }
                    }
                    // Ensure it doesn't overflow left edge of viewport
                    if (finalLeftViewportRelative < margin) {
                        finalLeftViewportRelative = margin;
                    }

                    // Final clamping to ensure it's strictly within viewport boundaries (accounts for extreme cases)
                    finalTopViewportRelative = Math.max(
                        margin,
                        Math.min(
                            finalTopViewportRelative,
                            viewportHeight - dropdownHeight - margin
                        )
                    );
                    finalLeftViewportRelative = Math.max(
                        margin,
                        Math.min(
                            finalLeftViewportRelative,
                            viewportWidth - dropdownWidth - margin
                        )
                    );

                    // Convert viewport-relative coordinates to document-relative for absolute positioning
                    // (since the dropdown is a child of body or similarly high-level container)
                    dropdown.style.top = `${
                        finalTopViewportRelative + window.scrollY
                    }px`;
                    dropdown.style.left = `${
                        finalLeftViewportRelative + window.scrollX
                    }px`;

                    // minWidth was already set for measurement. If CSS has a stronger min-width (e.g., 150px),
                    // dropdownWidth would have reflected that.
                    // If you want to ensure it's NOT NARROWER than the target, the previous style.minWidth handles it.
                    // If you want it not wider than target (unless content dictates), that's harder.
                    // Current logic: it's at least target.width, or its own content width, or css min-width, whichever is largest.

                    // Make it truly visible at the calculated position
                    dropdown.style.visibility = "visible";
                    dropdown.classList.add("visible"); // This also ensures display:flex

                    // --- End Positioning Logic ---

                    setTimeout(() => {
                        document.addEventListener(
                            "click",
                            this._boundHandleDocumentClick,
                            true
                        );
                    }, 0);

                    if (
                        this._targetElement &&
                        typeof this._targetElement.addEventListener ===
                            "function"
                    ) {
                        this._targetElement.addEventListener(
                            "keydown",
                            this._boundHandleKeyDownPassthrough,
                            true
                        );
                    }

                    if (
                        this._suggestions.length > 0 &&
                        this._selectedIndex === -1
                    ) {
                        // Select first item if none selected
                        this._selectedIndex = 0;
                        this._updateSelectionVisuals();
                    }
                }

                hide() {
                    if (!this.classList.contains("visible")) return;

                    this.classList.remove("visible");
                    this.style.visibility = "hidden"; // Ensure it's hidden
                    this.style.display = "none"; // And not taking up space

                    document.removeEventListener(
                        "click",
                        this._boundHandleDocumentClick,
                        true
                    );

                    if (
                        this._targetElement &&
                        typeof this._targetElement.removeEventListener ===
                            "function"
                    ) {
                        this._targetElement.removeEventListener(
                            "keydown",
                            this._boundHandleKeyDownPassthrough,
                            true
                        );
                    }
                    // Don't nullify _targetElement here if hide can be called temporarily during complex interactions.
                    // However, for a typical hide, it's fine. If a new `show` call happens, _targetElement gets reset.
                    // this._targetElement = null;
                    this.dispatchEvent(new CustomEvent("dropdown-hidden"));
                }

                _handleDocumentClick(event) {
                    if (
                        !this.contains(event.target) &&
                        event.target !== this._targetElement
                    ) {
                        this.hide();
                    }
                }

                _handleKeyDownPassthrough(event) {
                    if (!this.classList.contains("visible")) return;

                    switch (event.key) {
                        case "ArrowUp":
                            event.preventDefault();
                            event.stopPropagation();
                            this._navigate(-1);
                            break;
                        case "ArrowDown":
                            event.preventDefault();
                            event.stopPropagation();
                            this._navigate(1);
                            break;
                        case "Enter":
                        case "Tab":
                            if (this._selectedIndex !== -1) {
                                event.preventDefault();
                                event.stopPropagation();
                                this._selectItem(this._selectedIndex);
                            } else {
                                // If no item is selected but dropdown is open, Enter/Tab might mean "accept current input text"
                                // This is handled by the input's blur/keydown. Here, just hide.
                                this.hide();
                            }
                            break;
                        case "Escape":
                            event.preventDefault();
                            event.stopPropagation();
                            this.hide();
                            // Dispatch an event so the DatasetTag can know Escape was pressed while dropdown was open
                            this.dispatchEvent(
                                new CustomEvent("dropdown-escaped", {
                                    bubbles: true,
                                    composed: true,
                                })
                            );
                            break;
                    }
                }

                _navigate(direction) {
                    if (this._suggestions.length === 0) return;
                    const newIndex = this._selectedIndex + direction;
                    if (newIndex >= 0 && newIndex < this._suggestions.length) {
                        this._selectedIndex = newIndex;
                    } else if (newIndex < 0) {
                        // Wrap around to last item or stay at first
                        this._selectedIndex = this._suggestions.length - 1; // Or 0 to not wrap
                    } else if (newIndex >= this._suggestions.length) {
                        // Wrap around to first item or stay at last
                        this._selectedIndex = 0; // Or this._suggestions.length - 1 to not wrap
                    }
                    this._updateSelectionVisuals();
                }

                _updateSelectionVisuals() {
                    this.querySelectorAll(".suggestion-item").forEach(
                        (item, idx) => {
                            if (idx === this._selectedIndex) {
                                item.classList.add("selected");
                                // Ensure the selected item is visible within the scrollable dropdown
                                item.scrollIntoView({
                                    block: "nearest",
                                    inline: "nearest",
                                });
                            } else {
                                item.classList.remove("selected");
                            }
                        }
                    );
                }

                _selectItem(index) {
                    if (index >= 0 && index < this._suggestions.length) {
                        const selectedSuggestion = this._suggestions[index];
                        // Let the DatasetTag (or other listener) handle the selected suggestion
                        this.dispatchEvent(
                            new CustomEvent("suggestion-selected", {
                                detail: selectedSuggestion,
                            })
                        );
                        this.hide();
                    }
                }
            }
            customElements.define(
                "autocomplete-dropdown",
                AutocompleteDropdown
            );

            class DatasetTag extends HTMLElement {
                constructor() {
                    super();
                    this._boundHandleDeleteClick =
                        this._handleDeleteClick.bind(this);
                    this._boundHandleDeleteMouseDown =
                        this._handleDeleteMouseDown.bind(this);
                    this._boundHandleSpanDblClick =
                        this._handleSpanDblClick.bind(this);
                    this._boundHandleSpanKeyDown =
                        this._handleSpanKeyDown.bind(this);
                    this._boundHandleSpanBlur = this._handleSpanBlur.bind(this);
                    this._boundHandleDragStart =
                        this._handleDragStart.bind(this);
                    this._boundHandleDragEnd = this._handleDragEnd.bind(this);
                    this._boundHandleContextMenu =
                        this._handleContextMenu.bind(this);
                    this._originalText = "";

                    // For autocomplete
                    this._boundHandleAutocompleteSelection =
                        this._handleAutocompleteSelection.bind(this);
                    this._boundHandleAutocompleteEscape =
                        this._handleAutocompleteEscape.bind(this);
                    this._boundHandleSpanInput =
                        this._handleSpanInput.bind(this);
                    this._debouncedHandleSpanInput = debounce(
                        this._boundHandleSpanInput,
                        200
                    ); // Debounce input for suggestions
                }
                connectedCallback() {
                    let initialText = "";
                    const existingSpan = this.querySelector(
                        "span[contenteditable]"
                    );
                    if (existingSpan) {
                        initialText = existingSpan.textContent.trim();
                    } else {
                        initialText = this.textContent.trim();
                    }
                    this._originalText = initialText || "empty_tag";
                    this.innerHTML = "";
                    this.draggable = true;
                    const span = document.createElement("span");
                    span.setAttribute("contenteditable", "false");
                    span.setAttribute("translate", "no");
                    span.textContent = this._originalText;
                    const button = document.createElement("button");
                    button.classList.add("delete-tag", "material-icons");
                    button.speaker = "Delete Tag";
                    button.textContent = "close";

                    this.appendChild(span);
                    this.appendChild(button);
                    this.addEventListeners();
                }
                disconnectedCallback() {
                    this.removeEventListeners();
                    if (
                        globalTagAutocompleteDropdown &&
                        globalTagAutocompleteDropdown.classList.contains(
                            "visible"
                        ) &&
                        globalTagAutocompleteDropdown._targetElement ===
                            this.querySelector("span")
                    ) {
                        globalTagAutocompleteDropdown.hide();
                    }
                }
                addEventListeners() {
                    const d = this.querySelector(".delete-tag");
                    const s = this.querySelector("span[contenteditable]");
                    if (d) {
                        d.addEventListener(
                            "click",
                            this._boundHandleDeleteClick
                        );
                        d.addEventListener(
                            "mousedown",
                            this._boundHandleDeleteMouseDown
                        );
                    }
                    if (s) {
                        s.addEventListener(
                            "dblclick",
                            this._boundHandleSpanDblClick
                        );
                        s.addEventListener(
                            "keydown",
                            this._boundHandleSpanKeyDown
                        );
                        s.addEventListener("blur", this._boundHandleSpanBlur);
                        s.addEventListener(
                            "input",
                            this._debouncedHandleSpanInput
                        ); // Use debounced handler
                    }
                    this.addEventListener(
                        "dragstart",
                        this._boundHandleDragStart
                    );
                    this.addEventListener("dragend", this._boundHandleDragEnd);
                    this.addEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );

                    if (globalTagAutocompleteDropdown) {
                        globalTagAutocompleteDropdown.addEventListener(
                            "suggestion-selected",
                            this._boundHandleAutocompleteSelection
                        );
                        globalTagAutocompleteDropdown.addEventListener(
                            "dropdown-escaped",
                            this._boundHandleAutocompleteEscape
                        );
                    }
                }
                removeEventListeners() {
                    const d = this.querySelector(".delete-tag");
                    const s = this.querySelector("span[contenteditable]");
                    if (d) {
                        d.removeEventListener(
                            "click",
                            this._boundHandleDeleteClick
                        );
                        d.removeEventListener(
                            "mousedown",
                            this._boundHandleDeleteMouseDown
                        );
                    }
                    if (s) {
                        s.removeEventListener(
                            "dblclick",
                            this._boundHandleSpanDblClick
                        );
                        s.removeEventListener(
                            "keydown",
                            this._boundHandleSpanKeyDown
                        );
                        s.removeEventListener(
                            "blur",
                            this._boundHandleSpanBlur
                        );
                        s.removeEventListener(
                            "input",
                            this._debouncedHandleSpanInput
                        );
                    }
                    this.removeEventListener(
                        "dragstart",
                        this._boundHandleDragStart
                    );
                    this.removeEventListener(
                        "dragend",
                        this._boundHandleDragEnd
                    );
                    this.removeEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );
                    if (globalTagAutocompleteDropdown) {
                        globalTagAutocompleteDropdown.removeEventListener(
                            "suggestion-selected",
                            this._boundHandleAutocompleteSelection
                        );
                        globalTagAutocompleteDropdown.removeEventListener(
                            "dropdown-escaped",
                            this._boundHandleAutocompleteEscape
                        );
                    }
                }

                _handleSpanDblClick(e) {
                    e.stopPropagation();
                    const span = e.target;
                    this._originalText = getTagText(this);
                    span.contentEditable = "true";
                    span.focus();
                    window.getSelection().selectAllChildren(span);
                }

                _handleSpanInput(e) {
                    const span = e.target;
                    if (
                        span.contentEditable !== "true" ||
                        !globalTagAutocompleteDropdown ||
                        booruTags.length === 0
                    ) {
                        globalTagAutocompleteDropdown?.hide();
                        return;
                    }

                    const inputText = span.textContent.trim().toLowerCase();
                    if (inputText.length < 1) {
                        globalTagAutocompleteDropdown.hide();
                        return;
                    }

                    const matchedTags = booruTags
                        .filter((tag) =>
                            tag.name.toLowerCase().startsWith(inputText)
                        )
                        // .sort((a, b) => b.count - a.count) // Tags are already pre-sorted by count
                        .slice(0, MAX_SUGGESTIONS);

                    if (matchedTags.length > 0) {
                        // Pass the span itself as the target for positioning
                        globalTagAutocompleteDropdown.show(matchedTags, span);
                    } else {
                        globalTagAutocompleteDropdown.hide();
                    }
                }

                _handleSpanKeyDown(e) {
                    const span = e.target;
                    if (span.contentEditable === "true") {
                        if (
                            globalTagAutocompleteDropdown &&
                            globalTagAutocompleteDropdown.classList.contains(
                                "visible"
                            ) &&
                            e.defaultPrevented
                        ) {
                            // Autocomplete handled the key (Up, Down, Enter, Esc, Tab)
                            return;
                        }

                        // If autocomplete is NOT visible, or it is visible but didn't handle the key
                        if (e.key === "Enter") {
                            e.preventDefault();
                            globalTagAutocompleteDropdown.hide();
                            span.blur();
                        } else if (e.key === "Escape") {
                            e.preventDefault();
                            globalTagAutocompleteDropdown.hide();
                            span.textContent = this._originalText;
                            span.blur();
                        }
                    }
                }

                _handleSpanBlur(e) {
                    const span = e.target;
                    if (!this.isConnected) return;

                    setTimeout(() => {
                        if (span.contentEditable === "false") {
                            // Already finalized by autocomplete selection or escape
                            return;
                        }

                        globalTagAutocompleteDropdown.hide();

                        span.contentEditable = "false";
                        const newRawText = span.textContent;

                        if (newRawText === this._originalText) {
                            span.textContent =
                                this._originalText || "empty_tag";
                            return;
                        }
                        this._processEditedText(newRawText);
                    }, 50);
                }

                _handleAutocompleteSelection(e) {
                    // Check if this event is relevant to this specific tag instance
                    const span = this.querySelector(
                        "span[contenteditable='true']"
                    );
                    if (
                        span &&
                        globalTagAutocompleteDropdown._targetElement === span &&
                        e.target === globalTagAutocompleteDropdown
                    ) {
                        const selectedTag = e.detail;
                        span.textContent = selectedTag.name;

                        span.contentEditable = "false";
                        // globalTagAutocompleteDropdown.hide(); // Already hidden by dropdown's _selectItem

                        const range = document.createRange();
                        const sel = window.getSelection();
                        range.selectNodeContents(span);
                        range.collapse(false);
                        sel.removeAllRanges();
                        sel.addRange(range);

                        this._processEditedText(span.textContent);
                    }
                }

                _handleAutocompleteEscape(e) {
                    const span = this.querySelector(
                        "span[contenteditable='true']"
                    );
                    // Check if this event is relevant to this specific tag instance
                    if (
                        span &&
                        globalTagAutocompleteDropdown._targetElement === span &&
                        e.target === globalTagAutocompleteDropdown
                    ) {
                        span.textContent = this._originalText;
                        span.contentEditable = "false";
                        // globalTagAutocompleteDropdown.hide(); // Already hidden by dropdown's Escape handler
                    }
                }

                _handleDeleteClick(e) {
                    e.stopPropagation();
                    const parentTagList = this.closest("tag-list");
                    this.remove();
                    if (parentTagList) {
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }
                _handleDeleteMouseDown(e) {
                    e.stopPropagation();
                }

                _processEditedText(rawText) {
                    const finalTagTexts = parseRawTagInput(rawText);
                    const parentTagList = this.closest("tag-list");
                    const span = this.querySelector("span[contenteditable]");
                    if (span) {
                        span.setAttribute("translate", "no");
                    }

                    if (!parentTagList) {
                        const span = this.querySelector(
                            "span[contenteditable]"
                        );
                        if (finalTagTexts.length === 1) {
                            const newText = finalTagTexts[0];
                            if (newText !== this._originalText) {
                                span.textContent = newText;
                                this._originalText = newText;
                                this.dispatchEvent(
                                    new CustomEvent("tag-updated", {
                                        bubbles: true,
                                        composed: true,
                                    })
                                );
                            } else {
                                span.textContent =
                                    this._originalText || "empty_tag";
                            }
                        } else if (finalTagTexts.length === 0) {
                            if (this.parentElement) this.remove();
                            else
                                span.textContent =
                                    this._originalText || "empty_tag";
                        } else {
                            // Multiple tags entered, keep first in this tag, add others to list (if applicable)
                            const firstTagText = finalTagTexts[0];
                            let originalTextChanged =
                                firstTagText !== this._originalText;
                            span.textContent = firstTagText;
                            this._originalText = firstTagText;
                            if (originalTextChanged) {
                                this.dispatchEvent(
                                    new CustomEvent("tag-updated", {
                                        bubbles: true,
                                        composed: true,
                                    })
                                );
                            }
                        }
                        return;
                    }

                    let changeOccurred = false;

                    if (finalTagTexts.length === 0) {
                        this.remove();
                        changeOccurred = true;
                    } else if (finalTagTexts.length === 1) {
                        const newText = finalTagTexts[0];
                        if (newText === this._originalText) {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = this._originalText;
                            return; // No actual change
                        }

                        let isDuplicateOfSibling = false;
                        const siblings = Array.from(
                            parentTagList.querySelectorAll("dataset-tag")
                        );
                        for (const sibling of siblings) {
                            if (
                                sibling !== this &&
                                getTagText(sibling).toLowerCase() ===
                                    newText.toLowerCase()
                            ) {
                                isDuplicateOfSibling = true;
                                break;
                            }
                        }

                        if (isDuplicateOfSibling) {
                            this.remove(); // Remove this tag as it's now a duplicate
                        } else {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = newText;
                            this._originalText = newText;
                        }
                        changeOccurred = true;
                    } else {
                        // Multiple tags entered via editing one
                        const firstTagText = finalTagTexts.shift(); // Take the first for the current tag

                        let isFirstDuplicateOfSibling = false;
                        const siblings = Array.from(
                            parentTagList.querySelectorAll("dataset-tag")
                        );
                        for (const sibling of siblings) {
                            if (
                                sibling !== this &&
                                getTagText(sibling).toLowerCase() ===
                                    firstTagText.toLowerCase()
                            ) {
                                isFirstDuplicateOfSibling = true;
                                break;
                            }
                        }

                        if (isFirstDuplicateOfSibling) {
                            this.remove(); // Current tag becomes a duplicate, remove it
                        } else {
                            this.querySelector(
                                "span[contenteditable]"
                            ).textContent = firstTagText;
                            this._originalText = firstTagText;
                        }

                        // Add the rest as new tags to the list
                        for (const text of finalTagTexts) {
                            parentTagList.addTag(text); // addTag handles its own duplication checks within the list
                        }
                        changeOccurred = true;
                    }

                    if (changeOccurred && parentTagList.isConnected) {
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        parentTagList.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }

                _handleDragStart(e) {
                    const s = this.querySelector("span[contenteditable]");
                    if (s && s.contentEditable === "true") {
                        e.preventDefault();
                        return;
                    }
                    if (e.target instanceof DatasetTag) {
                        const t = getTagText(this);
                        draggedElement = this;
                        e.dataTransfer.setData("text/plain", t);
                        e.dataTransfer.effectAllowed = "copyMove";
                        e.target.classList.add("dragging");
                    } else {
                        e.preventDefault();
                    }
                }
                _handleDragEnd(e) {
                    if (
                        e.target instanceof DatasetTag &&
                        e.target.classList.contains("dragging")
                    ) {
                        e.target.classList.remove("dragging");
                    }
                    if (draggedElement === e.target) {
                        draggedElement = null;
                    }
                }

                _handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const tagText = getTagText(this);
                    const isInGroup = !!this.closest("tag-group");
                    const selectedCount =
                        opentaggerAPI.getSelectedEntries().length;

                    const items = [
                        {
                            label: `Add "${tagText}" to Selection (${selectedCount})`,
                            callback: () => {
                                const resultMsg =
                                    opentaggerAPI.addTagsToSelected([tagText]);
                                logToConsole(resultMsg, "info");
                            },
                            disabled: () => selectedCount === 0,
                        },
                        {
                            label: `Remove "${tagText}" from Selection (${selectedCount})`,
                            callback: () => {
                                const resultMsg =
                                    opentaggerAPI.removeTagsFromSelected([
                                        tagText,
                                    ]);
                                logToConsole(resultMsg, "info");
                            },
                            disabled: () => selectedCount === 0,
                        },
                        { type: "divider" },
                        {
                            label: "Edit Tag (Double Click)",
                            callback: null,
                            disabled: true,
                        },
                        {
                            label: "Delete Tag",
                            callback: () => this._handleDeleteClick(e),
                        },
                    ];

                    createContextMenu(items, e);
                }

                setHighlight(color) {
                    this.style.setProperty("--highlight-border-color", color);
                    this.classList.add("searched-highlight");
                }
                clearHighlight() {
                    this.classList.remove("searched-highlight");
                    this.style.removeProperty("--highlight-border-color");
                    this.style.order = "";
                }
            }
            customElements.define("dataset-tag", DatasetTag);

            class TagList extends HTMLElement {
                constructor() {
                    super();
                    this.addTagButtonElement = null;
                    this.addTagInputElement = null;
                    this.isEditingNewTag = false;
                    this._boundHandleAddTagButtonClick =
                        this._handleAddTagButtonClick.bind(this);
                    this._boundHandleAddTagInputKeyDown =
                        this._handleAddTagInputKeyDown.bind(this);
                    this._boundHandleAddTagInputBlur =
                        this._handleAddTagInputBlur.bind(this);
                }
                static observedAttributes = ["direction"];
                connectedCallback() {
                    this.setDirection();
                    this.addEventListeners();
                    if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }
                }
                disconnectedCallback() {
                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.removeEventListener(
                            "click",
                            this._boundHandleAddTagButtonClick
                        );
                    }
                    if (this.addTagInputElement) {
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }
                    this.isEditingNewTag = false;
                }
                attributeChangedCallback(name, oldValue, newValue) {
                    if (name === "direction") {
                        this.setDirection();
                    }
                }
                _createAddTagButton() {
                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.appendChild(this.addTagButtonElement);
                        return;
                    }
                    this.addTagButtonElement = document.createElement("button");
                    this.addTagButtonElement.className = "add-tag-button";
                    this.addTagButtonElement.type = "button";
                    this.addTagButtonElement.title = "Add a new tag";
                    const icon = document.createElement("span");
                    icon.className = "material-icons";
                    icon.textContent = "add_circle_outline";
                    this.addTagButtonElement.appendChild(icon);
                    this.addTagButtonElement.addEventListener(
                        "click",
                        this._boundHandleAddTagButtonClick
                    );
                    this.appendChild(this.addTagButtonElement);
                }
                _handleAddTagButtonClick(event) {
                    event.stopPropagation();
                    if (this.isEditingNewTag || !this.addTagButtonElement) {
                        return;
                    }
                    this.isEditingNewTag = true;
                    this.addTagButtonElement.style.display = "none";
                    this.addTagInputElement = document.createElement("span");
                    this.addTagInputElement.setAttribute(
                        "contenteditable",
                        "true"
                    );
                    this.addTagInputElement.className = "add-tag-input";
                    this.insertBefore(
                        this.addTagInputElement,
                        this.addTagButtonElement
                    );
                    this.addTagInputElement.addEventListener(
                        "keydown",
                        this._boundHandleAddTagInputKeyDown
                    );
                    this.addTagInputElement.addEventListener(
                        "blur",
                        this._boundHandleAddTagInputBlur
                    );
                    requestAnimationFrame(() => {
                        this.addTagInputElement.focus();

                        window
                            .getSelection()
                            .selectAllChildren(this.addTagInputElement);
                    });
                }
                _handleAddTagInputKeyDown(event) {
                    if (!this.isEditingNewTag || !this.addTagInputElement)
                        return;
                    if (event.key === "Enter") {
                        event.preventDefault();
                        this.addTagInputElement.blur();
                    } else if (event.key === "Escape") {
                        event.preventDefault();
                        this._revertAddTagButtonToPlaceholder(false);
                    }
                }
                _handleAddTagInputBlur() {
                    if (!this.isEditingNewTag || !this.addTagInputElement)
                        return;

                    queueMicrotask(() => {
                        if (!this.isEditingNewTag || !this.addTagInputElement)
                            return;
                        this._revertAddTagButtonToPlaceholder(true);
                    });
                }
                _revertAddTagButtonToPlaceholder(shouldProcessTags = false) {
                    if (!this.isEditingNewTag && !this.addTagInputElement) {
                        if (
                            this.addTagButtonElement &&
                            this.closest("dataset-entry")
                        ) {
                            this.addTagButtonElement.style.display = "";
                        }
                        return;
                    }

                    let rawInputText = "";
                    if (this.addTagInputElement) {
                        rawInputText = this.addTagInputElement.textContent;
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }

                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.style.display = "";

                        if (this.contains(this.addTagButtonElement)) {
                            this.appendChild(this.addTagButtonElement);
                        } else if (this.closest("dataset-entry")) {
                            this._createAddTagButton();
                        }
                    } else if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }

                    this.isEditingNewTag = false;

                    if (shouldProcessTags && rawInputText.trim()) {
                        const finalTagTexts = parseRawTagInput(rawInputText);
                        for (const tagText of finalTagTexts) {
                            this.addTag(tagText);
                        }
                    }
                }

                setDirection() {
                    const d = this.getAttribute("direction") || "row";
                    this.style.flexDirection = d;
                    this.style.alignItems =
                        d === "column" ? "flex-start" : "center";
                    this.style.flexWrap = d === "column" ? "nowrap" : "wrap";
                }
                addEventListeners() {
                    this.addEventListener("dragover", (e) => {
                        if (
                            !draggedElement ||
                            draggedElement.tagName !== "DATASET-TAG"
                        ) {
                            return;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        if (
                            draggedElement.closest("tag-list") !== this ||
                            this.contains(draggedElement)
                        ) {
                            e.dataTransfer.dropEffect =
                                this.determineDropEffect(draggedElement);
                            this.classList.add("drag-over");
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });
                    this.addEventListener("dragleave", (e) => {
                        if (
                            draggedElement &&
                            draggedElement.tagName === "DATASET-TAG"
                        ) {
                            const r = this.getBoundingClientRect();

                            if (
                                !this.contains(e.relatedTarget) ||
                                e.clientX < r.left ||
                                e.clientX >= r.right ||
                                e.clientY < r.top ||
                                e.clientY >= r.bottom
                            ) {
                                this.classList.remove("drag-over");
                            }
                        }
                    });
                    this.addEventListener("drop", (e) => {
                        if (
                            !draggedElement ||
                            draggedElement.tagName !== "DATASET-TAG"
                        )
                            return;
                        e.preventDefault();
                        e.stopPropagation();
                        this.classList.remove("drag-over");

                        const tagText = e.dataTransfer.getData("text/plain");
                        if (!tagText) return;

                        const amInDatasetEntry =
                            !!this.closest("dataset-entry");
                        const selectedEntries =
                            opentaggerAPI.getSelectedEntries();
                        const sourceList = draggedElement.closest("tag-list");
                        const isSourceGroup =
                            !!draggedElement.closest("tag-group");

                        let eventHandledBySelection = false;

                        if (
                            amInDatasetEntry &&
                            selectedEntries.length > 0 &&
                            (isSourceGroup ||
                                (sourceList && sourceList !== this))
                        ) {
                            let anyTagAddedToSelection = false;
                            for (const entry of selectedEntries) {
                                if (entry.addTag(tagText)) {
                                    anyTagAddedToSelection = true;
                                }
                            }
                            eventHandledBySelection = true;
                        }

                        if (!eventHandledBySelection || sourceList === this) {
                            const effect =
                                this.determineDropEffect(draggedElement);
                            const dropTargetUiElement = this.findDropTarget(
                                e.clientX,
                                e.clientY
                            );

                            if (
                                this.addTagButtonElement &&
                                (e.target === this.addTagButtonElement ||
                                    this.addTagButtonElement.contains(e.target))
                            )
                                return;
                            if (
                                this.addTagInputElement &&
                                (e.target === this.addTagInputElement ||
                                    this.addTagInputElement.contains(e.target))
                            )
                                return;

                            let actionPerformedLocally = false;
                            if (effect === "copy") {
                                if (this.addTag(tagText)) {
                                    const newTag = Array.from(
                                        this.querySelectorAll("dataset-tag")
                                    ).find((t) => getTagText(t) === tagText);
                                    if (
                                        newTag &&
                                        dropTargetUiElement &&
                                        (!this.addTagButtonElement ||
                                            dropTargetUiElement !==
                                                this.addTagButtonElement)
                                    ) {
                                        this.insertBefore(
                                            newTag,
                                            dropTargetUiElement
                                        );
                                    }
                                    actionPerformedLocally = true;
                                }
                            } else if (effect === "move") {
                                if (
                                    draggedElement.parentElement === this &&
                                    dropTargetUiElement !==
                                        draggedElement.nextElementSibling
                                ) {
                                    this.insertBefore(
                                        draggedElement,
                                        dropTargetUiElement
                                    );
                                    actionPerformedLocally = true;
                                }
                            }

                            if (
                                actionPerformedLocally &&
                                !eventHandledBySelection
                            ) {
                                this.dispatchEvent(
                                    new CustomEvent("tag-updated", {
                                        bubbles: true,
                                        composed: true,
                                    })
                                );
                                this.dispatchEvent(
                                    new CustomEvent(
                                        "tag-list-changed-internally",
                                        { bubbles: true, composed: true }
                                    )
                                );
                            }
                            sfx.sfxPop.volume = 1.0;
                            sfx.sfxPop.play();
                        }
                    });
                }
                determineDropEffect(el) {
                    const sourceList = el.closest("tag-list");
                    const sourceGroup = el.closest("tag-group");
                    const targetEntry = this.closest("dataset-entry");

                    if (sourceGroup && targetEntry) return "copy";
                    if (sourceList === this) return "move";
                    return "copy";
                }
                findDropTarget(clientX, clientY) {
                    const children = Array.from(this.children).filter(
                        (c) =>
                            c.tagName === "DATASET-TAG" &&
                            !c.classList.contains("dragging")
                    );
                    let closest = null;
                    let minDist = Infinity;

                    for (const c of children) {
                        const b = c.getBoundingClientRect();
                        const dx = clientX - (b.left + b.width / 2);
                        const dy = clientY - (b.top + b.height / 2);
                        const d = Math.sqrt(dx * dx + dy * dy);
                        if (d < minDist) {
                            minDist = d;
                            closest = c;
                        }
                    }

                    if (closest) {
                        const b = closest.getBoundingClientRect();
                        const col = this.getAttribute("direction") === "column";
                        if (col)
                            return clientY < b.top + b.height / 2
                                ? closest
                                : closest.nextElementSibling;
                        else
                            return clientX < b.left + b.width / 2
                                ? closest
                                : closest.nextElementSibling;
                    }

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        return this.addTagButtonElement;
                    }
                    return null;
                }
                getTags() {
                    return Array.from(this.querySelectorAll("dataset-tag")).map(
                        (tag) => getTagText(tag)
                    );
                }
                getTagsAsString(separator = ", ") {
                    return this.getTags().join(separator);
                }
                setTagsFromArray(tagsArray) {
                    for (const tag of this.querySelectorAll("dataset-tag")) {
                        tag.remove();
                    }

                    if (this.addTagInputElement) {
                        this.addTagInputElement.removeEventListener(
                            "keydown",
                            this._boundHandleAddTagInputKeyDown
                        );
                        this.addTagInputElement.removeEventListener(
                            "blur",
                            this._boundHandleAddTagInputBlur
                        );
                        this.addTagInputElement.remove();
                        this.addTagInputElement = null;
                    }
                    this.isEditingNewTag = false;

                    if (this.addTagButtonElement) {
                        this.addTagButtonElement.removeEventListener(
                            "click",
                            this._boundHandleAddTagButtonClick
                        );
                        this.addTagButtonElement.remove();
                        this.addTagButtonElement = null;
                    }

                    let changed = false;
                    if (Array.isArray(tagsArray)) {
                        const uniqueTags = new Set();
                        for (const tagText of tagsArray) {
                            if (tagText && typeof tagText === "string") {
                                const trimmedTag = tagText.trim();
                                if (
                                    trimmedTag &&
                                    !uniqueTags.has(trimmedTag.toLowerCase())
                                ) {
                                    const newTag =
                                        document.createElement("dataset-tag");
                                    newTag.textContent = trimmedTag;
                                    this.appendChild(newTag);
                                    uniqueTags.add(trimmedTag.toLowerCase());
                                    changed = true;
                                }
                            }
                        }
                    }
                    if (this.closest("dataset-entry")) {
                        this._createAddTagButton();
                    }

                    if (changed) {
                        this.dispatchEvent(
                            new CustomEvent("tag-updated", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                        this.dispatchEvent(
                            new CustomEvent("tag-list-changed-internally", {
                                bubbles: true,
                                composed: true,
                            })
                        );
                    }
                }
                addTag(tagText) {
                    tagText = tagText.trim();
                    if (!tagText) return false;

                    const currentTags = Array.from(
                        this.querySelectorAll("dataset-tag")
                    );
                    if (
                        currentTags.some(
                            (existingTag) =>
                                getTagText(existingTag).toLowerCase() ===
                                tagText.toLowerCase()
                        )
                    ) {
                        return false;
                    }

                    const newTag = document.createElement("dataset-tag");
                    newTag.textContent = tagText;

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.insertBefore(newTag, this.addTagButtonElement);
                    } else {
                        this.appendChild(newTag);
                    }

                    this.dispatchEvent(
                        new CustomEvent("tag-list-changed-internally", {
                            bubbles: true,
                            composed: true,
                        })
                    );
                    this.dispatchEvent(
                        new CustomEvent("tag-updated", {
                            bubbles: true,
                            composed: true,
                        })
                    );
                    return true;
                }
                applyHighlightingAndOrder(searchTerms, termColors) {
                    const children = Array.from(this.children);

                    for (const [
                        originalDOMIndex,
                        element,
                    ] of children.entries()) {
                        if (!(element instanceof DatasetTag)) continue;

                        const tagText = getTagText(element).toLowerCase();
                        let matchedSearchTerm = null;
                        let termIndexOfMatch = -1;

                        for (let i = 0; i < searchTerms.length; i++) {
                            if (tagText.includes(searchTerms[i])) {
                                matchedSearchTerm = searchTerms[i];
                                termIndexOfMatch = i;
                                break;
                            }
                        }

                        if (matchedSearchTerm !== null) {
                            element.setHighlight(termColors[matchedSearchTerm]);

                            element.style.order = termIndexOfMatch;
                        } else {
                            element.clearHighlight();

                            element.style.order =
                                searchTerms.length + originalDOMIndex;
                        }
                    }

                    if (
                        this.addTagButtonElement &&
                        this.contains(this.addTagButtonElement)
                    ) {
                        this.addTagButtonElement.style.order =
                            children.length + 1;
                    }
                }
                clearHighlightingAndOrder() {
                    for (const element of this.children) {
                        if (element instanceof DatasetTag) {
                            element.clearHighlight();
                        }
                        element.style.order = "";
                    }
                }
            }
            customElements.define("tag-list", TagList);

            class DatasetEntry extends HTMLElement {
                constructor() {
                    super();
                    this.imageSrc = "";
                    this.imageData = null;
                    this.originalImageName = "";
                    this._selected = false;
                    this._boundCheckAndUpdate =
                        this.checkGroupRequirementsAndUpdateVisuals.bind(this);
                    this._boundHandleImageClick =
                        this._handleImageClick.bind(this);
                    this._boundHandleAutotagClick =
                        this._handleAutotagClick.bind(this);
                    this._boundHandleEntryClick =
                        this._handleEntryClick.bind(this);
                    this._boundHandleContextMenu =
                        this._handleContextMenu.bind(this);
                }
                get selected() {
                    return this.hasAttribute("selected");
                }
                set selected(value) {
                    const isSelected = Boolean(value);
                    if (isSelected) {
                        this.setAttribute("selected", "");
                        this._selected = true;
                    } else {
                        this.removeAttribute("selected");
                        this._selected = false;
                    }
                }
                toggleSelected() {
                    this.selected = !this.selected;
                }
                connectedCallback() {
                    this.classList.add("dataset-entry");
                    if (!this.querySelector(".entry-content")) {
                        this.innerHTML = `
                <div class="entry-content">
                    <img src="${this.imageSrc || ""}" alt="${
                            this.originalImageName || ""
                        }" title="Click to preview">
                    <tag-list direction="row"></tag-list>
                </div>
                <div class="entry-buttons">
                    <button class="autotag-entry material-icons" title="Autotag Image (AI)" speaker="Autotag Image">auto_awesome</button>
                </div>
                <button class="delete-entry material-icons" title="Delete Entry" speaker="Delete Entry">delete_forever</button>`;
                    }
                    this.style.position = "relative";

                    const delBtn = this.querySelector(".delete-entry");
                    delBtn.addEventListener("click", () => this.deleteEntry());

                    const autotagBtn = this.querySelector(".autotag-entry");
                    autotagBtn?.addEventListener(
                        "click",
                        this._boundHandleAutotagClick
                    );

                    this.addEventListener(
                        "tag-updated",
                        this._boundCheckAndUpdate
                    );

                    this.addEventListener(
                        "tag-list-changed-internally",
                        this._boundCheckAndUpdate
                    );

                    const img = this.querySelector("img");
                    img?.addEventListener("click", this._boundHandleImageClick);

                    this.addEventListener("click", this._boundHandleEntryClick);
                    this.addEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );

                    this.checkGroupRequirementsAndUpdateVisuals();
                    this.addDragDropListeners();

                    if (img && this.imageSrc && !img.src) {
                        img.src = this.imageSrc;
                        img.alt = this.originalImageName;
                        img.title = "Click to preview";
                    }
                }
                disconnectedCallback() {
                    const img = this.querySelector("img");
                    if (img?.src.startsWith("blob:")) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.removeEventListener(
                        "tag-updated",
                        this._boundCheckAndUpdate
                    );
                    this.removeEventListener(
                        "tag-list-changed-internally",
                        this._boundCheckAndUpdate
                    );
                    img?.removeEventListener(
                        "click",
                        this._boundHandleImageClick
                    );
                    this.querySelector(".autotag-entry")?.removeEventListener(
                        "click",
                        this._boundHandleAutotagClick
                    );
                    this.removeEventListener(
                        "click",
                        this._boundHandleEntryClick
                    );
                    this.removeEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );
                }

                _handleEntryClick(event) {
                    const clickedEntry = this;
                    const wasSelected = clickedEntry.selected;
                    const isCtrlPressed = event.ctrlKey || event.metaKey; // metaKey for macOS
                    const isShiftPressed = event.shiftKey;

                    const targetTagName = event.target.tagName.toLowerCase();
                    if (
                        targetTagName !== "input" &&
                        targetTagName !== "textarea" &&
                        !event.target.isContentEditable &&
                        event.target !== clickedEntry.querySelector("img")
                    ) {
                        event.preventDefault();
                    }

                    const target = event.target;
                    if (
                        target.closest("button") ||
                        target.closest("dataset-tag") || // Allow click on tag to propagate if needed by tag itself
                        target.closest('span[contenteditable="true"]') ||
                        target.tagName === "IMG"
                    ) {
                        // If the dataset-tag was clicked, and it wasn't the editable span or delete button,
                        // it might be for initiating drag. Let the event propagate for that.
                        // If it was span/button, those have their own handlers.
                        if (
                            target.closest("dataset-tag") &&
                            !target.closest("span[contenteditable]") &&
                            !target.closest(".delete-tag")
                        ) {
                            // Fine, could be drag start
                        } else {
                            return; // Otherwise, specific interactive element was clicked.
                        }
                    }

                    event.stopPropagation();

                    if (
                        isShiftPressed &&
                        globalLastClickedEntryForShiftSelect &&
                        mainContentAreaElement
                    ) {
                        const allVisibleEntries = Array.from(
                            mainContentAreaElement.querySelectorAll(
                                'dataset-entry:not([style*="display: none"])'
                            )
                        );
                        const currentIndex =
                            allVisibleEntries.indexOf(clickedEntry);
                        const lastIndex = allVisibleEntries.indexOf(
                            globalLastClickedEntryForShiftSelect
                        );

                        if (currentIndex !== -1 && lastIndex !== -1) {
                            const start = Math.min(currentIndex, lastIndex);
                            const end = Math.max(currentIndex, lastIndex);

                            if (!isCtrlPressed) {
                                for (const entry of mainContentAreaElement.querySelectorAll(
                                    "dataset-entry[selected]"
                                )) {
                                    entry.selected = false;
                                }
                            }

                            for (let i = start; i <= end; i++) {
                                if (allVisibleEntries[i]) {
                                    allVisibleEntries[i].selected = true;
                                }
                            }
                        } else {
                            clickedEntry.selected = !wasSelected;
                            globalLastClickedEntryForShiftSelect =
                                clickedEntry.selected ? clickedEntry : null;
                        }
                    } else if (isCtrlPressed) {
                        clickedEntry.selected = !wasSelected;
                        if (clickedEntry.selected) {
                            globalLastClickedEntryForShiftSelect = clickedEntry;
                        } else if (
                            globalLastClickedEntryForShiftSelect ===
                            clickedEntry
                        ) {
                            globalLastClickedEntryForShiftSelect = null;
                        }
                    } else {
                        const currentlySelected =
                            opentaggerAPI.getSelectedEntries();
                        const isAlreadySolelySelected =
                            currentlySelected.length === 1 &&
                            currentlySelected[0] === clickedEntry;

                        if (isAlreadySolelySelected && wasSelected) {
                            clickedEntry.selected = false;
                            globalLastClickedEntryForShiftSelect = null;
                        } else {
                            for (const entry of currentlySelected) {
                                entry.selected = false;
                            }
                            clickedEntry.selected = true;
                            globalLastClickedEntryForShiftSelect = clickedEntry;
                        }
                    }
                }

                _handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const entry = this;
                    const targetEntries = entry.selected
                        ? opentaggerAPI.getSelectedEntries()
                        : [entry];
                    const targetCount = targetEntries.length;

                    const contextMenuItems = [
                        {
                            label: "Preview Image",
                            callback: () => entry._handleImageClick(e),
                        },
                        {
                            label: "Autotag Image (AI)",
                            callback: () => entry.triggerAutotag(false),
                        },
                        { type: "divider" },
                        {
                            label: `Copy Tags (${targetCount} selected) (NYI)`,
                            disabled: true,
                        },
                        {
                            label: `Paste Tags (${targetCount} selected) (NYI)`,
                            disabled: true,
                        },
                        { type: "divider" },
                        {
                            label: `Add Tags to ${targetCount} Selected... (NYI via UI)`,
                            disabled: () => targetCount === 0,
                            callback: () => {
                                /* TODO: Prompt for tags */
                            },
                        },
                        {
                            label: `Remove Tags from ${targetCount} Selected... (NYI via UI)`,
                            disabled: () => targetCount === 0,
                            callback: () => {
                                /* TODO: Prompt for tags */
                            },
                        },
                        { type: "divider" },
                        {
                            label: "Apply Group Tags",
                            items: getGroupSubmenuItems(targetEntries),
                            disabled: () => targetCount === 0,
                        },
                        { type: "divider" },
                        {
                            label: "Check Requirements",
                            callback: () =>
                                entry.checkGroupRequirementsAndUpdateVisuals(),
                        },
                        { type: "divider" },
                        {
                            label: "Delete Entry",
                            callback: () => entry.deleteEntry(),
                        },
                    ];

                    if (targetCount > 1) {
                        contextMenuItems.push({ type: "divider" });
                        contextMenuItems.push({
                            label: `Delete ${targetCount} Selected Entries`,
                            callback: () => {
                                showConfirmationModal(
                                    `Are you sure you want to delete ${targetCount} selected entries?`,
                                    [
                                        {
                                            text: "Delete",
                                            class: "modal-button-confirm",
                                            onClick: () => {
                                                const entriesToDelete = [
                                                    ...targetEntries,
                                                ];
                                                for (const en of entriesToDelete)
                                                    en.deleteEntry();
                                                globalLastClickedEntryForShiftSelect =
                                                    null;
                                            },
                                        },
                                        {
                                            text: "Cancel",
                                            class: "modal-button-cancel",
                                        },
                                    ]
                                );
                            },
                            disabled: () => targetCount === 0,
                        });
                    }

                    createContextMenu(contextMenuItems, e);
                }

                _handleImageClick(e) {
                    e.stopPropagation();
                    if (this.imageSrc) {
                        showImagePreviewModal(
                            this.imageSrc,
                            this.originalImageName
                        );
                    }
                }
                deleteEntry() {
                    const img = this.querySelector("img");
                    if (img?.src.startsWith("blob:") && URL.revokeObjectURL) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.remove();
                    this.dispatchEvent(
                        new CustomEvent("entry-deleted", { bubbles: true })
                    );
                }
                async _handleAutotagClick(e) {
                    e.stopPropagation();
                    await this.triggerAutotag(false);
                }
                async triggerAutotag(silent = false) { // Changed: Modified fetch URL logic
                    const autotagButton = this.querySelector(".autotag-entry");
                    const buttonWrapper = this.querySelector(".entry-buttons");

                    if (!autotagButton) {
                        console.error(
                            `Autotag button not found for ${this.originalImageName}.`
                        );
                        return {
                            success: false,
                            message: "Autotag button not found.",
                            tagsAddedCount: 0,
                            elapsedTime: 0,
                        };
                    }
                    if (!buttonWrapper && !silent) {
                        console.error(
                            `Button wrapper not found for ${this.originalImageName} for timer placement.`
                        );
                    }

                    if (autotagButton.disabled) {
                        if (!silent) {
                            console.warn(
                                `Autotag for ${this.originalImageName} skipped as button is disabled.`
                            );
                        }
                        return {
                            success: false,
                            message: "Autotag action disabled.",
                            tagsAddedCount: 0,
                            elapsedTime: 0,
                        };
                    }

                    let timer = null;
                    let timerLabel = null;
                    let operationResult = {
                        success: false,
                        message: "Operation not fully completed.",
                        tagsAddedCount: 0,
                        elapsedTime: 0,
                    };

                    if (!silent && buttonWrapper) {
                        buttonWrapper
                            .querySelector(".autotag-timer-label")
                            ?.remove();
                        timerLabel = createTimerLabelElement();
                        buttonWrapper.appendChild(timerLabel);
                        timer = startTimer((timeString) => {
                            if (timerLabel) timerLabel.textContent = timeString;
                        }, 100);
                    }

                    const originalIcon = autotagButton.textContent;
                    const originalTitle = autotagButton.getAttribute("title");

                    autotagButton.disabled = true;
                    if (!silent) {
                        autotagButton.textContent = "sync";
                        autotagButton.setAttribute(
                            "title",
                            "Autotagging in progress..."
                        );
                        autotagButton.classList.add("loading");
                    }

                    try {
                        const imageData = await this.getImageData();
                        if (!imageData) {
                            throw new Error(
                                "No image data available for autotagging."
                            );
                        }

                        const formData = new FormData();
                        formData.append(
                            "image_upload",
                            imageData,
                            this.originalImageName || "image.png"
                        );

                        const selectedModel =
                            preferences.tagging.autotagging.autotaggingModel
                                .value;
                        let endpointPath = "";

                        switch (selectedModel) {
                            case "wd-vit-tagger-v3":
                                endpointPath = "wd-vit-tagger-v3";
                                break;
                            case "it_so400m_patch14_siglip_384":
                                endpointPath = "redrocket-joint-tagger";
                                break;
                            default:
                                throw new Error(
                                    `Unknown autotagging model selected: ${selectedModel}`
                                );
                        }

                        const fullApiUrl = `${AUTOTAG_API_URL}${endpointPath}`;

                        const response = await fetch(fullApiUrl, {
                            method: "POST",
                            body: formData,
                        });

                        if (!response.ok) {
                            let errorDetail = `HTTP error ${response.status}`;
                            try {
                                const errorJson = await response.json();
                                errorDetail = errorJson.detail || errorDetail;
                            } catch (jsonError) {
                                const errorText = await response.text();
                                errorDetail = errorText || errorDetail;
                            }
                            if (!silent)
                                console.error(
                                    `Autotagging HTTP error ${
                                        response.status
                                    } for ${
                                        this.originalImageName
                                    }. Details: ${errorDetail}. Full response text: ${await response
                                        .text()
                                        .catch(
                                            () => "Could not read response text"
                                        )}`
                                );
                            throw new Error(
                                `Autotagging failed: ${errorDetail}`
                            );
                        }

                        const result = await response.json();
                        const tags = result.tags;
                        let tagsAddedCount = 0;

                        if (Array.isArray(tags)) {
                            for (const tag of tags) {
                                if (this.addTag(tag)) {
                                    tagsAddedCount++;
                                }
                            }
                            if (!silent) {
                                console.log(
                                    `Autotag for ${
                                        this.originalImageName || "untitled"
                                    } complete. ${tagsAddedCount} new tag(s) added. Total AI tags: ${
                                        tags.length
                                    }.`
                                );
                            }
                            operationResult = {
                                success: true,
                                tagsAddedCount: tagsAddedCount,
                                totalAiTags: tags.length,
                                elapsedTime: 0,
                            };
                        } else {
                            throw new Error(
                                "Autotagger returned an unexpected response format."
                            );
                        }
                    } catch (error) {
                        console.error(
                            `Autotagging error for ${
                                this.originalImageName || "untitled"
                            }:`,
                            error
                        );
                        operationResult = {
                            success: false,
                            message: error.message,
                            tagsAddedCount: 0,
                            elapsedTime: 0,
                        };
                    } finally {
                        if (timer) {
                            operationResult.elapsedTime = timer.stop();
                        }
                        if (!silent && timerLabel) {
                            const finalMessage = operationResult.success
                                ? `Done: ${operationResult.elapsedTime.toFixed(
                                      1
                                  )}s`
                                : `Error: ${operationResult.elapsedTime.toFixed(
                                      1
                                  )}s`;
                            timerLabel.textContent = finalMessage;
                            timerLabel.classList.add("fade-out");
                            setTimeout(() => timerLabel.remove(), 2500);
                        }

                        if (!silent) {
                            autotagButton.textContent = originalIcon;
                            autotagButton.setAttribute("title", originalTitle);
                            autotagButton.classList.remove("loading");
                        }

                        if (!autotagAllButton.classList.contains("loading")) {
                            autotagButton.disabled = false;
                        }
                    }
                    return operationResult;
                }
                addDragDropListeners() {
                    const tagList = this.querySelector("tag-list");

                    this.addEventListener("dragenter", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const listRect = tagList.getBoundingClientRect();
                            if (
                                e.clientX >= listRect.left &&
                                e.clientX <= listRect.right &&
                                e.clientY >= listRect.top &&
                                e.clientY <= listRect.bottom
                            ) {
                                tagList.classList.add("drag-over");
                            }
                        }
                    });

                    this.addEventListener("dragover", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const listRect = tagList.getBoundingClientRect();
                            if (
                                e.clientX >= listRect.left &&
                                e.clientX <= listRect.right &&
                                e.clientY >= listRect.top &&
                                e.clientY <= listRect.bottom
                            ) {
                                e.preventDefault();
                                e.stopPropagation();
                                e.dataTransfer.dropEffect =
                                    tagList.determineDropEffect(draggedElement);
                                tagList.classList.add("drag-over");
                            } else {
                                tagList.classList.remove("drag-over");
                            }
                        } else if (e.dataTransfer.types.includes("Files")) {
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });

                    this.addEventListener("dragleave", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            const entryRect = this.getBoundingClientRect();
                            if (
                                !this.contains(e.relatedTarget) ||
                                e.clientX < entryRect.left ||
                                e.clientX >= entryRect.right ||
                                e.clientY < entryRect.top ||
                                e.clientY >= entryRect.bottom
                            ) {
                                tagList.classList.remove("drag-over");
                            } else {
                                const listRect =
                                    tagList.getBoundingClientRect();
                                if (
                                    e.clientX < listRect.left ||
                                    e.clientX >= listRect.right ||
                                    e.clientY < listRect.top ||
                                    e.clientY >= listRect.bottom
                                ) {
                                    tagList.classList.remove("drag-over");
                                }
                            }
                        }
                    });

                    this.addEventListener("drop", (e) => {
                        if (
                            draggedElement?.tagName === "DATASET-TAG" &&
                            tagList
                        ) {
                            tagList.classList.remove("drag-over");
                        } else if (e.dataTransfer.files?.length > 0) {
                            tagList?.classList.remove("drag-over");
                        } else {
                            tagList?.classList.remove("drag-over");
                        }
                    });
                }
                setImage(blobUrl, fileObject) {
                    const img = this.querySelector("img");
                    if (
                        img?.src.startsWith("blob:") &&
                        img.src !== blobUrl &&
                        URL.revokeObjectURL
                    ) {
                        URL.revokeObjectURL(img.src);
                    }
                    this.imageSrc = blobUrl;
                    this.imageData = fileObject;
                    this.originalImageName =
                        fileObject?.name || `image_${Date.now()}.png`;
                    if (img) {
                        img.src = this.imageSrc;
                        img.alt = this.originalImageName;
                        img.title = "Click to preview";
                    }
                    this.checkGroupRequirementsAndUpdateVisuals();
                }
                async getImageData() {
                    if (
                        this.imageData instanceof Blob ||
                        this.imageData instanceof File
                    ) {
                        return this.imageData;
                    }

                    if (
                        this.imageSrc.startsWith("data:") ||
                        this.imageSrc.startsWith("blob:")
                    ) {
                        try {
                            console.warn(
                                `Attempting to fetch image data from src for ${this.originalImageName}. Direct Blob/File preferred.`
                            );
                            const response = await fetch(this.imageSrc);
                            if (!response.ok)
                                throw new Error(
                                    `HTTP error! status: ${response.status}`
                                );
                            this.imageData = await response.blob();

                            const name =
                                this.originalImageName ||
                                `fetched_image_${Date.now()}.png`;
                            if (this.imageData instanceof Blob) {
                                this.imageData = new File(
                                    [this.imageData],
                                    name,
                                    { type: this.imageData.type }
                                );
                            } else {
                                console.error(
                                    "Fetched data was not a Blob, cannot create File."
                                );
                                return null;
                            }
                            return this.imageData;
                        } catch (e) {
                            console.error(
                                `Error fetching image data from src (${this.imageSrc}):`,
                                e
                            );
                            return null;
                        }
                    }
                    console.error(
                        `Could not get image data for entry: ${this.originalImageName}`
                    );
                    return null;
                }
                addTag(text) {
                    const list = this.querySelector("tag-list");
                    const added = list ? list.addTag(text) : false;

                    return added;
                }
                setTags(tagsArray) {
                    const list = this.querySelector("tag-list");
                    if (list) {
                        list.setTagsFromArray(tagsArray);
                    } else {
                        console.warn(
                            "setTags called on dataset-entry, but internal <tag-list> not found. Tags not set for:",
                            this.originalImageName
                        );
                    }
                }
                getTagsAsString(sep = ", ") {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTagsAsString(sep) : "";
                }
                getTags() {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTags() : [];
                }
                getNormalizedTags() {
                    return this.getTags().map((tag) => tag.toLowerCase());
                }
                checkGroupRequirements() {
                    const groups = document.querySelectorAll(
                        "#tag-group-list tag-group"
                    );
                    const entryTagsLower = this.getNormalizedTags();

                    for (const group of groups) {
                        const minRequired = group.minimumTags;
                        if (minRequired <= 0) continue;

                        const groupTagsLower = group
                            .getGroupTags()
                            .map((t) => t.toLowerCase());
                        if (groupTagsLower.length === 0) continue;

                        let count = 0;
                        for (const entryTag of entryTagsLower) {
                            if (groupTagsLower.includes(entryTag)) {
                                count++;
                            }
                        }
                        if (count < minRequired) {
                            return false;
                        }
                    }
                    return true;
                }
                checkGroupRequirementsAndUpdateVisuals() {
                    const requirementsMet = this.checkGroupRequirements();
                    if (requirementsMet) {
                        this.classList.remove("requirement-not-met");
                    } else {
                        this.classList.add("requirement-not-met");
                    }
                }
                applyTagHighlighting(searchTerms, termColors) {
                    const tagList = this.querySelector("tag-list");
                    tagList?.applyHighlightingAndOrder(searchTerms, termColors);
                }
                clearTagHighlighting() {
                    const tagList = this.querySelector("tag-list");
                    tagList?.clearHighlightingAndOrder();
                }
            }
            customElements.define("dataset-entry", DatasetEntry);

            class TagGroup extends HTMLElement {
                constructor() {
                    super();
                    this._minimumTags = 0;
                    this._boundUpdateMinTags = this._updateMinTags.bind(this);
                    this._boundHandleContextMenu =
                        this._handleContextMenu.bind(this);
                }
                static observedAttributes = ["group-name"];
                get minimumTags() {
                    return this._minimumTags;
                }
                set minimumTags(value) {
                    const newMin = Math.max(0, parseInt(value, 10) || 0);
                    if (newMin !== this._minimumTags) {
                        this._minimumTags = newMin;
                        this.updateMinTagsDisplay();

                        document.dispatchEvent(
                            new CustomEvent("group-min-tags-changed", {
                                detail: { group: this },
                            })
                        );
                    }
                }
                connectedCallback() {
                    const name = this.getAttribute("group-name") || "New Group";
                    const tags = Array.from(
                        this.querySelectorAll("dataset-tag")
                    );
                    this.innerHTML = `
            <div class="group-header">
                <span class="group-name" contenteditable="true">${name}</span>
                 <div class="min-tags-control">
                     <span>Min:</span>
                     <button class="min-tags-decrement material-icons" speaker="Decrease Minimum Tags">remove</button>
                     <span class="min-tags-value">0</span>
                     <button class="min-tags-increment material-icons" speaker="Increase Minimum Tags">add</button>
                 </div>
                 <button class="btn-new-tag material-icons" speaker="Add New Tag">add_circle_outline</button>
            </div>
             <tag-list direction="column"></tag-list>
             <button class="delete-group material-icons" speaker="Delete Group">delete</button>`;
                    this.style.position = "relative";

                    const delBtn = this.querySelector(".delete-group");
                    delBtn.style.cssText = `position: absolute; bottom: 5px; right: 5px; background: none; border: none; cursor: pointer; color: #aaa; font-size: 18px;`;
                    delBtn.addEventListener("click", () => {
                        this.remove();

                        document.dispatchEvent(
                            new CustomEvent("group-min-tags-changed", {
                                detail: { group: null },
                            })
                        );
                    });

                    const list = this.querySelector("tag-list");

                    for (const t of tags) {
                        list.appendChild(t);
                    }
                    this.addEventListeners();
                    this.updateMinTagsDisplay();
                }
                disconnectedCallback() {}
                attributeChangedCallback(name, oldV, newV) {
                    if (name === "group-name") {
                        const s = this.querySelector(".group-name");
                        if (s) s.textContent = newV;
                    }
                }
                addEventListeners() {
                    const addBtn = this.querySelector(".btn-new-tag");
                    const list = this.querySelector("tag-list");
                    const nameSpan = this.querySelector(".group-name");
                    const incBtn = this.querySelector(".min-tags-increment");
                    const decBtn = this.querySelector(".min-tags-decrement");

                    if (addBtn && list) {
                        addBtn.addEventListener("click", () => {
                            const added = list.addTag("new_tag");
                            if (added) {
                                const tagElements =
                                    list.querySelectorAll("dataset-tag");
                                const tag = tagElements[tagElements.length - 1];
                                if (tag) {
                                    const s = tag.querySelector(
                                        "span[contenteditable]"
                                    );
                                    if (s) {
                                        s.setAttribute(
                                            "contenteditable",
                                            "true"
                                        );
                                        tag._originalText = getTagText(tag); // Set original text before focus
                                        s.focus();

                                        window
                                            .getSelection()
                                            .selectAllChildren(s);
                                    }
                                }
                            }
                        });
                    }
                    if (nameSpan) {
                        nameSpan.addEventListener("keydown", (e) => {
                            if (e.key === "Enter") {
                                e.preventDefault();
                                nameSpan.blur();
                            } else if (e.key === "Escape") {
                                nameSpan.textContent =
                                    this.getAttribute("group-name") ||
                                    "New Cat";
                                nameSpan.blur();
                            }
                        });
                        nameSpan.addEventListener("blur", () => {
                            const n = nameSpan.textContent.trim();
                            if (
                                n &&
                                n !==
                                    (this.getAttribute("group-name") ||
                                        "New Cat")
                            ) {
                                this.setAttribute("group-name", n);
                            } else {
                                nameSpan.textContent =
                                    this.getAttribute("group-name") ||
                                    "New Cat";
                            }
                        });
                    }
                    incBtn?.addEventListener("click", () =>
                        this._updateMinTags(1)
                    );
                    decBtn?.addEventListener("click", () =>
                        this._updateMinTags(-1)
                    );

                    addBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    incBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    decBtn?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    nameSpan?.addEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );

                    this.addEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );
                }
                removeEventListeners() {
                    const addBtn = this.querySelector(".btn-new-tag");
                    const nameSpan = this.querySelector(".group-name");
                    const incBtn = this.querySelector(".min-tags-increment");
                    const decBtn = this.querySelector(".min-tags-decrement");

                    addBtn?.removeEventListener(
                        "click",
                        this._handleAddTagButtonClick
                    ); // Assuming this was a typo for actual method
                    nameSpan?.removeEventListener(
                        "keydown",
                        this._handleSpanKeyDown
                    );
                    nameSpan?.removeEventListener("blur", this._handleSpanBlur);
                    incBtn?.removeEventListener(
                        "click",
                        this._boundUpdateMinTags
                    ); // This should be correct
                    decBtn?.removeEventListener(
                        "click",
                        this._boundUpdateMinTags
                    ); // This should be correct

                    addBtn?.removeEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    incBtn?.removeEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    decBtn?.removeEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );
                    nameSpan?.removeEventListener("mousedown", (e) =>
                        e.stopPropagation()
                    );

                    this.removeEventListener(
                        "contextmenu",
                        this._boundHandleContextMenu
                    );
                }
                _updateMinTags(delta) {
                    this.minimumTags += delta;
                }
                updateMinTagsDisplay() {
                    const valueSpan = this.querySelector(".min-tags-value");
                    if (valueSpan) {
                        valueSpan.textContent = this._minimumTags;
                    }
                }
                getGroupTags() {
                    const list = this.querySelector("tag-list");
                    return list ? list.getTags() : [];
                }
                setTags(tagsArray) {
                    const list = this.querySelector("tag-list");
                    list?.setTagsFromArray(tagsArray);
                }

                _handleContextMenu(e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const items = [
                        {
                            label: "Rename Group (Double Click Name)",
                            callback: null,
                            disabled: true,
                        },
                        {
                            label: "Add New Tag",
                            callback: () =>
                                this.querySelector(".btn-new-tag")?.click(),
                        },
                        { type: "divider" },
                        {
                            label: "Delete Group",
                            callback: () =>
                                this.querySelector(".delete-group")?.click(),
                        },
                    ];

                    createContextMenu(items, e);
                }
            }
            customElements.define("tag-group", TagGroup);

            class MenuItem extends HTMLElement {
                constructor() {
                    super();
                    this._callback = null;
                    this.submenu = null;
                }
                connectedCallback() {
                    this.submenu = this.querySelector("context-menu");
                    if (this.submenu) {
                        const arrow = document.createElement("span");
                        arrow.className = "submenu-arrow material-icons";
                        arrow.textContent = "arrow_right";
                        this.appendChild(arrow);

                        this.addEventListener("mouseenter", () => {
                            this.submenu.style.display = "flex";
                        });
                        this.addEventListener("mouseleave", () => {
                            this.submenu.style.display = "none";
                        });

                        this.addEventListener("click", (e) => {
                            e.stopPropagation();
                        });
                    } else {
                        this.addEventListener("click", (e) => {
                            e.stopPropagation();
                            if (
                                !this.classList.contains("disabled") &&
                                typeof this._callback === "function"
                            ) {
                                this._callback(e);
                            }
                            this.closestContextMenu()?.hide();
                        });
                    }
                }
                set callback(t) {
                    this._callback = t;
                }
                closestContextMenu() {
                    let e = this.closest("context-menu");
                    while (e && e.parentElement instanceof MenuItem) {
                        e = e.parentElement.closest("context-menu");
                    }
                    return e;
                }
            }
            customElements.define("menu-item", MenuItem);

            class ContextMenu extends HTMLElement {
                constructor() {
                    super();
                    this._boundHide = this.hide.bind(this);
                    this._boundPreventContextMenu = (e) => e.preventDefault();
                }
                connectedCallback() {
                    this.style.display = "none";
                    this.addEventListener(
                        "contextmenu",
                        this._boundPreventContextMenu
                    );
                }
                disconnectedCallback() {
                    document.removeEventListener("click", this._boundHide, {
                        capture: true,
                    });
                    document.removeEventListener(
                        "contextmenu",
                        this._boundHide,
                        { capture: true }
                    );
                    this.removeEventListener(
                        "contextmenu",
                        this._boundPreventContextMenu
                    );
                }
                show(x, y, anchorElement = null) {
                    for (const menu of document.querySelectorAll(
                        "context-menu.visible"
                    )) {
                        menu.hide();
                    }

                    let targetX = x;
                    let targetY = y;

                    if (anchorElement) {
                        const anchorRect =
                            anchorElement.getBoundingClientRect();
                        targetY = anchorRect.bottom + 2;
                        targetX = anchorRect.left;
                    } else {
                        this.style.minWidth = "150px";
                    }

                    this.style.left = `${targetX}px`;
                    this.style.top = `${targetY}px`;
                    this.classList.add("visible");
                    this.style.display = "flex";

                    requestAnimationFrame(() => {
                        const rect = this.getBoundingClientRect();
                        const screenWidth = window.innerWidth;
                        const screenHeight = window.innerHeight;

                        let adjustedX = parseFloat(this.style.left);
                        let adjustedY = parseFloat(this.style.top);

                        if (rect.right > screenWidth) {
                            adjustedX = anchorElement
                                ? anchorElement.getBoundingClientRect().right -
                                  rect.width
                                : screenWidth - rect.width - 5;
                        }
                        if (rect.bottom > screenHeight) {
                            adjustedY = anchorElement
                                ? anchorElement.getBoundingClientRect().top -
                                  rect.height -
                                  2
                                : screenHeight - rect.height - 5;
                        }
                        if (adjustedX < 0) adjustedX = 5;
                        if (adjustedY < 0) adjustedY = 5;

                        this.style.left = `${adjustedX}px`;
                        this.style.top = `${adjustedY}px`;
                    });

                    setTimeout(() => {
                        document.addEventListener("click", this._boundHide, {
                            capture: true,
                            once: true,
                        });
                        document.addEventListener(
                            "contextmenu",
                            this._boundHide,
                            { capture: true, once: true }
                        );
                    }, 0);
                }
                hide() {
                    if (this.classList.contains("visible")) {
                        this.style.display = "none";
                        this.classList.remove("visible");

                        document.removeEventListener("click", this._boundHide, {
                            capture: true,
                        });
                        document.removeEventListener(
                            "contextmenu",
                            this._boundHide,
                            { capture: true }
                        );

                        for (const submenu of this.querySelectorAll(
                            "context-menu"
                        )) {
                            submenu.style.display = "none";
                        }
                    }
                }
            }
            customElements.define("context-menu", ContextMenu);

            let currentContextMenu = null;
            function createContextMenu(items, triggerElementOrEvent) {
                currentContextMenu?.remove();
                currentContextMenu = null;

                const menu = document.createElement("context-menu");

                for (const item of items) {
                    if (item.type === "divider") {
                        menu.appendChild(document.createElement("hr"));
                    } else {
                        const menuItem = document.createElement("menu-item");
                        menuItem.textContent = item.label || "Item";

                        let isHidden = false;
                        if (typeof item.hidden === "function") {
                            isHidden = item.hidden(triggerElementOrEvent);
                        } else if (typeof item.hidden === "boolean") {
                            isHidden = item.hidden;
                        }
                        if (isHidden) {
                            menuItem.style.display = "none";
                        }

                        let isDisabled = false;
                        if (typeof item.disabled === "function") {
                            isDisabled = item.disabled(triggerElementOrEvent);
                        } else if (typeof item.disabled === "boolean") {
                            isDisabled = item.disabled;
                        }

                        if (isDisabled) {
                            menuItem.classList.add("disabled");
                        } else {
                            if (
                                item.callback &&
                                typeof item.callback === "function"
                            ) {
                                menuItem.callback = item.callback;
                            } else if (!item.items) {
                                menuItem.style.opacity = "0.5";
                                menuItem.style.pointerEvents = "none";
                            }
                        }

                        if (item.dataAction)
                            menuItem.dataset.action = item.dataAction;

                        if (item.items && item.items.length > 0) {
                            const subMenu =
                                document.createElement("context-menu");

                            for (const subItem of item.items) {
                                if (subItem.type === "divider") {
                                    subMenu.appendChild(
                                        document.createElement("hr")
                                    );
                                } else {
                                    const subMenuItem =
                                        document.createElement("menu-item");
                                    subMenuItem.textContent =
                                        subItem.label || "Sub Item";

                                    let isSubHidden = false;
                                    if (typeof subItem.hidden === "function") {
                                        isSubHidden = subItem.hidden(
                                            triggerElementOrEvent
                                        );
                                    } else if (
                                        typeof subItem.hidden === "boolean"
                                    ) {
                                        isSubHidden = subItem.hidden;
                                    }
                                    if (isSubHidden) {
                                        subMenuItem.style.display = "none";
                                    }

                                    let isSubDisabled = false;
                                    if (
                                        typeof subItem.disabled === "function"
                                    ) {
                                        isSubDisabled = subItem.disabled(
                                            triggerElementOrEvent
                                        );
                                    } else if (
                                        typeof subItem.disabled === "boolean"
                                    ) {
                                        isSubDisabled = subItem.disabled;
                                    }

                                    if (isSubDisabled) {
                                        subMenuItem.classList.add("disabled");
                                    } else {
                                        if (
                                            subItem.callback &&
                                            typeof subItem.callback ===
                                                "function"
                                        ) {
                                            subMenuItem.callback =
                                                subItem.callback;
                                        } else if (!subItem.items) {
                                            subMenuItem.style.opacity = "0.5";
                                            subMenuItem.style.pointerEvents =
                                                "none";
                                        }
                                    }

                                    if (subItem.dataAction)
                                        subMenuItem.dataset.action =
                                            subItem.dataAction;
                                    subMenu.appendChild(subMenuItem);
                                }
                            }
                            menuItem.appendChild(subMenu);
                        }
                        menu.appendChild(menuItem);
                    }
                }

                document.body.appendChild(menu);
                currentContextMenu = menu;

                if (triggerElementOrEvent instanceof HTMLElement) {
                    currentContextMenu._ownerButton = triggerElementOrEvent;
                } else {
                    currentContextMenu._ownerButton = null;
                }

                if (triggerElementOrEvent instanceof Event) {
                    triggerElementOrEvent.preventDefault();
                    menu.show(
                        triggerElementOrEvent.clientX,
                        triggerElementOrEvent.clientY
                    );
                } else if (triggerElementOrEvent instanceof HTMLElement) {
                    menu.show(0, 0, triggerElementOrEvent);
                }
                return menu;
            }

            function showConfirmationModal(message, buttons) {
                document.querySelector(".modal-overlay")?.remove();

                const overlay = document.createElement("div");
                overlay.className = "modal-overlay";

                const content = document.createElement("div");
                content.className = "modal-content";

                const msgElement = document.createElement("div");
                msgElement.className = "modal-message";
                msgElement.textContent = message;
                msgElement.style.whiteSpace = "pre-wrap";

                const btnContainer = document.createElement("div");
                btnContainer.className = "modal-buttons";

                for (const btnInfo of buttons) {
                    const button = document.createElement("button");
                    button.textContent = btnInfo.text;
                    button.className = btnInfo.class || "modal-button-default";
                    button.addEventListener("click", () => {
                        overlay.remove();
                        if (typeof btnInfo.onClick === "function") {
                            btnInfo.onClick();
                        }
                    });
                    btnContainer.appendChild(button);
                }

                content.appendChild(msgElement);
                content.appendChild(btnContainer);
                overlay.appendChild(content);

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });

                document.body.appendChild(overlay);
            }

            function showImagePreviewModal(imageUrl, imageName) {
                document.querySelector(".image-preview-overlay")?.remove();

                const overlay = document.createElement("div");
                overlay.className = "image-preview-overlay";

                const content = document.createElement("div");
                content.className = "image-preview-content";

                const closeBtn = document.createElement("button");
                closeBtn.className = "image-preview-close material-icons";
                closeBtn.textContent = "close";
                closeBtn.setAttribute("title", "Close Preview");

                const imgPreview = document.createElement("img");
                imgPreview.alt = `Preview: ${imageName}`;

                const infoDiv = document.createElement("div");
                infoDiv.className = "image-preview-info";
                infoDiv.textContent = "Loading image...";

                content.appendChild(closeBtn);
                content.appendChild(imgPreview);
                content.appendChild(infoDiv);
                overlay.appendChild(content);

                const close = () => {
                    overlay.remove();
                    document.removeEventListener("keydown", escapeHandler);
                };

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        close();
                    }
                });
                closeBtn.addEventListener("click", close);

                const escapeHandler = (e) => {
                    if (e.key === "Escape") {
                        close();
                    }
                };
                document.addEventListener("keydown", escapeHandler);

                const tempImg = new Image();
                tempImg.onload = () => {
                    imgPreview.src = imageUrl;
                    infoDiv.innerHTML = `
             <strong>${imageName}</strong>
             <br>
             Dimensions: ${tempImg.naturalWidth} x ${tempImg.naturalHeight} pixels
          `;
                };
                tempImg.onerror = () => {
                    infoDiv.textContent = `Error: Could not load preview for ${imageName}.`;
                    console.error(
                        "Image Preview Modal: Failed to load",
                        imageUrl
                    );
                };
                tempImg.src = imageUrl;

                document.body.appendChild(overlay);
            }

            const checkDropHintVisibility = () => {
                if (!mainContentAreaElement || !dropHint || !searchInput) {
                    return;
                }

                const hasAnyEntries =
                    mainContentAreaElement.querySelector("dataset-entry");

                if (!hasAnyEntries) {
                    dropHint.textContent =
                        "Drag & Drop Images Here, Load Project, or Import Dataset ZIP";
                    dropHint.classList.remove("no-results");
                    dropHint.style.display = "block";
                    return;
                }

                const hasVisibleEntries = mainContentAreaElement.querySelector(
                    'dataset-entry:not([style*="display: none"])'
                );
                if (!hasVisibleEntries && searchInput.value.trim() !== "") {
                    dropHint.textContent = "";
                    dropHint.classList.add("no-results");
                    dropHint.style.display = "block";
                } else {
                    dropHint.classList.remove("no-results");
                    dropHint.style.display = "none";
                }
            };

            async function handleAutotagAllClick() {
                if (
                    !mainContentAreaElement ||
                    !autotagAllButton ||
                    autotagAllButton.disabled
                )
                    return;

                const entriesToAutotag = Array.from(
                    mainContentAreaElement.querySelectorAll(
                        'dataset-entry:not([style*="display: none"])'
                    )
                );

                if (entriesToAutotag.length === 0) {
                    showConfirmationModal("No visible entries to autotag.", [
                        { text: "OK" },
                    ]);
                    return;
                }

                const originalButtonIcon = autotagAllButton.textContent;
                const originalButtonTitle =
                    autotagAllButton.getAttribute("title");

                autotagAllButton.textContent = "sync";
                autotagAllButton.classList.add("loading");
                autotagAllButton.disabled = true;

                let globalTimerLabel =
                    autotagAllButton.parentElement.querySelector(
                        ".autotag-timer-label"
                    );
                if (!globalTimerLabel) {
                    globalTimerLabel = createTimerLabelElement();
                    autotagAllButton.insertAdjacentElement(
                        "afterend",
                        globalTimerLabel
                    );
                } else {
                    globalTimerLabel.textContent = "0.0s";
                    globalTimerLabel.classList.remove("fade-out");
                }

                let successCount = 0;
                let failCount = 0;
                const totalEntries = entriesToAutotag.length;

                let globalTimer = startTimer((timeString) => {
                    if (globalTimerLabel)
                        globalTimerLabel.textContent = timeString;
                    const processedCount = successCount + failCount;
                    autotagAllButton.setAttribute(
                        "title",
                        `Autotagging ${processedCount}/${totalEntries}... (${timeString})`
                    );
                }, 200);

                for (const entry of entriesToAutotag) {
                    const btn = entry.querySelector(".autotag-entry");
                    if (btn) btn.disabled = true;
                }

                for (let i = 0; i < totalEntries; i++) {
                    const entry = entriesToAutotag[i];
                    const entryDisplayName =
                        entry.originalImageName || `entry ${i + 1}`;
                    autotagAllButton.setAttribute(
                        "title",
                        `Autotagging ${
                            successCount + failCount + 1
                        }/${totalEntries}: ${entryDisplayName} (${globalTimer.getElapsedTime()})`
                    );
                    try {
                        const result = await entry.triggerAutotag(true);
                        if (result && result.success) {
                            successCount++;
                            console.log(
                                `Autotagged successfully: ${entryDisplayName}. New tags: ${result.tagsAddedCount}`
                            );
                        } else {
                            failCount++;
                            console.warn(
                                `Autotagging failed or no tags added for: ${entryDisplayName}. Message: ${
                                    result ? result.message : "No details"
                                }`
                            );
                        }
                    } catch (error) {
                        failCount++;
                        console.error(
                            `Critical error during autotag for entry ${entryDisplayName}:`,
                            error
                        );
                    }
                }

                const totalElapsedTime = globalTimer.stop();
                if (globalTimerLabel) {
                    globalTimerLabel.textContent = `Total: ${totalElapsedTime.toFixed(
                        1
                    )}s`;
                    globalTimerLabel.classList.add("fade-out");
                    setTimeout(() => globalTimerLabel.remove(), 3000);
                }

                autotagAllButton.textContent = originalButtonIcon;
                autotagAllButton.setAttribute("title", originalButtonTitle);
                autotagAllButton.classList.remove("loading");
                autotagAllButton.disabled = false;

                for (const entry of entriesToAutotag) {
                    const btn = entry.querySelector(".autotag-entry");
                    if (btn) btn.disabled = false;
                }

                let summaryMessage = `Autotag All complete in ${totalElapsedTime.toFixed(
                    1
                )} seconds.\nSuccessfully processed: ${successCount} entr${
                    successCount === 1 ? "y" : "ies"
                }.`;
                if (failCount > 0) {
                    summaryMessage += `\nFailed or no tags added for: ${failCount} entr${
                        failCount === 1 ? "y" : "ies"
                    }.`;
                }
                if (
                    totalEntries > 0 &&
                    successCount === 0 &&
                    failCount === totalEntries
                ) {
                    summaryMessage = `Autotag All (took ${totalElapsedTime.toFixed(
                        1
                    )}s): All entries failed or had no new tags to add.`;
                } else if (totalEntries === 0) {
                    summaryMessage = "No visible entries were processed.";
                }
                showConfirmationModal(summaryMessage, [{ text: "OK" }]);
            }

            function filterEntries(query) {
                if (!mainContentAreaElement || !searchInput) {
                    console.warn(
                        "filterEntries called but mainContentAreaElement or searchInput is not yet available."
                    );
                    return;
                }

                const entries =
                    mainContentAreaElement.querySelectorAll("dataset-entry");
                query = query.trim().toLowerCase();

                if (query === "") {
                    globalParsedSearchTerms = [];
                    globalSearchTermColors = {};
                } else {
                    globalParsedSearchTerms = getQueryLeafTerms(query);
                    globalSearchTermColors = {};

                    for (const term of globalParsedSearchTerms) {
                        globalSearchTermColors[term] = getTagColor(term);
                    }
                }

                for (const entry of entries) {
                    const tags = entry.getNormalizedTags();
                    let match =
                        query === "" ? true : evaluateExpression(query, tags);

                    entry.style.display = match ? "" : "none";

                    if (match) {
                        if (globalParsedSearchTerms.length > 0) {
                            entry.applyTagHighlighting(
                                globalParsedSearchTerms,
                                globalSearchTermColors
                            );
                        } else {
                            entry.clearTagHighlighting();
                        }
                    } else {
                        entry.clearTagHighlighting();
                    }
                }

                if (query === "") {
                    for (const entry of entries) {
                        entry.clearTagHighlighting();
                    }
                }
                checkDropHintVisibility();
            }

            function logToConsole(
                message,
                type = "info",
                isPreformatted = false
            ) {
                if (!consoleOutputElement) return;

                const messageDiv = document.createElement("div");
                messageDiv.classList.add("console-message", type);

                if (typeof message === "object") {
                    try {
                        message = JSON.stringify(message, null, 2);
                        isPreformatted = true;
                    } catch (e) {
                        message = String(message);
                    }
                } else {
                    message = String(message);
                }

                if (isPreformatted) {
                    const pre = document.createElement("pre");
                    pre.textContent = message;
                    messageDiv.appendChild(pre);
                } else {
                    messageDiv.textContent = message;
                }

                consoleOutputElement.appendChild(messageDiv);
                consoleOutputElement.scrollTop =
                    consoleOutputElement.scrollHeight;
            }

            function toggleDevConsole(focusInput = true) {
                if (!devConsoleElement || !mainView) return;

                isConsoleVisible = !isConsoleVisible;
                if (isConsoleVisible) {
                    // Ensure mainView is the flex container for the console
                    const consoleParent = devConsoleElement.parentElement;
                    if (
                        consoleParent !== mainView &&
                        mainView.contains(devConsoleElement)
                    ) {
                        // This case should ideally not happen if HTML structure is correct
                        console.warn(
                            "Developer console is not a direct child of main-view. Layout might be unexpected."
                        );
                    } else if (consoleParent !== mainView) {
                        // If console is elsewhere, this logic might need adjustment or be removed
                        // For now, assuming it's meant to be part of mainView's flex layout
                    }

                    const mainViewHeight = mainView.clientHeight;
                    const consoleHeight = Math.min(
                        mainViewHeight * (CONSOLE_MAX_HEIGHT_PERCENT / 100),
                        300
                    );
                    devConsoleElement.style.maxHeight = `${consoleHeight}px`;
                    devConsoleElement.classList.add("visible");

                    if (consoleCodeMirrorInstance && focusInput) {
                        consoleCodeMirrorInstance.focus();
                        consoleCodeMirrorInstance.refresh();
                    }

                    if (
                        !hasShownConsoleWelcomeMessage &&
                        consoleCodeMirrorInstance &&
                        consoleCodeMirrorInstance.getValue().trim() === ""
                    ) {
                        logToConsole(
                            "Console opened. Type /help or JS code. Ctrl+Space for hints. Up/Down for history.",
                            "info"
                        );
                        hasShownConsoleWelcomeMessage = true;
                    }
                } else {
                    devConsoleElement.style.maxHeight = "0";
                    devConsoleElement.classList.remove("visible");

                    if (consoleCodeMirrorInstance) {
                        consoleCodeMirrorInstance.getInputField().blur();
                    }
                }

                // Refresh CodeMirror after transition if it became visible
                // and ensure focus if requested.
                setTimeout(() => {
                    if (isConsoleVisible && consoleCodeMirrorInstance) {
                        consoleCodeMirrorInstance.refresh();
                        if (
                            focusInput &&
                            document.activeElement !==
                                consoleCodeMirrorInstance.getInputField()
                        ) {
                            consoleCodeMirrorInstance.focus();
                        }
                    }
                }, 310); // Slightly after transition duration
            }

            function processConsoleInput(inputValue) {
                if (inputValue.startsWith("/")) {
                    const parts =
                        inputValue.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
                    if (parts.length === 0) return;

                    const commandName = parts[0].substring(1).toLowerCase();
                    const args = parts.map((p) =>
                        p.startsWith('"') && p.endsWith('"')
                            ? p.slice(1, -1)
                            : p
                    );

                    const commandObject = slashCommands[commandName];
                    if (
                        commandObject &&
                        typeof commandObject.func === "function"
                    ) {
                        try {
                            const result = commandObject.func(args);
                            if (result !== undefined) {
                                logToConsole(
                                    result,
                                    "success",
                                    typeof result === "object" ||
                                        (typeof result === "string" &&
                                            result.includes("\n"))
                                );
                            }
                        } catch (e) {
                            logToConsole(
                                `Error executing command /${commandName}: ${e.message}`,
                                "error"
                            );
                            console.error(`Command /${commandName} error:`, e);
                        }
                    } else {
                        logToConsole(
                            `Unknown command: ${parts[0]}. Type /help for available commands.`,
                            "error"
                        );
                    }
                } else {
                    try {
                        const result = (function (api) {
                            const apiKeys = Object.keys(api);

                            const P = new Proxy(api, {
                                get(target, prop, receiver) {
                                    if (apiKeys.includes(prop))
                                        return target[prop];
                                    if (prop in window) {
                                        if (typeof window[prop] === "function")
                                            return window[prop].bind(window);
                                        return window[prop];
                                    }
                                    return undefined;
                                },
                            });

                            return eval.call(P, `with(this) { ${inputValue} }`);
                        })(opentaggerAPI);

                        if (result !== undefined) {
                            logToConsole(
                                result,
                                "info",
                                typeof result === "object" ||
                                    (typeof result === "string" &&
                                        result.includes("\n"))
                            );
                        }
                    } catch (e) {
                        logToConsole(String(e), "error");
                        console.error("JS execution error:", e);
                    }
                }
            }

            function showMainAppUI() {
                if (splashScreenElement) {
                    splashScreenElement.classList.add("hidden");
                }
                // appContainer is now the tab-container, it's always "loaded" after splash
                // The visibility of its content (tagging or preferences) is handled by the tab-container itself.

                checkDropHintVisibility(); // Still relevant for the tagging tab

                // Ensure elements are queried after potential tab switches or initial load
                const currentMainContentArea =
                    document.getElementById("main-content-area");
                if (currentMainContentArea) {
                    for (const entry of currentMainContentArea.querySelectorAll(
                        "dataset-entry"
                    )) {
                        entry.checkGroupRequirementsAndUpdateVisuals();
                    }
                }

                sfx.sfxWelcome.play();

                // If the "Tagging" tab is active and console is visible, refresh CodeMirror
                const appTabContainer = document.getElementById("app"); // This is the tab-container
                if (
                    appTabContainer &&
                    appTabContainer.activeTab === "tagging"
                ) {
                    if (isConsoleVisible && consoleCodeMirrorInstance) {
                        setTimeout(() => {
                            if (consoleCodeMirrorInstance)
                                consoleCodeMirrorInstance.refresh();
                        }, 50); // Delay refresh slightly
                    }
                }
            }

            function clearWorkspaceForNewProject() {
                const groupListContainer =
                    document.getElementById("tag-group-list");
                if (groupListContainer) {
                    groupListContainer.innerHTML = "";
                }

                const currentMainContentArea =
                    document.getElementById("main-content-area");
                if (currentMainContentArea) {
                    const currentEntries =
                        currentMainContentArea.querySelectorAll(
                            "dataset-entry"
                        );

                    for (const el of currentEntries) {
                        el.deleteEntry();
                    }
                }

                const currentSearchInput =
                    document.getElementById("search-bar");
                if (currentSearchInput) {
                    currentSearchInput.value = "";
                    filterEntries(""); // Make sure filterEntries uses the potentially new searchInput if DOM was cleared
                }

                opentaggerAPI.deselectAllEntries(true);

                checkDropHintVisibility();
                console.log("Workspace cleared for new project.");
            }

            document.addEventListener("DOMContentLoaded", () => {
                appContainer = document.getElementById("app"); // Now the tab-container
                splashScreenElement = document.getElementById("splash-screen");

                // These elements are inside the "tagging" tab, so they might not be immediately available
                // if another tab is active by default. Query them when needed or ensure tagging tab is default.
                mainView = document.getElementById("main-view");
                mainContentAreaElement =
                    document.getElementById("main-content-area");

                if (mainContentAreaElement) {
                    dropHint =
                        mainContentAreaElement.querySelector(".drop-hint");
                } else {
                    // This might happen if "preferences" tab is active first.
                    // console.warn("mainContentAreaElement not found during DOMContentLoaded (possibly due to inactive tab).");
                }

                searchInput = document.getElementById("search-bar");
                autotagAllButton =
                    document.getElementById("autotag-all-button");

                devConsoleElement =
                    document.getElementById("developer-console");
                consoleOutputElement =
                    document.getElementById("console-output");
                const consoleTextArea =
                    document.getElementById("console-input");

                const preferencesPanel =
                    document.getElementById("preferences-panel");
                if (preferencesPanel) {
                    generatePreferencesUI(preferences, preferencesPanel);
                } else {
                    console.error("Preferences panel element not found.");
                }

                globalTagAutocompleteDropdown = document.getElementById(
                    "tag-autocomplete-dropdown"
                );
                if (!globalTagAutocompleteDropdown) {
                    console.error(
                        "AutocompleteDropdown element (#tag-autocomplete-dropdown) not found in DOM!"
                    );
                }

                loadBooruTags().then((tags) => {
                    if (tags.length > 0) {
                        console.log("Booru tags ready for autocomplete.");
                    } else {
                        console.warn(
                            "Booru tags could not be loaded. Tag autocomplete will not be available."
                        );
                    }
                });

                if (consoleTextArea && typeof CodeMirror !== "undefined") {
                    consoleCodeMirrorInstance = CodeMirror.fromTextArea(
                        consoleTextArea,
                        {
                            mode: "javascript",
                            theme: "neat",
                            lineWrapping: true,
                            autoCloseBrackets: true,
                            matchBrackets: true,
                            extraKeys: {
                                Enter: (cm) => {
                                    const inputValue = cm.getValue().trim();
                                    if (inputValue === "") return;

                                    logToConsole(`> ${inputValue}`, "command");
                                    cm.setValue("");
                                    processConsoleInput(inputValue);

                                    if (
                                        consoleHistory.length === 0 ||
                                        consoleHistory[
                                            consoleHistory.length - 1
                                        ] !== inputValue
                                    ) {
                                        consoleHistory.push(inputValue);
                                    }
                                    if (consoleHistory.length > 50)
                                        consoleHistory.shift();
                                    consoleHistoryIndex = consoleHistory.length;
                                    currentConsoleInputBuffer = "";
                                },
                                Up: (cm) => {
                                    if (
                                        consoleHistoryIndex ===
                                            consoleHistory.length &&
                                        cm.getValue() !== ""
                                    ) {
                                        currentConsoleInputBuffer =
                                            cm.getValue();
                                    }
                                    if (consoleHistoryIndex > 0) {
                                        consoleHistoryIndex--;
                                        cm.setValue(
                                            consoleHistory[consoleHistoryIndex]
                                        );
                                        cm.setCursor(cm.lineCount(), 0);
                                    }
                                    return true;
                                },
                                Down: (cm) => {
                                    if (
                                        consoleHistoryIndex <
                                        consoleHistory.length - 1
                                    ) {
                                        consoleHistoryIndex++;
                                        cm.setValue(
                                            consoleHistory[consoleHistoryIndex]
                                        );
                                        cm.setCursor(cm.lineCount(), 0);
                                    } else if (
                                        consoleHistoryIndex ===
                                        consoleHistory.length - 1
                                    ) {
                                        consoleHistoryIndex++;
                                        cm.setValue(currentConsoleInputBuffer);
                                        currentConsoleInputBuffer = "";
                                        cm.setCursor(cm.lineCount(), 0);
                                    }
                                    return true;
                                },
                                Esc: (cm) => {
                                    if (isConsoleVisible)
                                        toggleDevConsole(false);
                                },
                                "Ctrl-Space": "autocomplete",
                            },
                            hintOptions: {
                                hint: customCodeMirrorHints,
                                completeSingle: false,
                            },
                        }
                    );

                    consoleCodeMirrorInstance.on(
                        "inputRead",
                        function (cm, event) {
                            if (
                                cm.state.completionActive ||
                                !event ||
                                event.origin === "+delete" ||
                                event.origin === "paste" ||
                                /[ ;\),\(\]\}\[\{]/.test(event.text[0]) ||
                                event.key === "Enter" ||
                                event.key === "Escape" ||
                                (event.key && event.key.includes("Arrow"))
                            ) {
                                return;
                            }
                            CodeMirror.commands.autocomplete(cm, null, {
                                completeSingle: false,
                            });
                        }
                    );
                } else if (!consoleTextArea) {
                    console.warn(
                        "Console textarea (#console-input) not found for CodeMirror."
                    );
                } else if (typeof CodeMirror === "undefined") {
                    console.warn(
                        "CodeMirror library not loaded. Console will use basic textarea."
                    );
                    if (consoleTextArea) {
                        consoleTextArea.addEventListener("keydown", (e) => {
                            if (e.key === "Enter" && !e.shiftKey) {
                                e.preventDefault();
                                const inputValue = consoleTextArea.value.trim();
                                if (inputValue === "") return;
                                logToConsole(`> ${inputValue}`, "command");
                                processConsoleInput(inputValue);
                                consoleTextArea.value = "";
                            } else if (e.key === "Escape") {
                                if (isConsoleVisible) toggleDevConsole(false);
                            }
                        });
                    }
                }

                document.addEventListener("keydown", (event) => {
                    if (event.key === "F1") {
                        event.preventDefault();
                        if (
                            splashScreenElement &&
                            !splashScreenElement.classList.contains("hidden")
                        ) {
                            return;
                        }

                        // Check if focus is inside an input field that is NOT the console's CodeMirror instance
                        const targetTagName =
                            event.target.tagName.toLowerCase();
                        const isGenericInput =
                            targetTagName === "input" ||
                            targetTagName === "textarea" ||
                            event.target.isContentEditable;
                        const isConsoleInput =
                            consoleCodeMirrorInstance &&
                            event.target ===
                                consoleCodeMirrorInstance.getInputField();

                        if (isGenericInput && !isConsoleInput) {
                            return; // Don't toggle console if focus is in a regular input/textarea
                        }
                        toggleDevConsole();
                    }
                });

                if (
                    window.location.origin &&
                    window.location.origin !== "null"
                ) {
                    console.log("Frontend Origin:", window.location.origin);
                } else {
                    console.warn(
                        "Frontend Origin is 'null' or not available (likely file:// URL). Some fetch operations to localhost might be restricted by CORS if backend isn't configured for 'null' origin."
                    );
                }

                const groupListContainer =
                    document.getElementById("tag-group-list");
                const addGroupButton = document.getElementById("btn-add-group");
                const projectFileInput =
                    document.getElementById("project-file-input");
                const datasetZipInput =
                    document.getElementById("dataset-zip-input");

                const splashNewProjectBtn =
                    document.getElementById("splash-new-project");
                const splashOpenProjectBtn = document.getElementById(
                    "splash-open-project"
                );

                if (splashNewProjectBtn) {
                    splashNewProjectBtn.addEventListener("click", () => {
                        clearWorkspaceForNewProject();
                        showMainAppUI();
                    });
                }
                if (splashOpenProjectBtn) {
                    splashOpenProjectBtn.addEventListener("click", () => {
                        if (projectFileInput) projectFileInput.click();
                    });
                }

                if (projectFileInput) {
                    projectFileInput.addEventListener(
                        "change",
                        handleProjectFileSelect
                    );
                }
                if (datasetZipInput) {
                    datasetZipInput.addEventListener(
                        "change",
                        handleDatasetZipSelect
                    );
                }

                if (autotagAllButton) {
                    autotagAllButton.addEventListener(
                        "click",
                        handleAutotagAllClick
                    );
                }

                if (searchInput) {
                    const debouncedFilter = debounce(filterEntries, 300);
                    searchInput.addEventListener("input", () =>
                        debouncedFilter(searchInput.value)
                    );
                }

                // Drag and drop for main-view (which is inside tagging-panel)
                // This needs to be attached to mainView if it exists, or its parent panel.
                const taggingPanel = document.getElementById("tagging-panel");
                if (taggingPanel) {
                    // Attach to the panel that contains mainView
                    taggingPanel.addEventListener("dragenter", (e) => {
                        if (e.dataTransfer.types.includes("Files")) {
                            e.preventDefault();
                            e.stopPropagation();
                            // Add visual cue to the panel or a specific drop zone within it
                            if (mainView) mainView.classList.add("drag-over");
                            else taggingPanel.classList.add("drag-over"); // Fallback
                            e.dataTransfer.dropEffect = "copy";
                        }
                    });
                    taggingPanel.addEventListener("dragover", (e) => {
                        if (e.dataTransfer.types.includes("Files")) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.dataTransfer.dropEffect = "copy";
                        } else {
                            e.dataTransfer.dropEffect = "none";
                        }
                    });
                    taggingPanel.addEventListener("dragleave", (e) => {
                        const currentTarget = mainView || taggingPanel;
                        if (
                            !currentTarget.contains(e.relatedTarget) ||
                            e.target === currentTarget
                        ) {
                            currentTarget.classList.remove("drag-over");
                        }
                    });
                    taggingPanel.addEventListener("drop", (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const currentTarget = mainView || taggingPanel;
                        currentTarget.classList.remove("drag-over");

                        if (
                            e.dataTransfer.files?.length > 0 &&
                            !draggedElement // Ensure not a tag drag from within the app
                        ) {
                            const droppedFile = e.dataTransfer.files[0];
                            if (
                                droppedFile &&
                                droppedFile.name.endsWith(
                                    PROJECT_FILE_EXTENSION
                                )
                            ) {
                                handleProjectFileSelect({
                                    target: { files: [droppedFile] },
                                });
                            } else if (
                                droppedFile &&
                                droppedFile.name.endsWith(".zip")
                            ) {
                                handleDatasetZipSelect({
                                    target: { files: [droppedFile] },
                                });
                            } else {
                                handleFiles(e.dataTransfer.files);
                            }
                        } else {
                            console.log(
                                "Drop event on tagging panel ignored (not files or handled by child)."
                            );
                        }
                    });
                }

                function handleFiles(files) {
                    if (!mainContentAreaElement || !searchInput) {
                        // Try to get them again if they were not available initially
                        if (!mainContentAreaElement)
                            mainContentAreaElement =
                                document.getElementById("main-content-area");
                        if (!searchInput)
                            searchInput = document.getElementById("search-bar");
                        if (!mainContentAreaElement || !searchInput) {
                            console.error(
                                "Cannot handle files: main content area or search input not found."
                            );
                            showConfirmationModal(
                                "Error: UI components for tagging are not ready. Cannot add files.",
                                [{ text: "OK" }]
                            );
                            return;
                        }
                    }
                    for (const file of files) {
                        if (file.type.startsWith("image/")) {
                            const blobUrl = URL.createObjectURL(file);
                            const entry =
                                document.createElement("dataset-entry");
                            entry.setImage(blobUrl, file);

                            let referenceNode = dropHint?.isConnected
                                ? dropHint
                                : mainContentAreaElement.firstChild; // Fallback if dropHint is gone or not found

                            mainContentAreaElement.insertBefore(
                                entry,
                                referenceNode
                            );

                            if (searchInput.value.trim() !== "") {
                                const currentQuery = searchInput.value
                                    .trim()
                                    .toLowerCase();
                                const tags = entry.getNormalizedTags();
                                const isMatch = evaluateExpression(
                                    currentQuery,
                                    tags
                                );
                                entry.style.display = isMatch ? "" : "none";
                                if (
                                    isMatch &&
                                    globalParsedSearchTerms.length > 0
                                ) {
                                    entry.applyTagHighlighting(
                                        globalParsedSearchTerms,
                                        globalSearchTermColors
                                    );
                                } else {
                                    entry.clearTagHighlighting();
                                }
                            } else {
                                entry.clearTagHighlighting();
                            }
                        } else if (file.name.endsWith(PROJECT_FILE_EXTENSION)) {
                            handleProjectFileSelect({
                                target: { files: [file] },
                            });
                        } else if (file.name.endsWith(".zip")) {
                            handleDatasetZipSelect({
                                target: { files: [file] },
                            });
                        } else {
                            console.warn(
                                `Skipped non-image file: ${file.name}`
                            );
                        }
                    }
                    checkDropHintVisibility();
                }

                if (addGroupButton) {
                    addGroupButton.addEventListener("click", () => {
                        const cat = document.createElement("tag-group");
                        cat.setAttribute("group-name", "New Cat");
                        if (groupListContainer)
                            groupListContainer.appendChild(cat);
                        const span = cat.querySelector(".group-name");
                        if (span) {
                            requestAnimationFrame(() => {
                                span.focus();

                                window.getSelection().selectAllChildren(span);
                            });
                        }
                    });
                }

                const menuBarButtons =
                    document.querySelectorAll("#menu-bar button");

                for (const button of menuBarButtons) {
                    button.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        if (
                            splashScreenElement &&
                            !splashScreenElement.classList.contains("hidden")
                        ) {
                            const buttonAction = button.textContent
                                .trim()
                                .toLowerCase();

                            // If splash screen is visible, only allow File > New/Load actions
                            // or actions that implicitly hide the splash screen.
                            // For now, let's assume most menu actions should proceed to show the main app.
                            // A more refined logic could be added here if specific menus should be disabled.
                            if (
                                buttonAction !== "file" &&
                                buttonAction !== "help"
                            ) {
                                // Example: allow File and Help
                                // Potentially show a message or do nothing if other menus are clicked on splash
                                // For now, we'll let it try to open the menu, which might trigger showMainAppUI
                            }
                        }

                        if (
                            currentContextMenu &&
                            currentContextMenu.classList.contains("visible") &&
                            currentContextMenu._ownerButton === button
                        ) {
                            currentContextMenu.hide();
                            return;
                        }

                        const type = button.textContent.trim().toLowerCase();
                        let items = [];
                        switch (type) {
                            case "file":
                                items = [
                                    {
                                        label: "New Project",
                                        callback: () => {
                                            clearWorkspaceForNewProject();
                                            showMainAppUI(); // Ensure main app is visible
                                            // If tab-container is used, ensure 'tagging' tab is active
                                            const appTabs =
                                                document.getElementById("app");
                                            if (
                                                appTabs &&
                                                typeof appTabs.activateTab ===
                                                    "function"
                                            ) {
                                                appTabs.activateTab(
                                                    appTabs.sanitizeId(
                                                        "tagging"
                                                    )
                                                );
                                            }
                                        },
                                        dataAction: "new-project",
                                    },
                                    { type: "divider" },
                                    {
                                        label: "Save Project",
                                        callback: () => {
                                            if (
                                                splashScreenElement &&
                                                !splashScreenElement.classList.contains(
                                                    "hidden"
                                                )
                                            ) {
                                                showMainAppUI();
                                            }
                                            saveProject();
                                        },
                                        dataAction: "save-project",
                                    },
                                    {
                                        label: "Load Project...",
                                        callback: () => {
                                            if (projectFileInput)
                                                projectFileInput.click();
                                            // showMainAppUI will be called after successful load
                                        },
                                    },
                                    { type: "divider" },

                                    {
                                        label: "Import Dataset (ZIP)...",
                                        callback: () => {
                                            if (datasetZipInput)
                                                datasetZipInput.click();
                                            // showMainAppUI will be called after successful import
                                        },
                                        dataAction: "import-dataset-zip",
                                    },
                                    {
                                        label: "Export Dataset (ZIP)",
                                        dataAction: "export",
                                        callback: () => {
                                            if (
                                                splashScreenElement &&
                                                !splashScreenElement.classList.contains(
                                                    "hidden"
                                                )
                                            ) {
                                                showMainAppUI();
                                            }
                                            confirmAndExportDataset();
                                        },
                                    },
                                ];
                                break;
                            case "edit":
                                items = [
                                    { label: "Undo (NYI)", disabled: true },
                                    { label: "Redo (NYI)", disabled: true },
                                    { type: "divider" },
                                    {
                                        label: "Clear Search",
                                        callback: () => {
                                            if (searchInput)
                                                searchInput.value = "";
                                            filterEntries("");
                                        },
                                        disabled: () =>
                                            !searchInput ||
                                            document.getElementById("app")
                                                ?.activeTab !== "tagging",
                                    },
                                    { type: "divider" },
                                    {
                                        label: "Select All Visible",
                                        callback: () =>
                                            opentaggerAPI.selectEntries(
                                                "",
                                                false
                                            ),
                                        disabled: () =>
                                            document.getElementById("app")
                                                ?.activeTab !== "tagging",
                                    },
                                    {
                                        label: "Deselect All",
                                        callback: () =>
                                            opentaggerAPI.deselectAllEntries(),
                                        disabled: () =>
                                            document.getElementById("app")
                                                ?.activeTab !== "tagging",
                                    },
                                    // { type: "divider" },
                                    // { label: "Preferences...", callback: () => {
                                    //     const appTabs = document.getElementById('app');
                                    //     if (appTabs && typeof appTabs.activateTab === 'function') {
                                    //        appTabs.activateTab(appTabs.sanitizeId('preferences'));
                                    //     }
                                    //     showMainAppUI(); // Ensure app is visible if coming from splash
                                    // }},
                                ];
                                break;
                            case "view":
                                items = [
                                    { label: "Zoom In (NYI)", disabled: true },
                                    { label: "Zoom Out (NYI)", disabled: true },
                                    { type: "divider" },
                                    {
                                        label: "Re-check All Requirements",
                                        callback: () => {
                                            const currentMainContentArea =
                                                document.getElementById(
                                                    "main-content-area"
                                                );
                                            if (!currentMainContentArea) return;

                                            for (const entry of currentMainContentArea.querySelectorAll(
                                                "dataset-entry"
                                            )) {
                                                entry.checkGroupRequirementsAndUpdateVisuals();
                                            }
                                            console.log(
                                                "Manually re-checked all entry requirements."
                                            );
                                        },
                                        disabled: () =>
                                            document.getElementById("app")
                                                ?.activeTab !== "tagging",
                                    },
                                ];
                                break;
                            case "help":
                                items = [
                                    { label: "About (NYI)", disabled: true },
                                ];
                                break;
                            default:
                                return; // Don't create a menu if button type is unknown
                        }
                        if (items.length > 0) createContextMenu(items, button);
                    });
                }

                document.addEventListener("contextmenu", (e) => {
                    currentContextMenu?.hide();

                    if (
                        splashScreenElement &&
                        !splashScreenElement.classList.contains("hidden")
                    ) {
                        const onSplash = e.target.closest("#splash-screen");
                        if (!onSplash) {
                            // If context menu is outside splash, prevent it
                            e.preventDefault();
                        }
                        // Allow native context menu on splash screen elements themselves
                        return;
                    }

                    // If the context menu is on a tab button, let the tab-container handle it or allow native.
                    if (
                        e.target
                            .closest("tab-container")
                            ?.shadowRoot.contains(e.target) &&
                        e.target.closest('[role="tablist"]')
                    ) {
                        return;
                    }

                    if (
                        e.target.closest(
                            "dataset-tag, dataset-entry, tag-group"
                        )
                    ) {
                        // These elements have their own context menus
                        return;
                    }
                    if (
                        globalTagAutocompleteDropdown &&
                        globalTagAutocompleteDropdown.contains(e.target)
                    ) {
                        // Allow context menu on the autocomplete dropdown itself if needed (currently not)
                        // Or prevent default here: e.preventDefault();
                        return;
                    }

                    const targetTagName = e.target.tagName.toLowerCase();
                    if (
                        e.target.closest('span[contenteditable="true"]') ||
                        targetTagName === "input" ||
                        targetTagName === "textarea" ||
                        (consoleCodeMirrorInstance &&
                            consoleCodeMirrorInstance
                                .getWrapperElement()
                                .contains(e.target))
                    ) {
                        // Allow native context menu for text editing areas
                        return;
                    }

                    e.preventDefault();
                    e.stopPropagation();

                    const appTabs = document.getElementById("app");
                    const isTaggingTabActive =
                        appTabs && appTabs.activeTab === "tagging";

                    const generalItems = [
                        {
                            label: "Add Group", // Changed from "Add Tags"
                            callback: () => {
                                if (addGroupButton) addGroupButton.click();
                            },
                            disabled: !isTaggingTabActive,
                        },
                        { type: "divider" },
                        {
                            label: "Autotag All Visible",
                            callback: () => handleAutotagAllClick(),
                            disabled: !isTaggingTabActive,
                        },
                        {
                            label: "Re-check All Requirements",
                            callback: () => {
                                const currentMainContentArea =
                                    document.getElementById(
                                        "main-content-area"
                                    );
                                if (!currentMainContentArea) return;

                                for (const entry of currentMainContentArea.querySelectorAll(
                                    "dataset-entry"
                                )) {
                                    entry.checkGroupRequirementsAndUpdateVisuals();
                                }
                            },
                            disabled: !isTaggingTabActive,
                        },
                        { type: "divider" },
                        {
                            label: "Select All Visible",
                            callback: () =>
                                opentaggerAPI.selectEntries("", false),
                            disabled: !isTaggingTabActive,
                        },
                        {
                            label: "Deselect All",
                            callback: () => opentaggerAPI.deselectAllEntries(),
                            disabled: !isTaggingTabActive,
                        },
                    ];
                    createContextMenu(generalItems, e);
                });

                document.addEventListener("group-min-tags-changed", () => {
                    const currentMainContentArea =
                        document.getElementById("main-content-area");
                    if (!currentMainContentArea) return;

                    for (const entry of currentMainContentArea.querySelectorAll(
                        "dataset-entry"
                    )) {
                        entry.checkGroupRequirementsAndUpdateVisuals();
                    }
                });

                // Initial check for drop hint visibility if app is already "loaded" (splash hidden)
                // This is less relevant now as tab-container handles initial display.
                // The checkDropHintVisibility will be called by showMainAppUI or when files are added.
                if (
                    splashScreenElement &&
                    splashScreenElement.classList.contains("hidden")
                ) {
                    checkDropHintVisibility();
                }

                // Observe mainContentArea for changes to update dropHint and entry requirements
                // This needs to be robust if mainContentAreaElement is initially null (e.g. preferences tab active)
                const setupMainContentObserver = () => {
                    if (!mainContentAreaElement) {
                        mainContentAreaElement =
                            document.getElementById("main-content-area");
                    }
                    if (mainContentAreaElement) {
                        const mainContentObserver = new MutationObserver(
                            (mutationsList) => {
                                let listChanged = false;
                                for (const mutation of mutationsList) {
                                    if (mutation.type === "childList") {
                                        const addedEntries = Array.from(
                                            mutation.addedNodes
                                        ).filter(
                                            (node) =>
                                                node.tagName === "DATASET-ENTRY"
                                        );
                                        const removedEntries = Array.from(
                                            mutation.removedNodes
                                        ).filter(
                                            (node) =>
                                                node.tagName === "DATASET-ENTRY"
                                        );

                                        if (
                                            addedEntries.length > 0 ||
                                            removedEntries.length > 0
                                        ) {
                                            listChanged = true;

                                            for (const entry of addedEntries) {
                                                requestAnimationFrame(() =>
                                                    entry.checkGroupRequirementsAndUpdateVisuals()
                                                );
                                            }
                                            if (
                                                globalLastClickedEntryForShiftSelect &&
                                                removedEntries.includes(
                                                    globalLastClickedEntryForShiftSelect
                                                )
                                            ) {
                                                globalLastClickedEntryForShiftSelect =
                                                    null;
                                            }
                                            break;
                                        }
                                    }
                                }
                                if (listChanged) checkDropHintVisibility();
                            }
                        );
                        mainContentObserver.observe(mainContentAreaElement, {
                            childList: true,
                        });

                        mainContentAreaElement.addEventListener(
                            "entry-deleted",
                            () => checkDropHintVisibility()
                        );
                        // Initial check after observer is set up
                        checkDropHintVisibility();
                        for (const entry of mainContentAreaElement.querySelectorAll(
                            "dataset-entry"
                        )) {
                            entry.checkGroupRequirementsAndUpdateVisuals();
                        }
                    } else {
                        console.warn(
                            "Main content area not found for observer setup."
                        );
                    }
                };

                // If the app container is a tab-container, set up observer when tagging tab becomes active
                if (appContainer && appContainer.tagName === "TAB-CONTAINER") {
                    if (appContainer.activeTab === "tagging") {
                        setupMainContentObserver();
                    }
                    appContainer.addEventListener("tab-change", (e) => {
                        if (e.detail.activeTabId === "tagging") {
                            // Ensure elements are re-queried if they weren't available before
                            if (!mainContentAreaElement)
                                mainContentAreaElement =
                                    document.getElementById(
                                        "main-content-area"
                                    );
                            if (!mainView)
                                mainView = document.getElementById("main-view");
                            if (!searchInput)
                                searchInput =
                                    document.getElementById("search-bar");
                            if (!autotagAllButton)
                                autotagAllButton =
                                    document.getElementById(
                                        "autotag-all-button"
                                    );
                            if (!devConsoleElement)
                                devConsoleElement =
                                    document.getElementById(
                                        "developer-console"
                                    );
                            if (!consoleOutputElement)
                                consoleOutputElement =
                                    document.getElementById("console-output");
                            if (
                                mainContentAreaElement &&
                                !mainContentAreaElement.hasAttribute(
                                    "data-observer-set"
                                )
                            ) {
                                setupMainContentObserver();
                                mainContentAreaElement.setAttribute(
                                    "data-observer-set",
                                    "true"
                                );
                            } else if (mainContentAreaElement) {
                                // Refresh visibility and requirements if tab is re-activated
                                checkDropHintVisibility();
                                for (const entry of mainContentAreaElement.querySelectorAll(
                                    "dataset-entry"
                                )) {
                                    entry.checkGroupRequirementsAndUpdateVisuals();
                                }
                            }
                            // Refresh CodeMirror if console is visible
                            if (isConsoleVisible && consoleCodeMirrorInstance) {
                                setTimeout(() => {
                                    if (consoleCodeMirrorInstance)
                                        consoleCodeMirrorInstance.refresh();
                                }, 50); // Delay refresh slightly
                            }
                        }
                    });
                } else {
                    // Fallback for non-tab-container structure (original behavior)
                    setupMainContentObserver();
                }
            }); // End of DOMContentLoaded

            async function saveProject() {
                console.log("Starting project save...");
                showConfirmationModal("Saving project...", []);

                const groups = [];

                for (const catElement of document.querySelectorAll(
                    "#tag-group-list tag-group"
                )) {
                    groups.push({
                        name:
                            catElement.getAttribute("group-name") ||
                            "Unnamed Group",
                        minimumTags: catElement.minimumTags,
                        tags: catElement.getGroupTags(),
                    });
                }

                const entries = [];
                const currentMainContentArea =
                    document.getElementById("main-content-area"); // Re-query in case of tab changes
                if (!currentMainContentArea) {
                    console.error(
                        "Cannot save project: mainContentAreaElement element not found."
                    );
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        "Error saving project: UI elements missing.",
                        [{ text: "OK" }]
                    );
                    return;
                }
                const entryElements =
                    currentMainContentArea.querySelectorAll("dataset-entry");
                const imageSavePromises = [];
                const zip = new JSZip();
                const imagesFolder = zip.folder("images");

                const usedImageNames = new Set();

                for (const entryElement of entryElements) {
                    const originalName =
                        entryElement.originalImageName ||
                        `entry_${Date.now()}.png`;

                    let safeName = sanitizeFilename(originalName);
                    let uniqueName = safeName;
                    let counter = 1;
                    while (usedImageNames.has(uniqueName.toLowerCase())) {
                        const extension = uniqueName.includes(".")
                            ? uniqueName.substring(uniqueName.lastIndexOf("."))
                            : "";
                        const base = uniqueName.includes(".")
                            ? uniqueName.substring(
                                  0,
                                  uniqueName.lastIndexOf(".")
                              )
                            : uniqueName;

                        const baseWithoutCounter = base.replace(/_\d+$/, "");
                        uniqueName = `${baseWithoutCounter}_${counter++}${extension}`;
                    }
                    usedImageNames.add(uniqueName.toLowerCase());

                    entries.push({
                        imageName: uniqueName,
                        tags: entryElement.getTags(),
                    });

                    imageSavePromises.push(
                        entryElement
                            .getImageData()
                            .then((imageData) => {
                                if (imageData) {
                                    imagesFolder.file(uniqueName, imageData, {
                                        binary: true,
                                    });
                                } else {
                                    console.warn(
                                        `Could not get image data for entry originally named: ${originalName}. Skipping image file.`
                                    );

                                    throw new Error(
                                        `Missing image data for ${originalName}`
                                    );
                                }
                            })
                            .catch((err) => {
                                console.error(
                                    `Error processing image for ${originalName}:`,
                                    err
                                );
                                return {
                                    status: "rejected",
                                    reason: `Failed to process image: ${originalName}`,
                                };
                            })
                    );
                }

                const projectData = {
                    version: 1,
                    groups: groups,
                    entries: entries,
                };
                zip.file("project.json", JSON.stringify(projectData, null, 2));

                const results = await Promise.allSettled(imageSavePromises);
                document.querySelector(".modal-overlay")?.remove();

                const failedImages = results.filter(
                    (r) => r.status === "rejected"
                );
                if (failedImages.length > 0) {
                    console.error(
                        `${failedImages.length} image(s) failed to save.`
                    );
                    showConfirmationModal(
                        `Warning: ${failedImages.length} image(s) could not be read or saved. The project file might be incomplete. Save anyway?`,
                        [
                            {
                                text: "Save Anyway",
                                onClick: () =>
                                    generateAndDownloadZip(zip, "Save Project"),
                                class: "modal-button-confirm",
                            },
                            {
                                text: "Cancel",
                                onClick: () =>
                                    console.log(
                                        "Project save cancelled due to image errors."
                                    ),
                                class: "modal-button-cancel",
                            },
                        ]
                    );
                } else {
                    generateAndDownloadZip(zip, "Save Project");
                }
            }

            async function generateAndDownloadZip(
                zip,
                menuActionText = "Processing..."
            ) {
                const menuSave = document.querySelector(
                    'menu-item[data-action="save-project"]'
                );
                const menuExport = document.querySelector(
                    'menu-item[data-action="export"]'
                );
                const targetMenuItem = menuSave || menuExport;
                const originalText =
                    targetMenuItem?.textContent || menuActionText;

                if (targetMenuItem) {
                    targetMenuItem.textContent = "Zipping...";
                    targetMenuItem.style.pointerEvents = "none";
                } else {
                    showConfirmationModal("Zipping project...", []);
                }

                try {
                    const blob = await zip.generateAsync(
                        {
                            type: "blob",
                            compression: "DEFLATE",
                            compressionOptions: { level: 6 },
                        },
                        (metadata) => {
                            const progressText = `Zipping... (${metadata.percent.toFixed(
                                0
                            )}%)`;
                            if (targetMenuItem)
                                targetMenuItem.textContent = progressText;
                            else {
                                const modalMsg = document.querySelector(
                                    ".modal-overlay .modal-message"
                                );
                                if (modalMsg)
                                    modalMsg.textContent = progressText;
                            }
                        }
                    );
                    document.querySelector(".modal-overlay")?.remove();
                    const filename = menuSave
                        ? `lora_project_${Date.now()}${PROJECT_FILE_EXTENSION}`
                        : "lora_dataset_export.zip";
                    saveAs(blob, filename);
                    console.log("Project saved successfully.");
                    showConfirmationModal(
                        menuSave
                            ? "Project saved successfully!"
                            : "Dataset exported successfully!",
                        [{ text: "OK" }]
                    );
                } catch (err) {
                    console.error("Error generating ZIP:", err);
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        "Error generating file. Check console for details.",
                        [{ text: "OK" }]
                    );
                } finally {
                    if (targetMenuItem) {
                        targetMenuItem.textContent = originalText;
                        targetMenuItem.style.pointerEvents = "auto";
                    }
                }
            }

            function handleProjectFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                event.target.value = null;

                if (!file.name.endsWith(PROJECT_FILE_EXTENSION)) {
                    showConfirmationModal(
                        `Invalid file type. Please select a ${PROJECT_FILE_EXTENSION} file.`,
                        [{ text: "OK" }]
                    );
                    return;
                }

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const zipData = e.target.result;
                        await loadProjectFromZip(zipData);
                        showMainAppUI();
                        // Ensure tagging tab is active after loading a project
                        const appTabs = document.getElementById("app");
                        if (
                            appTabs &&
                            typeof appTabs.activateTab === "function"
                        ) {
                            appTabs.activateTab(appTabs.sanitizeId("tagging"));
                        }
                    } catch (error) {
                        console.error("Error loading project file:", error);
                        document.querySelector(".modal-overlay")?.remove();
                        showConfirmationModal(
                            `Error loading project: ${error.message}. Check console for details.`,
                            [{ text: "OK" }]
                        );
                    }
                };
                reader.onerror = (e) => {
                    console.error("FileReader error:", e);
                    showConfirmationModal("Error reading project file.", [
                        { text: "OK" },
                    ]);
                };
                reader.readAsArrayBuffer(file);
            }

            async function loadProjectFromZip(zipData) {
                console.log("Loading project from zip data...");
                showConfirmationModal("Loading project...", []);

                let zip;
                try {
                    zip = await JSZip.loadAsync(zipData);
                } catch (e) {
                    console.error("Failed to load ZIP data:", e);
                    throw new Error(
                        "Invalid or corrupted project file (could not read as ZIP)."
                    );
                }

                const projectFile = zip.file("project.json");
                if (!projectFile) {
                    throw new Error(
                        "Invalid project file: 'project.json' not found."
                    );
                }
                let projectJson;
                try {
                    projectJson = await projectFile.async("string");
                } catch (e) {
                    console.error("Failed to read project.json:", e);
                    throw new Error(
                        "Could not read 'project.json' from the file."
                    );
                }
                let projectData;
                try {
                    projectData = JSON.parse(projectJson);
                } catch (e) {
                    console.error("Failed to parse project.json:", e);
                    throw new Error(
                        "Invalid project file: Could not parse 'project.json'."
                    );
                }

                if (
                    !projectData ||
                    typeof projectData !== "object" ||
                    projectData.version !== 1
                ) {
                    throw new Error(
                        "Invalid or unsupported project file format/version."
                    );
                }
                if (
                    !Array.isArray(projectData.groups) ||
                    !Array.isArray(projectData.entries)
                ) {
                    throw new Error(
                        "Invalid project data structure (missing groups or entries array)."
                    );
                }

                clearWorkspaceForNewProject();

                console.log(`Loading ${projectData.groups.length} groups...`);
                const groupListContainer =
                    document.getElementById("tag-group-list");

                for (const catData of projectData.groups) {
                    const groupElement = document.createElement("tag-group");
                    groupElement.setAttribute(
                        "group-name",
                        catData.name || "Unnamed"
                    );

                    requestAnimationFrame(() => {
                        groupElement.minimumTags = catData.minimumTags || 0;
                        groupElement.setTags(catData.tags || []);
                    });
                    groupListContainer.appendChild(groupElement);
                }

                console.log(`Loading ${projectData.entries.length} entries...`);
                let loadedCount = 0;
                let errorCount = 0;
                const imageLoadErrors = [];

                const loadingModalMsg = document.querySelector(
                    ".modal-overlay .modal-message"
                );
                if (loadingModalMsg)
                    loadingModalMsg.textContent = `Loading ${projectData.entries.length} entries...`;

                const currentMainContentArea =
                    document.getElementById("main-content-area"); // Re-query

                const entryCreationPromises = projectData.entries.map(
                    async (entryData, index) => {
                        if (
                            !entryData ||
                            typeof entryData.imageName !== "string"
                        ) {
                            console.warn(
                                `Skipping invalid entry data at index ${index}.`
                            );
                            imageLoadErrors.push(
                                `Invalid entry data at index ${index}.`
                            );
                            return null;
                        }

                        const imageName = entryData.imageName;
                        const imageFileInZip = zip.file(`images/${imageName}`);

                        if (!imageFileInZip) {
                            console.warn(
                                `Image '${imageName}' not found in project zip's images/ folder. Skipping entry.`
                            );
                            imageLoadErrors.push(
                                `Image not found in zip: images/${imageName}`
                            );
                            return null;
                        }

                        let blobUrl;
                        try {
                            const imageDataBlob = await imageFileInZip.async(
                                "blob"
                            );
                            blobUrl = URL.createObjectURL(imageDataBlob);

                            const imageFileObject = new File(
                                [imageDataBlob],
                                imageName,
                                { type: imageDataBlob.type }
                            );

                            const entryElement =
                                document.createElement("dataset-entry");
                            entryElement.setImage(blobUrl, imageFileObject);
                            return {
                                element: entryElement,
                                tags: entryData.tags || [],
                            };
                        } catch (err) {
                            console.error(
                                `Error processing entry image '${imageName}':`,
                                err
                            );
                            imageLoadErrors.push(
                                `Error loading ${imageName}: ${err.message}`
                            );
                            if (
                                typeof blobUrl !== "undefined" &&
                                URL.revokeObjectURL
                            )
                                URL.revokeObjectURL(blobUrl);
                            return null;
                        }
                    }
                );

                const processedEntries = await Promise.all(
                    entryCreationPromises
                );

                for (const [index, result] of processedEntries.entries()) {
                    if (result && currentMainContentArea) {
                        let referenceNode =
                            dropHint?.isConnected &&
                            dropHint.parentElement === currentMainContentArea
                                ? dropHint
                                : currentMainContentArea.firstChild; // Fallback

                        currentMainContentArea.insertBefore(
                            result.element,
                            referenceNode
                        );
                        result.element.setTags(result.tags);
                        loadedCount++;
                        if (loadingModalMsg && index % 10 === 0) {
                            loadingModalMsg.textContent = `Loading entry ${
                                index + 1
                            } / ${projectData.entries.length}...`;
                        }
                    } else if (result && !currentMainContentArea) {
                        console.error(
                            "mainContentAreaElement not available to append loaded entry. This is unexpected."
                        );
                        errorCount++;
                    } else if (!result) {
                        errorCount++;
                    }
                }

                document.querySelector(".modal-overlay")?.remove();

                let resultMessage = `Project loaded successfully. ${loadedCount} entries added.`;
                if (errorCount > 0) {
                    resultMessage += ` ${errorCount} error(s) encountered (check console for details).`;
                    console.error(
                        "Errors during project load (image or data issues):",
                        imageLoadErrors
                    );
                }
                showConfirmationModal(resultMessage, [{ text: "OK" }]);
                checkDropHintVisibility();
            }

            async function handleDatasetZipSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                event.target.value = null;

                if (!file.name.endsWith(".zip")) {
                    showConfirmationModal(
                        "Invalid file type. Please select a .zip file for dataset import.",
                        [{ text: "OK" }]
                    );
                    return;
                }

                showConfirmationModal("Importing dataset from ZIP...", []);
                console.log(`Importing dataset from: ${file.name}`);

                try {
                    const zipData = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(zipData);

                    const imageFiles = [];
                    const textFiles = {};

                    zip.forEach((relativePath, zipEntry) => {
                        if (zipEntry.dir) return;

                        const fileName = relativePath.substring(
                            relativePath.lastIndexOf("/") + 1
                        );
                        const lowerFileName = fileName.toLowerCase();

                        if (
                            /\.(jpe?g|png|webp|gif|bmp|tiff)$/i.test(
                                lowerFileName
                            )
                        ) {
                            imageFiles.push(zipEntry);
                        } else if (lowerFileName.endsWith(".txt")) {
                            const baseName = lowerFileName.substring(
                                0,
                                lowerFileName.lastIndexOf(".txt")
                            );
                            textFiles[baseName] = zipEntry.async("string");
                        }
                    });

                    if (imageFiles.length === 0) {
                        document.querySelector(".modal-overlay")?.remove();
                        showConfirmationModal(
                            "No image files found in the ZIP archive.",
                            [{ text: "OK" }]
                        );
                        return;
                    }

                    const loadingModalMsg = document.querySelector(
                        ".modal-overlay .modal-message"
                    );
                    if (loadingModalMsg)
                        loadingModalMsg.textContent = `Processing ${imageFiles.length} images...`;

                    let importedCount = 0;
                    let errorCount = 0;
                    const currentMainContentArea =
                        document.getElementById("main-content-area"); // Re-query

                    for (let i = 0; i < imageFiles.length; i++) {
                        const imageEntry = imageFiles[i];
                        const imageName = imageEntry.name.substring(
                            imageEntry.name.lastIndexOf("/") + 1
                        );
                        if (loadingModalMsg)
                            loadingModalMsg.textContent = `Importing ${i + 1}/${
                                imageFiles.length
                            }: ${imageName}`;

                        try {
                            const imageDataBlob = await imageEntry.async(
                                "blob"
                            );
                            const blobUrl = URL.createObjectURL(imageDataBlob);
                            const imageFileObject = new File(
                                [imageDataBlob],
                                imageName,
                                { type: imageDataBlob.type }
                            );

                            const newEntryElement =
                                document.createElement("dataset-entry");
                            newEntryElement.setImage(blobUrl, imageFileObject);

                            const imageBaseName = imageName
                                .substring(0, imageName.lastIndexOf("."))
                                .toLowerCase();
                            if (textFiles[imageBaseName]) {
                                const tagsString = await textFiles[
                                    imageBaseName
                                ];
                                const tagsArray = parseRawTagInput(tagsString);
                                newEntryElement.setTags(tagsArray);
                            }

                            if (currentMainContentArea) {
                                let referenceNode =
                                    dropHint?.isConnected &&
                                    dropHint.parentElement ===
                                        currentMainContentArea
                                        ? dropHint
                                        : currentMainContentArea.firstChild;

                                currentMainContentArea.insertBefore(
                                    newEntryElement,
                                    referenceNode
                                );
                                importedCount++;
                            } else {
                                console.error(
                                    "mainContentAreaElement not found, cannot add imported entry."
                                );
                                errorCount++;
                            }
                        } catch (err) {
                            console.error(
                                `Error processing image ${imageName} from ZIP:`,
                                err
                            );
                            errorCount++;
                        }
                    }

                    document.querySelector(".modal-overlay")?.remove();
                    let resultMessage = `Dataset import complete. ${importedCount} entries added.`;
                    if (errorCount > 0) {
                        resultMessage += ` ${errorCount} error(s) occurred.`;
                    }
                    showConfirmationModal(resultMessage, [{ text: "OK" }]);
                    showMainAppUI();
                    // Ensure tagging tab is active after importing
                    const appTabs = document.getElementById("app");
                    if (appTabs && typeof appTabs.activateTab === "function") {
                        appTabs.activateTab(appTabs.sanitizeId("tagging"));
                    }
                    checkDropHintVisibility();
                } catch (error) {
                    console.error("Error importing dataset from ZIP:", error);
                    document.querySelector(".modal-overlay")?.remove();
                    showConfirmationModal(
                        `Error importing dataset: ${error.message}. Check console for details.`,
                        [{ text: "OK" }]
                    );
                }
            }

            function confirmAndExportDataset() {
                const currentMainContentArea =
                    document.getElementById("main-content-area");
                const currentSearchInput =
                    document.getElementById("search-bar");

                if (!currentMainContentArea || !currentSearchInput) {
                    showConfirmationModal(
                        "Cannot export: UI elements missing.",
                        [{ text: "OK" }]
                    );
                    return;
                }

                const entries =
                    currentMainContentArea.querySelectorAll("dataset-entry");
                const searchIsActive = currentSearchInput.value.trim() !== "";
                const entriesToCheck = searchIsActive
                    ? Array.from(entries).filter(
                          (entry) => entry.style.display !== "none"
                      )
                    : Array.from(entries);

                if (entriesToCheck.length === 0) {
                    if (searchIsActive && entries.length > 0) {
                        showConfirmationModal(
                            "No entries match the current filter. Export all entries instead?",
                            [
                                {
                                    text: "Export All (" + entries.length + ")",
                                    onClick: () =>
                                        exportDataset(Array.from(entries)),
                                    class: "modal-button-confirm",
                                },
                                {
                                    text: "Cancel",
                                    onClick: () => {},
                                    class: "modal-button-cancel",
                                },
                            ]
                        );
                    } else {
                        showConfirmationModal(
                            "Dataset is empty. Nothing to export.",
                            [{ text: "OK" }]
                        );
                    }
                    return;
                }

                let requirementsMet = true;
                let failingEntriesCount = 0;
                for (const entry of entriesToCheck) {
                    if (!entry.checkGroupRequirements()) {
                        requirementsMet = false;
                        failingEntriesCount++;
                    }
                }

                const exportTargetDescription = searchIsActive
                    ? "filtered"
                    : "all";
                const countDescription = `${
                    entriesToCheck.length
                } ${exportTargetDescription} entr${
                    entriesToCheck.length === 1 ? "y" : "ies"
                }`;

                if (requirementsMet) {
                    exportDataset(
                        entriesToCheck,
                        `Exporting ${countDescription}...`
                    );
                } else {
                    showConfirmationModal(
                        `Warning: ${failingEntriesCount} of the ${countDescription} do not meet minimum tag requirements. Export anyway?`,
                        [
                            {
                                text: "Export Anyway",
                                onClick: () =>
                                    exportDataset(
                                        entriesToCheck,
                                        `Exporting ${countDescription} (with warnings)...`
                                    ),
                                class: "modal-button-confirm",
                            },
                            {
                                text: "Cancel",
                                onClick: () => {},
                                class: "modal-button-cancel",
                            },
                        ]
                    );
                }
            }

            async function exportDataset(
                entriesToExport,
                description = "Exporting dataset..."
            ) {
                if (
                    typeof JSZip === "undefined" ||
                    typeof saveAs === "undefined"
                ) {
                    showConfirmationModal(
                        "Export libraries (JSZip, FileSaver) not loaded.",
                        [{ text: "OK" }]
                    );
                    return;
                }
                if (!entriesToExport || entriesToExport.length === 0) {
                    showConfirmationModal("No entries to export.", [
                        { text: "OK" },
                    ]);
                    return;
                }

                const zip = new JSZip();
                const folder = zip.folder("lora_dataset");
                let count = 0,
                    errors = 0;
                console.log(description);

                const exportMenuItem = document.querySelector(
                    'menu-item[data-action="export"]'
                );
                let originalMenuText = "Export Dataset (ZIP)";
                if (exportMenuItem) {
                    originalMenuText = exportMenuItem.textContent;
                    exportMenuItem.textContent = "Exporting...";
                    exportMenuItem.style.pointerEvents = "none";
                } else {
                    showConfirmationModal("Exporting dataset...", []);
                }

                const names = new Set();
                for (const entry of entriesToExport) {
                    count++;
                    const imgElement = entry.querySelector("img");
                    const baseNameSource =
                        entry.originalImageName || imgElement?.alt || "";

                    let baseName = baseNameSource.includes(".")
                        ? baseNameSource.substring(
                              0,
                              baseNameSource.lastIndexOf(".")
                          )
                        : baseNameSource;
                    baseName =
                        baseName || `image_${String(count).padStart(4, "0")}`;
                    baseName = sanitizeFilename(baseName);

                    const imageData = await entry.getImageData();
                    if (!imageData) {
                        console.warn(
                            `Skipping entry ${count} (${baseNameSource}): Failed to get image data.`
                        );
                        errors++;
                        continue;
                    }

                    let extension = "png";
                    if (imageData.type) {
                        const mimeType = imageData.type.split("/")[1];
                        if (mimeType === "jpeg") extension = "jpg";
                        else if (
                            ["png", "webp", "gif", "bmp", "tiff"].includes(
                                mimeType
                            )
                        )
                            extension = mimeType;
                    } else if (
                        entry.originalImageName &&
                        entry.originalImageName.includes(".")
                    ) {
                        let origExt = entry.originalImageName
                            .substring(
                                entry.originalImageName.lastIndexOf(".") + 1
                            )
                            .toLowerCase();
                        if (
                            [
                                "png",
                                "jpg",
                                "jpeg",
                                "webp",
                                "gif",
                                "bmp",
                                "tiff",
                            ].includes(origExt)
                        ) {
                            extension = origExt === "jpeg" ? "jpg" : origExt;
                        }
                    }
                    extension = extension.startsWith(".")
                        ? extension.substring(1)
                        : extension;

                    let uniqueFullName = `${baseName}.${extension}`;
                    let nameCounter = 1;
                    while (names.has(uniqueFullName.toLowerCase())) {
                        const tempBaseName = baseName.replace(/_\d+$/, "");
                        uniqueFullName = `${tempBaseName}_${nameCounter++}.${extension}`;
                    }
                    names.add(uniqueFullName.toLowerCase());

                    const tags = entry.getTagsAsString(", ");

                    folder.file(uniqueFullName, imageData, {
                        binary: true,
                    });
                    folder.file(
                        `${uniqueFullName.substring(
                            0,
                            uniqueFullName.lastIndexOf(".")
                        )}.txt`,
                        tags
                    );
                }

                document.querySelector(".modal-overlay")?.remove();

                let exportMessage = "";
                if (entriesToExport.length === 0 && errors === 0)
                    exportMessage = "No entries were exported.";
                else if (errors > 0)
                    exportMessage = `Export finished with ${errors} error(s). ${
                        entriesToExport.length - errors
                    } entries exported successfully. Check console for details.`;
                else
                    exportMessage = `Export successful! ${entriesToExport.length} entries packaged.`;

                if (
                    entriesToExport.length > 0 &&
                    errors < entriesToExport.length
                ) {
                    try {
                        const blob = await zip.generateAsync(
                            {
                                type: "blob",
                                compression: "DEFLATE",
                                compressionOptions: { level: 6 },
                            },
                            (meta) => {
                                if (exportMenuItem)
                                    exportMenuItem.textContent = `Exporting... (${meta.percent.toFixed(
                                        0
                                    )}%)`;
                            }
                        );
                        saveAs(blob, "lora_dataset_export.zip");
                        showConfirmationModal(exportMessage, [{ text: "OK" }]);
                    } catch (err) {
                        console.error("Error generating ZIP file:", err);
                        showConfirmationModal(
                            "Error generating ZIP file. Check console.",
                            [{ text: "OK" }]
                        );
                    }
                } else {
                    showConfirmationModal(exportMessage, [{ text: "OK" }]);
                }

                if (exportMenuItem) {
                    exportMenuItem.textContent = originalMenuText;
                    exportMenuItem.style.pointerEvents = "auto";
                }
            }
        </script>
    </body>
</html>
